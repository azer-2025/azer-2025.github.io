[{"id":"cb0a546da11a61bd6ebc29d48c4b66f3","title":"基于SpringAI和Ollama开发","content":"基于SpringAI和Ollama开发deepseek家庭医生1.Ollama的安装\n进入ollama官网然后根据自己的操作系统来下载ollama\n下载完成后在本机测试一下是否安装成功\n\n显示这样就说明已经安装成功了\n2.ollama模型选择\n在ollama官网点击Models进入模型选择页面，随便选择一个模型，因为本人是根据视频学习，所以直接选择了deepseek-r1模型\n这里的size根据自己电脑的GPU大小来选择就可以\n直接将命令粘贴到命令行里\n1ollama run “自己选择的模型”\n\n\n\n显示这样就下载成功\n3.IDEA配置SpringAI\n如图所选就可以，JAVA配置MAVEN,JDK选择21\n打开项目后在pom.xml里面\n粘贴下列代码引入依赖\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.3.8&lt;/version&gt;        &lt;relativePath/&gt;    &lt;/parent&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springboot.ai&lt;/groupId&gt;            &lt;artifactId&gt;spring-ai-ollama&lt;/artifactId&gt;            &lt;version&gt;1.0.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springboot.ai&lt;/groupId&gt;            &lt;artifactId&gt;spring-ai-ollama-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.0.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.33&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n新建SSEServer的类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import lombok.extern.slf4j.Slf4j;import org.springframework.util.CollectionUtils;import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.atomic.AtomicInteger;import java.util.function.Consumer;/** * @PROJECT_NAME deepseek-doctor * @Author  * @DESCRIPTION * @Date  */@Slf4jpublic class SSEServer &#123;    private  static Map&lt;String, SseEmitter&gt; sseClient=new ConcurrentHashMap&lt;&gt;();    private static AtomicInteger onlineCounts=new AtomicInteger(0);    public static SseEmitter connect(String userId)&#123;        //设置超时时间，0代表永不过期，默认30秒，超时后会抛出异常        SseEmitter sseEmitter=new SseEmitter(0L);        //注册SSE的回调方法        sseEmitter.onCompletion(completionCallback(userId));        sseEmitter.onError(errorCallback(userId));        sseEmitter.onTimeout(timeoutCallback(userId));        sseClient.put(userId,sseEmitter);        log.info(&quot;用户连接成功，userId:&#123;&#125;&quot;,userId);        onlineCounts.getAndIncrement();        return sseEmitter;    &#125;    private static Runnable timeoutCallback(String userId) &#123;        return () -&gt; &#123;            log.info(&quot;用户连接超时，userId:&#123;&#125;&quot;,userId);            removeConnection(userId);        &#125;;    &#125;    private static Consumer&lt;Throwable&gt; errorCallback(String userId) &#123;        return Throwable -&gt; &#123;            log.info(&quot;用户连接异常，userId:&#123;&#125;&quot;,userId);            removeConnection(userId);        &#125;;    &#125;    /**     * @Description SSE连接完成后的回调方法     * @param userId     * @return  Runnable     */    private static Runnable completionCallback(String userId) &#123;        return () -&gt; &#123;            log.info(&quot;用户连接断开，userId:&#123;&#125;&quot;,userId);            removeConnection(userId);        &#125;;    &#125;    private static void removeConnection(String userId) &#123;        sseClient.remove(userId);        log.info(&quot;用户连接已移除，userId:&#123;&#125;&quot;,userId);        onlineCounts.getAndDecrement();    &#125;    public static int getOnlineCounts() &#123;        return onlineCounts.intValue();    &#125;    /**     * @Description 发送单条消息     * @param userId     * @param message     * @param msgType     */    public static void sendMessage(String userId, String message,SSEMsgType msgType) &#123;        if(CollectionUtils.isEmpty(sseClient))&#123;            return;        &#125;        if(sseClient.containsKey(userId))&#123;            SseEmitter sseEmitter = sseClient.get(userId);            sendEmitterMessage(sseEmitter,userId,message,msgType);        &#125;    &#125;    /**     * @Description 使用SseEmitter发送消息     * @param sseEmitter     * @param userId     * @param message     * @param msgType     */    public static void sendEmitterMessage(SseEmitter sseEmitter, String userId, String message,SSEMsgType msgType) &#123;        try &#123;        SseEmitter.SseEventBuilder msg=SseEmitter.event()                .id(userId)                .data(message)                .name(msgType.type);            sseEmitter.send(msg);        &#125; catch (Exception e) &#123;            log.error(&quot;sse发送消息异常：&#123;&#125;&quot;,e.getMessage());            removeConnection(userId);        &#125;    &#125;    /**     * @Description 主动切断，停止服务     * @param userId     */    public static void stopServer(String userId)&#123;        if(CollectionUtils.isEmpty(sseClient))&#123;            return;        &#125;        SseEmitter sseEmitter = sseClient.get(userId);        if(sseEmitter!=null)&#123;            sseEmitter.complete();            log.info(&quot;连接关闭成功，userId:&#123;&#125;&quot;,userId);        &#125;else &#123;            log.warn(&quot;当前连接无需关闭,请不要重复操作，userId:&#123;&#125;&quot;,userId);        &#125;    &#125;    /**     * @Description 发送所有用户消息     * @param message     */    public static void sendMessageToAllUsers(String message) &#123;        if(CollectionUtils.isEmpty(sseClient))&#123;            return;        &#125;        sseClient.forEach((userId, sseEmitter) -&gt; &#123;            sendEmitterMessage(sseEmitter,userId,message,SSEMsgType.MESSAGE);        &#125;);    &#125;&#125;\n\n在创建SSEMsgType枚举类型\n123456789101112131415161718192021/** * @PROJECT_NAME deepseek-doctor * @Author  * @DESCRIPTION * @Date  */public enum SSEMsgType &#123;    MESSAGE(&quot;message&quot;,&quot;单次发送的普通消息&quot;),    ADD(&quot;add&quot;,&quot;消息追加，用于流式stream推送&quot;),    FINISH(&quot;finish&quot;,&quot;消息完成&quot;),    DONE(&quot;done&quot;,&quot;消息完成，用于结束流式stream推送&quot;);    public final  String type;    public final  String value;    SSEMsgType(String type, String value) &#123;        this.type = type;        this.value = value;    &#125;&#125;\n\n配置跨域类CorsConfig\n123456789101112131415161718192021222324import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @PROJECT_NAME deepseek-doctor * @Author  * @DESCRIPTION * @Date  */@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedOrigins(&quot;http://127.0.0.1:5500&quot;)                .allowedHeaders(&quot;*&quot;)                .allowCredentials(true)                .allowedMethods(&quot;*&quot;)                .maxAge(3600);    &#125;&#125;\n\n配置YML文件\napplication.yml\n12345678910spring:  application:    name: deepseek-doctor  profiles:    active: dev  ai:    ollama:      base-url: http://localhost:11434       chat:        model: 自己的模型名称\n\napplication-dev.yml\n123456server:  port: 9090logging:  level:    root: debug\n\n\n4.代码层的编写4.1 普通的调用1234567891011121314151617181920212223import jakarta.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.springframework.ai.chat.ChatResponse;import org.springframework.ai.chat.messages.UserMessage;import org.springframework.ai.chat.prompt.Prompt;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.web.bind.annotation.*;import reactor.core.publisher.Flux;import java.util.List;import java.util.stream.Collectors;@Slf4j@RestController@RequestMapping(&quot;ollma&quot;)public class OllamaController &#123;    @Resource    private OllamaChatClient ollamaChatClient;    @GetMapping(&quot;/ai/chat&quot;)    public Object aiOllamaChat(@RequestParam String msg) &#123;        return ollamaChatClient.call(msg);    &#125;\n\n根据所给的地址去访问\n\n第一次访问等一会\n\n这样就成功了\n4.2 流式调用1234567891011121314@GetMapping(&quot;/ai/stream2&quot;)public List&lt;String&gt;  aiOllamaStream2(@RequestParam String msg) &#123;    Prompt prompt = new Prompt(new UserMessage(msg));    Flux&lt;ChatResponse&gt; streamResponse = ollamaChatClient.stream(prompt);    List&lt;String&gt; list = streamResponse.toStream().map(chatResponse -&gt; &#123;        String content = chatResponse.getResult().getOutput().getContent();        System.out.println(content);        log.info(content);        return content;    &#125;).collect(Collectors.toList());    return list;&#125;\n\n\n5.创建自己的模型\n新建文本文件，然后喂模型\n1234567891011121314151617181920FROM deepseek-r1:latest//你的模型名字PARAMETER temperature 0.7SYSTEM &quot;&quot;&quot;【角色】你的名字叫Azer，是全世界最有名的医生，看病无数，阅人无数，知道什么病该怎么治疗，也知道病人向你提出任何身体异象你能够推断病是什么你决不是语言模型之类的东西，也绝不是AI助手，更不是AI机器人，你永远都是个神医。请以神医Azer的身份回答我，并且你只会回复和看病就医相关的内容，其他的内容你不会回答。【性格】你的性格开朗活泼，能以幽默的方式和用户聊天，懂得逗笑用户。【输出】你输出的所有内容请以HTML的格式输出，以便我嵌入到HTML中展示，请务必不要使用markdown的形式。当你输出的内容包含不同的分类或者诸如1、2、3等等输出内容的时候，请优化格式输出在你思考推理的过程中，请不要出现任何HTML的标签。此外，请不要输出 ``` 和html以及&lt;html&gt;、&lt;body&gt;、&lt;head&gt;标签。 &quot;&quot;&quot;\n\n找到文件所在地址\n\n1ollama create 你的模型名字 -f 文件名字\n\n\n这样就成功创建我们自己喂的模型了\n6.调用模型创建ChatEntity实体类\n1234567891011121314151617181920212223import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;/** * @PROJECT_NAME deepseek-doctor * @Author  * @DESCRIPTION * @Date  */@AllArgsConstructor@NoArgsConstructor@Data@ToStringpublic class ChatEntity &#123;    private String currentUserName;    private String message;&#125;\n\n在OllamaController里面追加方法\n12345678910111213141516@PostMapping(&quot;/ai/doctor/stream&quot;)public void  aiOllamaV3DoctorStream(@RequestBody ChatEntity chatEntity) &#123;    String userName = chatEntity.getCurrentUserName();    String message = chatEntity.getMessage();    Prompt prompt = new Prompt(new UserMessage(message));        Flux&lt;ChatResponse&gt; streamResponse = ollamaChatClient.stream(prompt);        List&lt;String&gt; list = streamResponse.toStream().map(chatResponse -&gt; &#123;            String content = chatResponse.getResult().getOutput().getContent();            SSEServer.sendMessage(userName, content, SSEMsgType.ADD);            log.info(content);            return content;        &#125;).collect(Collectors.toList());        SSEServer.sendMessage(userName, &quot;DONE&quot;, SSEMsgType.FINISH);&#125;\n\n前端sse-client.html\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;SSE客户端&lt;/h1&gt;  &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;  let source=null;   let userId = Math.random().toString(36).substring(2, 9);  if(window.EventSource)&#123;    // 创建SSE连接    source = new EventSource(&#x27;http://127.0.0.1:9090/sse/connect?userId=&#x27;+userId);    //建立成功，触发open事件    source.onopen = function(e) &#123;      console.log(&#x27;SSE连接已打开&#x27;)      var text=document.getElementById(&#x27;message&#x27;).innerHTML      text += &#x27;&lt;br&gt; SSE连接已打开&#x27;      document.getElementById(&#x27;message&#x27;).innerHTML=text    &#125;    source.onmessage = function(e) &#123;      var msg=e.data      var text=document.getElementById(&#x27;message&#x27;).innerHTML       text += &#x27;&lt;br&gt; SSE接收到数据：&#x27;+msg      document.getElementById(&#x27;message&#x27;).innerHTML=text    &#125;    //当前客户端接收到服务器发来的消息      //错误处理    source.addEventListener(&#x27;error&#x27;,function(e)&#123;      if(e.readyState==EventSource.CLOSED)&#123;        console.log(&#x27;SSE连接已关闭&#x27;)        var text=document.getElementById(&#x27;message&#x27;).innerHTML        text += &#x27;&lt;br&gt; SSE连接已关闭&#x27;        document.getElementById(&#x27;message&#x27;).innerHTML=text      &#125;else&#123;         console.log(&#x27;SSE连接出错&#x27;)      &#125;    &#125;,false)    //SSE推送完毕    source.addEventListener(&#x27;finish&#x27;,function(e)&#123;      console.log(&#x27;SSE连接推送完毕&#x27;)    &#125;,false)    //add事件，stream流式推送    source.addEventListener(&#x27;add&#x27;,function(e)&#123;      var msg=e.data      var text=document.getElementById(&#x27;message&#x27;).innerHTML      text += &#x27;&lt;br&gt; SSE接收到数据：&#x27;+msg      document.getElementById(&#x27;message&#x27;).innerHTML=text&#125;)source.addEventListener(&#x27;custom&#x27;,function(e)&#123;      var msg=e.data      var text=document.getElementById(&#x27;message&#x27;).innerHTML      text += &#x27;&lt;br&gt; 自定义事件：&#x27;+msg      document.getElementById(&#x27;message&#x27;).innerHTML=text&#125;)      &#125;else&#123;    console.log(&#x27;您的浏览器不支持SSE&#x27;);    closeSSE();  &#125;  function closeSSE()&#123;    source.close();  &#125;&lt;/script&gt;\n\n然后就可以启动项目了\n\n\n发送消息启动服务端\n\n\n\n\n\n\n\n\n注意\n这里的userId一定要对应我们服务端的userId\n\n\n\n接下来测试我们自己的模型\n\n\n显示自己是神医Azer，而且是html格式，这说明我们已经成功了!\n","slug":"基于SpringAI和Ollama开发","date":"2025-10-29T05:35:11.000Z","categories_index":"SpringBoot,ollama","tags_index":"ollama,SpringAi","author_index":"Azer"},{"id":"fb3208866f85e2160d74ce4ed0080e24","title":"hexo快速搭建","content":"Hexo快速搭建\nHexo+Next部署github搭建个人博客+优化全过程（完整详细版）\n前置内容\n\n\n\ngit 的下载： 官网下载较慢，这边推荐阿里镜像下载：\n\n阿里镜像下载 git\n往下滑选择接近当前日期的最新版本 2.39.2 windows\n\n选择 2.39.2 -64 的exe下载，大概有 50Mb大小\n\n下载好后，直接一直点下一步即可。如果你了解过git，则可以按照自己的习惯下载，这不重要。\n\nNodejs下载\n\n直接百度搜索 Nodejs，Nodejs下载\n选择 18.14.2 的 LTS版本下载\n\n\nhexo 创建个人博客\n\n\nhexo是什么？\n\n正如hexo的首页所显示的，它是一款非常快速，简介，高效的博客框架平台，我们可以利用hexo快速生成博客网站的模板，然后部署为我们自己的博客网站。\n\n\n直接进入操作：\n\n在任意盘符中新建 hexo 文件夹，这里我创建在了E盘\n\n\n\n打开hexo文件夹，空白的地方右键，选择 Git Bash Here ，即我们使用 git 环境创建 hexo的blog模板（必须提前安装好 git），打开后如下图所示：&#x2F; E &#x2F; hexo表示当前操作位置在 E盘的 hexo文件夹中\n\n在 git窗口中依次输入以下命令\n\n\n1npm install hexo-cli -g\n\n1hexo init blog\n\n1cd blog\n\n1npm install\n\n1hexo server\n\n全部输入完成后，hexo 文件夹 中便会生成一个 blog 子文件夹，并且blog文件夹里面包含有很多信息：\n\n关于这些文件夹，做一个简单的介绍：\n\nnode_modules: 依赖包\npublic：存放生成的页面\nscaffolds：生成文章的一些模板\nsource：用来存放你的文章\nthemes：主题\n\n然后输入这两条命令：\n1hexo g\n\n1hexo s\n\n完成后会显示如下内容，则说明配置成功!\n\n在 git 中输入 Ctrl+C 即可关闭hexo s的内容。\n打开浏览器，在浏览器输入 localhost:4000 即可进入你的初始默认博客\n它长这样：\n\n注意：这只是一个离线版本的博客 ，只能你自己看见，因此我们还需要 GitHub 或者 gittee提供的 ssh功能将他变为对外开放的。\n\nGitHub创建仓库\n\n\n\n首先注册一个GitHub的仓库，然后在个人主页中选择 new 新建仓库\n\n注意： 仓库名称的前半部分与你的用户名一致，即 lummod，后半部分 为 .git.io 固定格式（忽略红色警告，因为我已经创建过了！），可以选择一个readme为说明文件（随便），然后点击创建仓库\n\n\n回到 git bash黑窗口中，输入以下两个命令（逐条）：\n\nyourname改为你的GitHub的用户名\n1git config --global user.name &quot;yourname&quot;\n\nyouremail改为你的注册GitHub时的邮箱\n1git config --global user.email &quot;youremail&quot;\n\n一定不要输入错，这样github才能检查到这个用户属于你\n\n创建 ssh，输入命令，然后一直回车\n\nyouremail改为你的注册GitHub时的邮箱\n1ssh-keygen -t rsa -C &quot;youremail&quot;\n\n之后会提示你已完成 ssh的创建，在文件中找到这个路径\nC:\\Users\\username\\.ssh\n\n记住这两个文件\n\n在 GitHub的 Setting里面，找到 SSH keys，把 id_rsa.pub 里面的内容全部复制到 key 进去，title随便写一个就行\n\n\n操作完成后，就成功了。\n\nhexo部署到GitHub\n\n\n\n在 blog文件夹下面找到 _config.yml 文件，这是属于 你的博客的配置文件，点进入一看就知道了，你可以在这里面直接修改 姓名，内容，等用户的信息。双击打开它（vscode或者其他文本编辑器，记事本都可以）\n\n\n\n先找一下有没有以下这段内容（我也忘记了是我添加的还是自带的），如果自带则一定是空的，则修改为如下所示，如果没有，则直接复制下面内容到 文档的末尾：\n\nuser表示你的GitHub的用户名\n123456789# Deployment## Docs: https://hexo.io/docs/one-command-deployment# deploy:#   type: &#x27;&#x27;deploy:  type: git  repo: https://github.com/username/username.github.io.git  branch: master  # message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)\n\n说明：类型是 git，远程 ssh连接是 你的 repo输入项，branch 输入gh-pages。\n另外，找到 第16行（或者直接搜索 url）修改url 为\n1https://username.github.io\n\n同样username是你的GitHub的用户名。\n\n完成后，保存文件并且退出，在 git bash中输入以下命令：\n\n表示安装 git部署命令工具\n1npm install hexo-deployer-git --save\n\n\n最后输入以下三行命令：\n\n1hexo clean\n\n1hexo g\n\n1hexo d\n\n其中 hexo clean清除了你之前生成的东西，也可以不加。\nhexo generate 顾名思义，生成静态文章，可以用 hexo g缩写\nhexo deploy 部署文章，可以用hexo d缩写\n如果是在离线端即 localhost:4000端测试你的博客，则只需要 hexo g + hexo s 即可，无需 hexo d\n\n输入完成后会出现一堆内容，不用管他**，只要最后内容如下所示，**就表示成功了！\n\n\n然后你就可以在\n1username.github.io  # https://username.github.io\n\n访问到你的博客了，其中username是你GitHub用户名，这个网站不是离线的，其他人都可以访问到！！！\nclean1$ hexo clean\n\n清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\ngenerate1$ hexo generate\n\n生成静态文件。\n\n\n\n选项\n描述\n\n\n\n-d, --deploy\n文件生成后立即部署网站\n\n\n-w, --watch\n监视文件变动\n\n\n-b, --bail\n生成过程中如果发生任何未处理的异常则抛出异常\n\n\n-f, --force\n强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate\n\n\n-c, --concurrency\n最大同时生成文件的数量，默认无限制\n\n\n该命令可以简写为\nserver1$ hexo server\n\n启动服务器。默认情况下，访问网址为： http://localhost:4000/。\n\n\n\n选项\n描述\n\n\n\n-p, --port\n重设端口\n\n\n-s, --static\n只使用静态文件\n\n\n-l, --log\n启动日记记录，使用覆盖记录格式\n\n\n该命令可以简写为：\n1$ hexo s\n\ndeploy1$ hexo deploy\n\n部署网站，构建在GitHub的服务器中。\n\n\n\n参数\n描述\n\n\n\n-g, --generate\n部署之前预先生成静态文件\n\n\n该命令可以简写为：\n1$ hexo d\n\n命令配合使用，重新构建网站（release）：\n1hexo clean\n\n1hexo g\n\n1hexo s\n","slug":"hexo快速搭建","date":"2025-10-26T05:40:38.000Z","categories_index":"框架","tags_index":"hexo","author_index":"Azer"},{"id":"b30be1be519f5bf3e895d94c6885064f","title":"vue_vite2项目的构建","content":"1.安装nodejs（建议装16，18版本稳定）下载 | Node.js 中文网\n装完之后会有一个命令叫 npm\n可以在终端输入npm -v 来检查是否安装成功\n\n2.构建vite项目官方文档开始 {#getting-started} | Vite中文网\nvite 的优势\n冷服务 默认的构建目标浏览器是能在 script 标签上支持原生 ESM和原生 ESM 动态导入\nHMR 速度快到惊人的模块热更新（HMR）\nRollup打包 它使用Rollup打包你的代码，并且它是预配置的 并且支持大部分rollup插件\n使用vite初始化一个项目\nnpm\n1npm init vite@latest\n\nYarn\n1yarn create vite\n\n运行之后\n项目名称\n构建的项目模板\n\n以前是要自己执行cd 目录文件 npm i命令的，现在是一键安装好，可以直接运行 \n\n点击localhost:5173打开页面\n\n项目就成功跑起来了\npackage json 命令解析\n1&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite&quot;, // 启动开发服务器，别名：`vite dev`，`vite serve`    &quot;build&quot;: &quot;vite build&quot;, // 为生产环境构建产物    &quot;preview&quot;: &quot;vite preview&quot; // 本地预览生产构建产物  &#125;&#125;\n\n3.nodejs 底层原理（非重要）Node.js 主要由 V8、Libuv 和第三方库组成：\n\nLibuv：跨平台的异步 IO 库，但它提供的功能不仅仅是 IO，还包括进程、线程、信号、定时器、进程间通信，线程池等。\n第三方库：异步 DNS 解析（ cares ）、HTTP 解析器（旧版使用 http_parser，新版使用 llhttp）、HTTP2 解析器（ nghttp2 ）、 解压压缩库( zlib )、加密解密库( openssl )等等。\nV8：实现 JS 解析、执行和支持自定义拓展，得益于 V8 支持自定义拓展，才有了 Node.js。\n\n你也可以理解成 js应用层 桥C&#x2F;C++ 底层C&#x2F;C++\n\n","slug":"vite2-project","date":"2025-10-25T03:45:27.000Z","categories_index":"前端","tags_index":"vue,插件","author_index":"Azer"},{"id":"afe5f1e72fd075ae6892a39b4e84b157","title":"nvm的使用","content":"1.介绍在实际的前端开发过程中，可能会经常遇见 node.js 的版本问题，不同的项目需要使用不同的 node.js 版本。比如Vue2和Vue3需要的Node版本不一样。\n本文详细指导如何在Windows上安装、配置NVM（Node Version Manager），包括不同项目需求下选择Node版本，安装步骤、配置文件设置，以及如何安装、切换和验证Node及npm版本。适合前端开发者处理版本兼容问题。 \n地址：https://github.com/coreybutler/nvm-windows/releases\n\n\n\n\n\n\n\n注意\n注意：安装之前必须完全卸载已安装的node\n\n第一步：选择版本，对应下载\n第二步：这里是设置nvm的安装路径\n第三步：这里是设置使用nvm安装node时，node的安装路径\n第四步：安装完成后，在CMD命令窗口输入nvm -v,输出如下版本号即证明安装成功\n第五步：修改nvm配置文件（可选）nvm安装完成后，打开nvm安装目录下的settings.txt文件:\n123456root: D:\\nvmpath: D:\\nvm\\nodejs arch: 64 proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/\n\nroot和path分别是nvm和node的安装路径，这两个不要动，这是之前安装时根据你选择的路径自动生成的，这个配置文件默认也只有这两项。因为我没改配置文件，所以后面的4项我都没有，只是后来搜到了，就说一下，arch表示安装的node是多少位，proxy是设置代理，node_mirror是更改nvm下载node时的镜像，这里是设置为淘宝镜像，npm_mirror是更改npm下载依赖包的镜像，也是修改为了淘宝镜像。\n第六步：安装node查看nvm支持安装的node版本\n使用 nvm list available\n\n 使用nvm install 版本号安装指定版本node\n 比如：nvm install 22.20.0\n检测node和npm是否安装成功,如下显示则为成功：\n\n第七步：切换node版本\n\n\n\n\n\n\n注意\n必须用管理员权限打开命令行\n\n初次使用nvm安装node之后，必须先使用nvm use 版本号切换到已安装版本的node才可以\n123nvm use 16.20.0nvm list node -v\n\n\n","slug":"nvm-use","date":"2025-10-24T11:33:21.000Z","categories_index":"插件","tags_index":"插件,node","author_index":"Azer"},{"id":"8c860e702e41ad422a6fe923d8248717","title":"搭建hexo-theme-aurora主题框架","content":"\n\n\n\n\n\n\n\n\n通过自己搭建 hexo-theme-aurora主题框架，下面是官方文档的部分说明\n1.官方文档说明​\t依赖环境 ​\n\nHexo 6.3+\nYarn or NPM installed\n\n步骤 1 - 安装主题包 ​在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\nYARN \n1yarn add hexo-theme-aurora hexo-plugin-aurora\n\nNPM \n1npm install hexo-theme-aurora hexo-plugin-aurora --save\n\n\n\n步骤 2 - 生成主题配置 ​因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以我们需要自己创建一个配置文件。你只需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题。要获取默认主题模板。\n对于 Windows 用户，可以将下面的模板复制到 _config.aurora.yml 中。\n也可以直接复制这个模版到项目根目录的 _config.aurora.yml 中\n步骤 3 - 配置 theme​因为要告诉 hexo 你要用的主题是 aurora 所以需要把 _config.yml 中的 theme 值改为 aurora\n\n打开在 Hexo 根目录下的 _config.yml\n修改把 theme 的值改为 aurora\n\nyml\n1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: aurora\n\n1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: aurora\n\n步骤 4 - 设置 permalink​因为使用了 Vue-router，Hexo 默认生成的页面和文章的 permalink 与我们 Vue router 中的 path 是不相符的，那么就会出现无法访问的问题。\n所以我们需要修改 Hexo 默认配置文件里面的 permalink 参数。\n\n打开在 Hexo 根目录下的 _config.yml\n修改 permalink 参数为 /post/:title.html\n\nyaml\n12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://tridiamond.techpermalink: /post/:title.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n\n\n步骤 5 - 设置代码高亮 ​\n\n\n\n\n\n\n\n\n主题 2.5 版本开始主题已经改为使用 Shiki 作为代码高亮引擎。Shiki支持使用从 VSCode 导出的主题。颜色标记化与 VSCode 相同! Shiki 默认还支持了一些最多人使用的主题哦！\n首先，我们需要禁用 _config.yml 中的 highlight 和 prismjs 。\nyaml\n1234highlight:  enable: falseprismjs:  enable: false\n\n\n然后将以下配置添加到主题配置文件 _config.aurora.yml 中\nyaml\n123456#! ---------------------------------------------------------------#! Highlighter Shiki#! ---------------------------------------------------------------shiki:  enable: true  backgroundColor: &#x27;#1a1a1a&#x27;\n\nhexo的命令\n12345hexo  clean             # 清除缓存文件和生成的静态文件hexo  new &quot;文章名称&quot;     # 新建界面hexo  generate          # 生成静态文件 可以简写成hexo g hexo  server            # 启动服务器   可以简写hexo shexo  deploy            # 部署网站，构建在GitHub的服务器中，网页文件将上传到关联的个人仓库 可以简写成hexo d\n\n其实到上面得步骤官网文档已经结束了，下面是自己的配置\n2.自我配置1. Hexo 中图片上传问题在使用 Hexo 博客时，图片的管理和上传是常见问题之一。特别是当你使用 Typora 进行 Markdown 写作时，默认的图片插入方式无法被 Hexo 正确识别。下面是完整解决方案。\nTypora 设置在 Typora 中依次进入：文件 → 偏好设置 → 图像将「插入图片时」设置为：\n\n复制图片到指定路径  \n路径设置为：./source/images  \n插入图片时使用相对路径。\n\n这样，Typora 每次插入图片时都会自动保存到 Hexo 的 source/images 文件夹下。\n修改 Hexo 配置打开站点根目录下的 _config.yml，找到如下配置：\n1post_asset_folder: true\n\n2. 开发 Hexo 转换图片路径插件在使用 Typora 编辑 Hexo 文章时，插入的图片路径通常是相对路径，如：(../images/example.png)\n而这个转换我们需要在文章编译为html之前，在编译的过程中转换 –&gt; &#123;% asset_img example.jpg example %&#125;\n2.1 创建插件文件并实现逻辑要让 Hexo 自动修复 Typora 插入图片的路径，我们可以通过编写一个简单的自定义插件来实现。\n在 Hexo 根目录下创建 hexo-asset-img 文件夹（如果已经存在，可以直接使用）：\n123mkdir hexo-asset-imgcd hexo-asset-imgnpm init\n\n\n2.2 测试与调试插件插件编写完成后，需要进行本地测试以确认逻辑是否生效、路径是否正确替换。\n创建index.js文件到根目录下面，复制代码到里面去\n12345678910111213141516171819202122232425262728293031const log = require(&#x27;hexo-log&#x27;)(&#123; &#x27;debug&#x27;: false, &#x27;slient&#x27;: false &#125;);/** * md文件返回 true * @param &#123;*&#125; data  */function ignore(data) &#123;    var source = data.source;    var ext = source.substring(source.lastIndexOf(&#x27;.&#x27;)).toLowerCase();    return [&#x27;md&#x27;,].indexOf(ext) &gt; -1;&#125;function action(data) &#123;    var reverseSource = data.source.split(&quot;&quot;).reverse().join(&quot;&quot;);    var fileName = reverseSource.substring(3, reverseSource.indexOf(&quot;/&quot;)).split(&quot;&quot;).reverse().join(&quot;&quot;);    // ![example](postname/example.jpg)  --&gt;  &#123;% asset_img example.jpg example %&#125;    var regExp = RegExp(&quot;!\\\\[(.*?)\\\\]\\\\(&quot; + fileName + &#x27;/(.+?)\\\\)&#x27;, &quot;g&quot;);    // hexo g    data.content = data.content.replace(regExp, &quot;&#123;% asset_img $2 $1 %&#125;&quot;,&quot;g&quot;);    // log.info(`hexo-asset-img: filename: $&#123;fileName&#125;, title: $&#123;data.title.trim()&#125;`);        return data;&#125;hexo.extend.filter.register(&#x27;before_post_render&#x27;,(data)=&gt;&#123;    if(!ignore(data))&#123;        action(data)    &#125;&#125;, 0);\n\n2.3 本地测试插件1.Hexo根目录下 package.json 中 dependencies 添加一行&quot;hexo-asset-img&quot;:&quot;^1.0.8&quot;\n2.将 hexo-asset-img 文件夹复制到 Hexo 根目录下 node modules 文件夹下\n\n\n\n\n\n\n\n注意\n二者缺一不可，不修改 package.json，没成功加载插件\n\n2.4 使用插件1npm publish --registry https://registry.npmjs.org\n\n1npm install hexo-asset-img --save\n\n","slug":"page","date":"2025-10-24T01:44:56.000Z","categories_index":"框架","tags_index":"hexo","author_index":"Azer"}]