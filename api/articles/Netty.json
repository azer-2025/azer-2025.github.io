{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2025-11-19T05:37:44.000Z","updated":"2025-11-19T05:39:32.547Z","comments":true,"path":"api/articles/Netty.json","keywords":"VUE、Python、JAVA","cover":"/medias/Netty.png","content":"<h1 id=\"Netty网络框架详细讲解\"><a href=\"#Netty网络框架详细讲解\" class=\"headerlink\" title=\"Netty网络框架详细讲解\"></a>Netty网络框架详细讲解</h1><h2 id=\"一、Netty基本内容\"><a href=\"#一、Netty基本内容\" class=\"headerlink\" title=\"一、Netty基本内容\"></a>一、Netty基本内容</h2><h3 id=\"1-什么是netty？\"><a href=\"#1-什么是netty？\" class=\"headerlink\" title=\"1.什么是netty？\"></a>1.什么是netty？</h3><p>Netty是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。</p>\n<p>异步的：</p>\n<p>事件驱动：基于 Java NIO（Non-blocking I&#x2F;O）的 <code>Selector</code> 实现的。</p>\n<p>Netty 的核心设计目标是：</p>\n<ul>\n<li><strong>高性能</strong>：充分利用 Java NIO 的非阻塞特性。</li>\n<li><strong>可扩展性</strong>：适用于从简单客户端到复杂服务器的大多数网络应用场景。</li>\n<li><strong>易用性</strong>：提供高度抽象的 API，屏蔽 NIO 编程的复杂细节。</li>\n</ul>\n<h3 id=\"2-Netty-的核心特性\"><a href=\"#2-Netty-的核心特性\" class=\"headerlink\" title=\"2. Netty 的核心特性\"></a>2. Netty 的核心特性</h3><ol>\n<li><p><strong>异步和事件驱动</strong></p>\n<ul>\n<li>Netty 的通信是基于事件驱动的，事件由事件循环管理。</li>\n<li>异步特性让 Netty 在处理高并发时具有天然优势，避免阻塞操作。</li>\n</ul>\n</li>\n<li><p><strong>高效的线程模型</strong></p>\n<ul>\n<li>Netty 使用少量线程处理大量连接，通过 I&#x2F;O 多路复用机制实现。</li>\n<li>默认采用 Reactor 模式，分为 Boss 和 Worker 两类线程。</li>\n</ul>\n</li>\n<li><p><strong>灵活的编解码</strong></p>\n<ul>\n<li>提供丰富的编码器和解码器支持，包括 Protobuf、HTTP、WebSocket 等。</li>\n<li>支持自定义协议解析。</li>\n</ul>\n</li>\n<li><p><strong>内存管理</strong></p>\n<ul>\n<li>使用内置的 ByteBuf 代替 Java 的 ByteBuffer，提供动态扩展、零拷贝等高效操作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-初识-netty\"><a href=\"#3-初识-netty\" class=\"headerlink\" title=\"3. 初识 netty\"></a>3. 初识 netty</h3><p>在讲解netty核心组件之前，我们先通过一个简单的示例，对netty有一个整体的认识。这个示例演示的是netty处理I&#x2F;O请求的能力。</p>\n<p>service代码中，我们配置了一个线程池 <code>group</code>，用来监听到客户端的建立请求(<strong>connect</strong>)和处理 I&#x2F;O 操作，当客户端发送<strong>connect</strong>时服务端会调用<code>initChannel</code> 方法初始化客户端和服务端建立的管道 <strong>channel</strong>，之后服务端和客户端可以通过这个channel来发送和接受消息（由 <code>group</code> 处理）。而且这个channel中有ChannelPipeline，所有通过channel接收或发送的消息都会经过ChannelPipeline中添加的方法来处理。</p>\n<p>这个示例中我们只添加了当触发读事件时，通过建立的channel来获取消息，并通过服务端的ChannelPipeline来解码打印输出。 (解码：二进制转成字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;\t\t\t\t</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();                </span><br><span class=\"line\">        <span class=\"comment\">// 1. 配置和启动 Netty 服务端        \t\t\t\t</span></span><br><span class=\"line\">        <span class=\"comment\">// ServerBootstrap 负责设置服务端的各项配置，包括线程池、通道类型、事件处理器等。        </span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()                </span><br><span class=\"line\">            <span class=\"comment\">// 2. 将 group(线程池) 配置到 ServerBootstrap 中。                </span></span><br><span class=\"line\">            .group(group)                </span><br><span class=\"line\">            <span class=\"comment\">// 3. 指定了服务端使用的通道类型 NioServerSocketChannel，用于监听客户端连接               </span></span><br><span class=\"line\">            .channel(NioServerSocketChannel.class)              </span><br><span class=\"line\">            <span class=\"comment\">// 4. 设置连接到服务端的每个客户端的通道（NioSocketChannel）如何初始化              </span></span><br><span class=\"line\">            .childHandler(                      </span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;             </span><br><span class=\"line\">            <span class=\"comment\">// 6. 每当有新的客户端向服务端建立连接(connect)时，调用initChannel初始化服务端的ChannelPipeline                      </span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                           </span><br><span class=\"line\">            <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel sc)</span> <span class=\"keyword\">throws</span> Exception &#123;                              </span><br><span class=\"line\">            <span class=\"comment\">// 当服务端收到客户端信息时经过ChannelPipeline的处理                                </span></span><br><span class=\"line\">            \tsc.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringDecoder</span>());                           </span><br><span class=\"line\">                sc.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;                                   </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">                    <span class=\"comment\">// 处理接收到的消息                                   </span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;                                        System.out.println(msg);                                    </span><br><span class=\"line\">                                &#125;                                </span><br><span class=\"line\">                \t&#125;);                            </span><br><span class=\"line\">            &#125;                        </span><br><span class=\"line\">            &#125;)                </span><br><span class=\"line\">            <span class=\"comment\">// 5. 绑定端口 8888 并启动服务                </span></span><br><span class=\"line\">            .bind(<span class=\"number\">8888</span>);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>client代码中，我们配置了一个线程池group，添加了解码器，并在和服务端建立连接后通过channel发送 <code>hello world</code> 消息，通过channel 发送的消息会经过客户端的ChannelPipeline，ChannelPipeline对发送的消息进行了编码。(转成二进制)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;         </span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建一个 EventLoopGroup，用于客户端的 I/O 操作       </span></span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();         </span><br><span class=\"line\">        <span class=\"comment\">// 2. 配置和启动 Netty 客户端       </span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()               </span><br><span class=\"line\">            <span class=\"comment\">// 3. 将 group 配置到 Bootstrap 中，负责客户端的 I/O 操作        </span></span><br><span class=\"line\">            .group(group)               </span><br><span class=\"line\">            <span class=\"comment\">// 4. 指定了客户端使用的通道类型（NioSocketChannel 用于基于 NIO 的 socket 通信）                </span></span><br><span class=\"line\">            .channel(NioSocketChannel.class)             </span><br><span class=\"line\">            <span class=\"comment\">// 5. 配置客户端的 ChannelPipeline              </span></span><br><span class=\"line\">            .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;             </span><br><span class=\"line\">                <span class=\"comment\">// 7. 当客户端向服务端建立连接(connect)时调用initChannel初始化客户端的ChannelPipeline                    </span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span>                    </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel sc)</span> <span class=\"keyword\">throws</span> Exception &#123;      </span><br><span class=\"line\">                    <span class=\"comment\">// 发送消息时执行 ChannelPipeline 中的操作                       </span></span><br><span class=\"line\">                    sc.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());                   </span><br><span class=\"line\">                &#125;                </span><br><span class=\"line\">            &#125;)               </span><br><span class=\"line\">            <span class=\"comment\">// 6. 连接到服务端的 8888 端口              </span></span><br><span class=\"line\">            .connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>))                </span><br><span class=\"line\">            <span class=\"comment\">// 8. 阻塞等待直到连接成功                </span></span><br><span class=\"line\">            .sync()               </span><br><span class=\"line\">            <span class=\"comment\">// 9. 获取客户端和服务端之间的 Channel               </span></span><br><span class=\"line\">            .channel()                </span><br><span class=\"line\">            <span class=\"comment\">// 10. 向服务端发送消息               </span></span><br><span class=\"line\">            .writeAndFlush(<span class=\"string\">&quot;hello world&quot;</span>);        </span><br><span class=\"line\">        <span class=\"comment\">// 12. 关闭客户端的 EventLoopGroup，释放资源      </span></span><br><span class=\"line\">        group.shutdownGracefully();    </span><br><span class=\"line\">    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>service、client、channel、channelPipeline的关系</p>\n<p><img src=\"/post/Netty/image-20251118233727285.png\" alt=\"image-20251118233727285\"></p>\n<h2 id=\"二、Netty-的核心组件\"><a href=\"#二、Netty-的核心组件\" class=\"headerlink\" title=\"二、Netty 的核心组件\"></a>二、Netty 的核心组件</h2><h3 id=\"1-EventLoop-和-EventLoopGroup\"><a href=\"#1-EventLoop-和-EventLoopGroup\" class=\"headerlink\" title=\"1. EventLoop 和 EventLoopGroup\"></a>1. EventLoop 和 EventLoopGroup</h3><h4 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h4><p><code>EventLoop</code> 是一个 单线程的事件循环，用于处理 I&#x2F;O 操作、普通任务和定时任务。</p>\n<ul>\n<li><strong>I&#x2F;O 事件处理</strong>：<code>EventLoop</code> 会循环监听和处理 I&#x2F;O 事件（如网络连接、数据读取、数据写入等）</li>\n<li><strong>任务调度</strong>：<code>EventLoop</code> 可以执行异步任务，通常是定时任务或需要在 I&#x2F;O 线程上执行的任务。</li>\n</ul>\n<p><code>EventLoopGroup</code> 是多个 <code>EventLoop</code> 的容器，负责管理其生命周期，并为 Netty 中的 I&#x2F;O 操作分配线程。</p>\n<ul>\n<li><p>负责创建、分配和管理多个 <code>EventLoop</code>， 每个 <code>EventLoop</code> 绑定一个独立的线程。</p>\n</li>\n<li><p>为每个新连接（<code>Channel</code>）分配一个 <code>EventLoop</code>，保证 <code>Channel</code> 的事件总是由同一个 <code>EventLoop</code> 处理。</p>\n</li>\n<li><p>将任务（普通任务、定时任务、I&#x2F;O 事件）分配到 <code>EventLoop</code> 中运行。</p>\n</li>\n</ul>\n<h4 id=\"1-2-与-Channel-关联\"><a href=\"#1-2-与-Channel-关联\" class=\"headerlink\" title=\"1.2 与 Channel 关联\"></a><strong>1.2 与 Channel 关联</strong></h4><ol>\n<li><p><code>EventLoopGroup</code> 管理多个 <code>EventLoop</code>， 每个 <code>EventLoop</code> 与一个线程绑定。</p>\n</li>\n<li><p>一个 <code>EventLoop</code> 内部维护了一个 <code>selector</code> 来管理服务多个 <code>Channel</code>。</p>\n</li>\n<li><p>每个 <code>Channel</code> 绑定到唯一的 <code>EventLoop</code>，从而保证线程安全。</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-------(线程1)EventLoop1 ─── Channel1              |                   └─ Channel2              |                   └─ Channel3EventLoopGroup              |-------(线程2)EventLoop2 ─── Channel4                                 └─ Channel5</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-EventLoopGroup-的实现\"><a href=\"#1-3-EventLoopGroup-的实现\" class=\"headerlink\" title=\"1.3 EventLoopGroup 的实现\"></a>1.3 <code>EventLoopGroup</code> 的实现</h4><p><code>EventLoopGroup</code> 是一个接口，我们创建对象时要创建接口的实现，其中前三个可以处理 io操作、普通任务、定时任务，第四个不能处理I&#x2F;O操作</p>\n<table>\n<thead>\n<tr>\n<th><strong>实现</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NioEventLoopGroup</code></td>\n<td>基于 Java NIO 的 Selector，实现跨平台支持。线程池，可指定线程数，默认是cpu核心数 * 2</td>\n</tr>\n<tr>\n<td><code>EpollEventLoopGroup</code></td>\n<td>基于 Linux epoll 的实现，性能更高，但只支持 Linux。</td>\n</tr>\n<tr>\n<td><code>KQueueEventLoopGroup</code></td>\n<td>基于 macOS 和 BSD 系统的 kqueue 实现，性能更高，但只支持这些平台。</td>\n</tr>\n<tr>\n<td><code>DefaultEventLoopGroup</code></td>\n<td>不处理 I&#x2F;O 操作，仅用于普通任务调度或定时任务。只有一个线程</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-4-常用方法\"><a href=\"#1-4-常用方法\" class=\"headerlink\" title=\"1.4 常用方法\"></a>1.4 常用方法</h4><ol>\n<li><code>EventLoop</code> 的方法</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>next()</code></td>\n<td>获取当前 <code>EventLoop</code> 的下一个 <code>EventLoop</code>，通常用于轮询分配。</td>\n</tr>\n<tr>\n<td><code>submit</code></td>\n<td>提交一个有返回值的任务到当前的 <code>EventLoop</code> 中，返回一个 <code>Future</code> 用于获取结果。</td>\n</tr>\n<tr>\n<td><code>execute(Runnable task)</code></td>\n<td>提交一个任务到当前 <code>EventLoop</code> 的任务队列中执行。</td>\n</tr>\n<tr>\n<td><code>schedule</code></td>\n<td>提交一个延迟执行的任务到当前 <code>EventLoop</code> 的任务队列中执行。</td>\n</tr>\n<tr>\n<td><code>scheduleAtFixedRate</code></td>\n<td>提交一个周期性任务，每隔固定时间间隔执行。</td>\n</tr>\n<tr>\n<td><code>scheduleWithFixedDelay</code></td>\n<td>提交一个任务，每次执行完成后等待固定延迟时间再执行下一次。</td>\n</tr>\n<tr>\n<td><code>parent()</code></td>\n<td>获取当前 <code>EventLoop</code> 所属的 <code>EventLoopGroup</code>。</td>\n</tr>\n<tr>\n<td><code>register(Channel channel)</code></td>\n<td>将一个 <code>Channel</code> 注册到当前 <code>EventLoop</code>，并返回异步结果 <code>ChannelFuture</code>。</td>\n</tr>\n<tr>\n<td><code>inEventLoop()</code></td>\n<td>判断当前线程是否属于此 <code>EventLoop</code>。</td>\n</tr>\n<tr>\n<td><code>inEventLoop(Thread thread)</code></td>\n<td>判断指定线程是否属于此 <code>EventLoop</code>。</td>\n</tr>\n<tr>\n<td><code>shutdownGracefully()</code></td>\n<td>优雅地关闭当前 <code>EventLoop</code>，完成已有任务并释放资源。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>EventLoopGrop</code> 的方法</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>next()</code></td>\n<td>获取一个 <code>EventLoop</code>，通常采用轮询方式分配。</td>\n</tr>\n<tr>\n<td><code>execute(Runnable task)</code></td>\n<td>提交一个任务到某个 <code>EventLoop</code> 的任务队列中。</td>\n</tr>\n<tr>\n<td><code>schedule()</code></td>\n<td>提交一个延迟或周期性任务。</td>\n</tr>\n<tr>\n<td><code>shutdownGracefully()</code></td>\n<td>优雅地关闭所有 <code>EventLoop</code>，释放资源。优雅地是指停止接受新任务，等待之前接收到的任务执行完</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-5-执行任务\"><a href=\"#1-5-执行任务\" class=\"headerlink\" title=\"1.5 执行任务\"></a>1.5 执行任务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">EventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含4个线程的 EventLoopGroup </span></span><br><span class=\"line\"><span class=\"comment\">// 获取EventLoopEventLoop </span></span><br><span class=\"line\">eventLoop1 = group.next(); </span><br><span class=\"line\"><span class=\"comment\">// 获取一个 EventLoopEventLoop</span></span><br><span class=\"line\">eventLoop2 = group.next();</span><br><span class=\"line\"><span class=\"comment\">// 轮询获取下一个 EventLoop </span></span><br><span class=\"line\"><span class=\"comment\">// 提交任务，立即执行</span></span><br><span class=\"line\">eventLoop1.execute(() -&gt; &#123;    </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Task executed in EventLoop1: &quot;</span> + Thread.currentThread().getName());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 提交任务，延迟执行</span></span><br><span class=\"line\">eventLoop2.schedule(() -&gt; &#123;   </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Scheduled task executed in EventLoop2&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"comment\">// 延迟3秒执行任务 </span></span><br><span class=\"line\"><span class=\"comment\">// 关闭 </span></span><br><span class=\"line\">EventLoopGroupgroup.shutdownGracefully(); </span><br><span class=\"line\"><span class=\"comment\">// 优雅关闭所有 EventLoop</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-6-细分-EventLoopGroup\"><a href=\"#1-6-细分-EventLoopGroup\" class=\"headerlink\" title=\"1.6 细分 EventLoopGroup\"></a>1.6 细分 <code>EventLoopGroup</code></h4><p>在一开始给大家的代码中只用到了一个线程池来处理连接请求(connect)和处理I&#x2F;O。在实际开发中一般会单独用一个线程来处理连接请求，另一个线程池来处理I&#x2F;O操作。同时，对于比较复杂的不涉及I&#x2F;O操作的任务，我们也可以再创建一个线程池来专门处理。</p>\n<p>下面代码补充了上面讲的这两个功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;       </span><br><span class=\"line\">        <span class=\"comment\">// 创建两个 EventLoopGroup，分别处理 Boss Group 线程池 和 Worker Group 线程池     </span></span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">bossGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 只需要一个线程来接受客户端的连接请求     </span></span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">workerGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 默认为 CPU 核数 * 2 个线程处理 I/O 操作     </span></span><br><span class=\"line\">        <span class=\"type\">DefaultEventLoopGroup</span> <span class=\"variable\">defaultGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(<span class=\"number\">1</span>);      </span><br><span class=\"line\">        <span class=\"comment\">// 1. 配置和启动 Netty 服务端     </span></span><br><span class=\"line\">        <span class=\"comment\">// ServerBootstrap 负责设置服务端的各项配置，包括线程池、通道类型、事件处理器等。    </span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()               </span><br><span class=\"line\">            <span class=\"comment\">// 2. 将 Boss Group 和 Worker Group 配置到 ServerBootstrap 中。             </span></span><br><span class=\"line\">            <span class=\"comment\">// bossGroup 负责处理客户端的连接请求，workerGroup 负责处理已连接客户端的 I/O 操作                </span></span><br><span class=\"line\">            .group(bossGroup, workerGroup)               </span><br><span class=\"line\">            <span class=\"comment\">// 3. 指定了服务端使用的通道类型 NioServerSocketChannel，用于监听客户端连接                </span></span><br><span class=\"line\">            .channel(NioServerSocketChannel.class)          </span><br><span class=\"line\">            <span class=\"comment\">// 4. 设置连接到服务端的每个客户端的通道（NioSocketChannel）如何初始化           </span></span><br><span class=\"line\">            .childHandler(                     </span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;                            </span><br><span class=\"line\">                <span class=\"comment\">// 6. 每当有新的客户端向服务端建立连接(connect)时，调用initChannel初始化服务端的ChannelPipeline                            </span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span>                            </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel sc)</span> <span class=\"keyword\">throws</span> Exception &#123;       </span><br><span class=\"line\">                    <span class=\"comment\">// 当服务端收到客户端信息时经过ChannelPipeline的处理                                </span></span><br><span class=\"line\">                    sc.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringDecoder</span>());                               </span><br><span class=\"line\">                    sc.pipeline().addLast(<span class=\"string\">&quot;handle1&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;                                    \t\t<span class=\"meta\">@Override</span>  </span><br><span class=\"line\">                        <span class=\"comment\">// 处理接收到的消息                                   </span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;                                        System.out.println(msg);                                        </span><br><span class=\"line\">                        <span class=\"comment\">// 提交任务到 DefaultEventLoop 中来执行 handle2                                        </span></span><br><span class=\"line\">                                                                                                                                          defaultGroup.submit(() -&gt; &#123;                      </span><br><span class=\"line\">                                                                                                                                              <span class=\"comment\">// 在 DefaultEventLoop 中处理消息                                            </span></span><br><span class=\"line\">                                                                                                                                              System.out.println(<span class=\"string\">&quot;Handle2: &quot;</span> + msg);                                    </span><br><span class=\"line\">                                                                                                                                          &#125;);                                   </span><br><span class=\"line\">                          &#125;);                           </span><br><span class=\"line\">                    &#125;                       </span><br><span class=\"line\">               &#125;)                </span><br><span class=\"line\">                        <span class=\"comment\">// 5. 绑定端口 8888 并启动服务                </span></span><br><span class=\"line\">                   .bind(<span class=\"number\">8888</span>);    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Channel\"><a href=\"#2-Channel\" class=\"headerlink\" title=\"2. Channel\"></a>2. <strong>Channel</strong></h3><p><strong>Channel</strong> 是 Netty 中用于数据传输的核心组件，代表了 I&#x2F;O 操作的端点。它用于处理连接、接收和发送数据，并且与具体的 I&#x2F;O 模型（如 NIO、Epoll 或 KQueue）紧密集成。</p>\n<ul>\n<li><strong>Channel</strong> 主要用于处理 I&#x2F;O 操作，支持异步 I&#x2F;O 事件的处理和数据传输。</li>\n<li>在 Netty 中，<strong>Channel</strong> 是与客户端和服务端之间的连接一一对应的。</li>\n</ul>\n<h4 id=\"2-1-Channel-的类型\"><a href=\"#2-1-Channel-的类型\" class=\"headerlink\" title=\"2.1 Channel 的类型\"></a><strong>2.1 Channel 的类型</strong></h4><p>Netty 提供了多种类型的 Channel，每种类型根据不同的协议和传输方式进行优化。常见的 <code>Channel</code> 类型如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>类型</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NioServerSocketChanne</code></td>\n<td>基于 Java NIO 的 TCP 服务器通道，专门用于监听和接受传入的 TCP 连接请求。</td>\n</tr>\n<tr>\n<td><code>NioSocketChannel</code></td>\n<td>基于 Java NIO 的 TCP 客户端与服务端通道，通常用于实现基于 TCP 协议的连接。</td>\n</tr>\n<tr>\n<td><code>EpollServerSocketChannel</code></td>\n<td>基于 Linux epoll 的 TCP 服务器通道，仅支持 Linux 系统，用于监听 TCP 连接请求。</td>\n</tr>\n<tr>\n<td><code>EpollSocketChannel</code></td>\n<td>基于 Linux epoll 的通道，性能较高，只支持 Linux 系统，适用于需要高效 I&#x2F;O 操作的场景。</td>\n</tr>\n<tr>\n<td><code>NioDatagramChannel</code></td>\n<td>基于 Java NIO 的 UDP 通道，适用于 UDP 协议的网络通信。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-Channel-的基本功能\"><a href=\"#2-2-Channel-的基本功能\" class=\"headerlink\" title=\"2.2 Channel 的基本功能\"></a><strong>2.2 Channel 的基本功能</strong></h4><p>Netty 的 <code>Channel</code> 提供了一些基础的操作，以下是最常用的一些功能：</p>\n<ul>\n<li><strong>连接管理：</strong> 用于创建、绑定、连接和关闭连接。</li>\n<li><strong>数据读写：</strong> 支持从 Channel 中读取数据和向 Channel 写入数据。</li>\n<li><strong>事件触发：</strong> 可以处理来自客户端或服务器的 I&#x2F;O 事件（如接收数据、写入数据等）。</li>\n<li><strong>流量控制：</strong> 支持背压机制，控制数据的读写速率。</li>\n</ul>\n<h4 id=\"2-3-常用方法\"><a href=\"#2-3-常用方法\" class=\"headerlink\" title=\"2.3 常用方法\"></a><strong>2.3 常用方法</strong></h4><table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>connect(SocketAddress remoteAddress)</code></td>\n<td>连接到指定的远程地址（如服务端）。</td>\n</tr>\n<tr>\n<td><code>close()</code></td>\n<td>关闭当前的 Channel，释放资源。</td>\n</tr>\n<tr>\n<td><code>write(Object msg)</code></td>\n<td>向 Channel 写入数据。通常是发送到对方的缓冲区，数据并未立即发送，需要调用 <code>flush()</code> 方法来发送。</td>\n</tr>\n<tr>\n<td><code>flush()</code></td>\n<td>刷新 Channel 缓冲区，将之前写入的数据发送出去。</td>\n</tr>\n<tr>\n<td><code>read()</code></td>\n<td>从 Channel 中读取数据。</td>\n</tr>\n<tr>\n<td><code>bind(SocketAddress localAddress)</code></td>\n<td>将 Channel 绑定到本地地址，监听来自客户端的连接请求。</td>\n</tr>\n<tr>\n<td><code>isOpen()</code></td>\n<td>检查 Channel 是否已打开。返回 <code>true</code> 表示可以继续使用该 Channel，<code>false</code> 则表示已经关闭。</td>\n</tr>\n<tr>\n<td><code>isActive()</code></td>\n<td>检查 Channel 是否是活动的，即是否已经连接上远程地址并处于有效状态。</td>\n</tr>\n<tr>\n<td><code>eventLoop()</code></td>\n<td>获取当前 Channel 所绑定的 EventLoop。</td>\n</tr>\n<tr>\n<td><code>config()</code></td>\n<td>获取 Channel 配置信息，返回一个 ChannelConfig 对象，包含各种 I&#x2F;O 配置选项。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-4-ChannelPipeline\"><a href=\"#2-4-ChannelPipeline\" class=\"headerlink\" title=\"2.4 ChannelPipeline\"></a><strong>2.4 ChannelPipeline</strong></h4><p><code>ChannelPipeline</code> 是一个链式结构，负责管理 I&#x2F;O 操作的处理逻辑。在一个 <code>Channel</code> 中，每个数据的读取、写入操作都会经过一系列处理器（<code>ChannelHandler</code>）的加工。这些处理器可以执行多种任务，如编码、解码、协议解析等。</p>\n<ul>\n<li><strong>ChannelHandler</strong>：用于处理 I&#x2F;O 操作的具体业务逻辑，如编解码、业务处理、异常处理等。</li>\n<li><strong>ChannelPipeline</strong>：由多个 <code>ChannelHandler</code> 组成，形成一个处理链。每当发生 I&#x2F;O 事件时，事件会在 <code>ChannelPipeline</code> 中按照顺序流动，逐个交给对应的处理器处理。</li>\n</ul>\n<h4 id=\"2-5-获取和关闭channel\"><a href=\"#2-5-获取和关闭channel\" class=\"headerlink\" title=\"2.5 获取和关闭channel\"></a><strong>2.5 获取和关闭channel</strong></h4><p>由于<strong>connect</strong>和<strong>close</strong>方法是异步执行的，也就是在另外的线程中执行，主线程只负责调用，所以获取 <code>channel</code> 分为两种情况，一种是在主线程中获取channel并执行业务代码，另一种情况是在执行connect的线程执行业务代码。关闭channel同样，要么是主线程，要么是close的线程。</p>\n<ol>\n<li>客户端通过<strong>同步</strong>的方式获取和关闭 <code>channel</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;       </span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">connectFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()                </span><br><span class=\"line\">            .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())              </span><br><span class=\"line\">            .channel(NioSocketChannel.class)              </span><br><span class=\"line\">            .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;                </span><br><span class=\"line\">                <span class=\"meta\">@Override</span>                   </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;                       </span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());                  </span><br><span class=\"line\">                &#125;                </span><br><span class=\"line\">            &#125;)                </span><br><span class=\"line\">            .connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>);        </span><br><span class=\"line\">        <span class=\"comment\">// 1. 在主线程中获取channel，并输出    </span></span><br><span class=\"line\">        connectFuture.sync();\t</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞，直到connect线程执行成功      </span></span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> connectFuture.channel();       </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, channel);        </span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;            </span><br><span class=\"line\">            <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);           </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;                </span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> sc.nextLine();               </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">&quot;q&quot;</span>.equals(line)) &#123;                   </span><br><span class=\"line\">                    channel.close();                    </span><br><span class=\"line\">                    <span class=\"comment\">// close是异步的，所以如果在close后面直接写善后工作的代码，无法保证其在close之后执行                 </span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                </span><br><span class=\"line\">                &#125;                </span><br><span class=\"line\">                channel.writeAndFlush(line);           </span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">        &#125;).start();        </span><br><span class=\"line\">        <span class=\"comment\">// 2. 关闭channel, 并执行关闭后的善后工作       </span></span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">closeFuture</span> <span class=\"operator\">=</span> channel.closeFuture(); </span><br><span class=\"line\">        <span class=\"comment\">// 获取关闭的结果       </span></span><br><span class=\"line\">        closeFuture.sync();</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞, 直到调用close       </span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, closeFuture);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">输出</span><br><span class=\"line\">    <span class=\"number\">20</span>:<span class=\"number\">29</span>:<span class=\"number\">15.955</span> [main] - [id: <span class=\"number\">0xa8522feb</span>, L:/<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">2185</span> - R:localhost/<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">8888</span>]</span><br><span class=\"line\">    <span class=\"number\">20</span>:<span class=\"number\">29</span>:<span class=\"number\">15.960</span> [main] - <span class=\"number\">020</span>:<span class=\"number\">29</span>:<span class=\"number\">15.960</span> [main] - <span class=\"number\">1</span></span><br><span class=\"line\">        hello</span><br><span class=\"line\">        q</span><br><span class=\"line\">    <span class=\"number\">20</span>:<span class=\"number\">29</span>:<span class=\"number\">42.378</span> [main] - AbstractChannel$CloseFuture@70e9c95d(success)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>客户端通过<strong>异步</strong>的方式获取和关闭<code>channel</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;      </span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">connectFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()               </span><br><span class=\"line\">            .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())              </span><br><span class=\"line\">            .channel(NioSocketChannel.class)               </span><br><span class=\"line\">            .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;                   </span><br><span class=\"line\">                <span class=\"meta\">@Override</span>                   </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;                        </span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());             </span><br><span class=\"line\">                &#125;             </span><br><span class=\"line\">            &#125;)               </span><br><span class=\"line\">            .connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>);        </span><br><span class=\"line\">        <span class=\"comment\">// 1. 在connect线程中获取channel，并输出      </span></span><br><span class=\"line\">        connectFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;            </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>          </span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;     </span><br><span class=\"line\">                <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> future.channel();              </span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, channel);               </span><br><span class=\"line\">                <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);              </span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;                  </span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> sc.nextLine();                 </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;q&quot;</span>.equals(line)) &#123;            </span><br><span class=\"line\">                        channel.close();              </span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;                   </span><br><span class=\"line\">                    &#125;                   </span><br><span class=\"line\">                    channel.writeAndFlush(line);           </span><br><span class=\"line\">                &#125;           </span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">        &#125;);        </span><br><span class=\"line\">        <span class=\"comment\">// 2. 关闭channel, 并执行关闭后的善后工作       </span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;0&quot;</span>);       </span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">closeFuture</span> <span class=\"operator\">=</span> connectFuture.sync().channel().closeFuture();  </span><br><span class=\"line\">        <span class=\"comment\">// 关闭并返回结果       </span></span><br><span class=\"line\">        closeFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;            </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>          </span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;   </span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, future);          </span><br><span class=\"line\">            &#125;      </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察可以看到，对于异步执行业务代码都是通过 <code>ChannelFuture</code> 的 <code>addListener</code> 方法给这个future添加一个回调函数。</p>\n<h3 id=\"3-Future-和-Promise\"><a href=\"#3-Future-和-Promise\" class=\"headerlink\" title=\"3. Future 和 Promise\"></a>3. <strong>Future 和 Promise</strong></h3><p>在 Netty 中，<code>Future</code> 是一个异步操作的结果容器，用于表示当前任务的执行状态以及操作的结果或失败原因。相比于 Java 原生的 <code>Future</code> 接口，Netty 提供了功能更加强大的 <code>ChannelFuture</code> 和 <code>Promise</code>，支持<strong>异步回调</strong>和<strong>链式操作</strong>，极大地方便了异步编程。</p>\n<h4 id=\"3-1-Future-异步回调\"><a href=\"#3-1-Future-异步回调\" class=\"headerlink\" title=\"3.1 Future 异步回调\"></a>3.1 Future 异步回调</h4><ol>\n<li>同步操作</li>\n</ol>\n<p>“hello world” 由主线程输出。这点跟 <code>Java juc</code> 中的 future 相同，调用<strong>get</strong>时阻塞等待future返回结果，然后继续业务的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;      </span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">eventLoopGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();       </span><br><span class=\"line\">        <span class=\"type\">EventLoop</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> eventLoopGroup.next();    </span><br><span class=\"line\">        Future&lt;String&gt; resFuture = next.submit(() -&gt; &#123;         </span><br><span class=\"line\">            sleep(<span class=\"number\">1000</span>);          </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world&quot;</span>;       </span><br><span class=\"line\">        &#125;);     </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;main run&quot;</span>);       </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, resFuture.get());      </span><br><span class=\"line\">        eventLoopGroup.shutdownGracefully();   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">49</span>:<span class=\"number\">34.367</span> [main] - main run</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">49</span>:<span class=\"number\">35.379</span> [main] - hello world</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>异步回调</li>\n</ol>\n<p>观察输出可以看到 “hello world” 不再是由 main 线程输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;        </span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">eventLoopGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();      </span><br><span class=\"line\">        <span class=\"type\">EventLoop</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> eventLoopGroup.next();      </span><br><span class=\"line\">        Future&lt;String&gt; resFuture = next.submit(() -&gt; &#123;       </span><br><span class=\"line\">            sleep(<span class=\"number\">1000</span>);           </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world&quot;</span>;    </span><br><span class=\"line\">        &#125;);       </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;main run&quot;</span>);      </span><br><span class=\"line\">        resFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">GenericFutureListener</span>&lt;Future&lt;? <span class=\"built_in\">super</span> String&gt;&gt;() &#123;   </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>          </span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(Future&lt;? <span class=\"built_in\">super</span> String&gt; future)</span> <span class=\"keyword\">throws</span> Exception &#123;               </span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, resFuture.get());            </span><br><span class=\"line\">                eventLoopGroup.shutdownGracefully();    </span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">        &#125;);       </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;main is over&quot;</span>);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出 </span></span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">01</span>:<span class=\"number\">14.140</span> [main] - main run</span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">01</span>:<span class=\"number\">14.142</span> [main] - main is over</span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">01</span>:<span class=\"number\">15.147</span> [nioEventLoopGroup-<span class=\"number\">2</span>-<span class=\"number\">1</span>] - hello world</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-Future-状态-和-方法\"><a href=\"#3-2-Future-状态-和-方法\" class=\"headerlink\" title=\"3.2 Future 状态 和 方法\"></a><strong>3.2 Future 状态 和 方法</strong></h4><table>\n<thead>\n<tr>\n<th><strong>状态</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>未完成</strong></td>\n<td>操作还未结束，<code>Future</code> 未完成。</td>\n</tr>\n<tr>\n<td><strong>完成（成功）</strong></td>\n<td>操作成功完成，可以通过 <code>getNow()</code> 获取结果。</td>\n</tr>\n<tr>\n<td><strong>完成（失败）</strong></td>\n<td>操作失败，包含异常信息，可以通过 <code>cause()</code> 获取失败原因。</td>\n</tr>\n<tr>\n<td><strong>取消</strong></td>\n<td>操作被取消。</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>isDone()</code></td>\n<td>判断操作是否完成（无论成功或失败）。</td>\n</tr>\n<tr>\n<td><code>isSuccess()</code></td>\n<td>判断操作是否成功完成。</td>\n</tr>\n<tr>\n<td><code>cause()</code></td>\n<td>返回失败的原因，如果成功则返回 <code>null</code>。</td>\n</tr>\n<tr>\n<td><code>getNow()</code></td>\n<td>获取操作的结果（如果已经完成）。</td>\n</tr>\n<tr>\n<td><code>addListener(GenericFutureListener listener)</code></td>\n<td>添加一个监听器，在操作完成时触发回调。</td>\n</tr>\n<tr>\n<td><code>sync()</code></td>\n<td>阻塞当前线程直到操作完成，操作失败会抛出异常。</td>\n</tr>\n<tr>\n<td><code>await()</code></td>\n<td>等待操作完成，不会抛出异常。</td>\n</tr>\n<tr>\n<td><code>cancel(boolean mayInterruptIfRunning)</code></td>\n<td>取消操作。</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-3-Promise-设置状态\"><a href=\"#3-3-Promise-设置状态\" class=\"headerlink\" title=\"3.3 Promise 设置状态\"></a>3.3 <strong>Promise 设置状态</strong></h4><p>在 Netty 中，<code>Promise</code> 是 <code>Future</code> 的扩展，它不仅是一个异步操作的<strong>结果容器</strong>，还提供了手动设置操作结果的能力，可以<strong>主动控制</strong>操作完成的状态（成功或失败），而不仅仅是被动等待。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;        </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();      </span><br><span class=\"line\">        <span class=\"type\">EventLoop</span> <span class=\"variable\">eventLoop</span> <span class=\"operator\">=</span> group.next();    </span><br><span class=\"line\">        DefaultPromise&lt;String&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventLoop);\t</span><br><span class=\"line\">        <span class=\"comment\">// 手动创建      </span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;        </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;            </span><br><span class=\"line\">                sleep(<span class=\"number\">1000</span>);           </span><br><span class=\"line\">                promise.setSuccess(<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 手动设置    </span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;           </span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);   </span><br><span class=\"line\">            &#125;      </span><br><span class=\"line\">        &#125;).start();     </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;main running&quot;</span>);      </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, promise.get());    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">29</span>:<span class=\"number\">29.243</span> [main] - main running</span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">29</span>:<span class=\"number\">30.252</span> [main] - hello world</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-4-Promise-的常用方法\"><a href=\"#3-4-Promise-的常用方法\" class=\"headerlink\" title=\"3.4 Promise 的常用方法\"></a><strong>3.4 Promise 的常用方法</strong></h4><table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>setSuccess(V result)</code></td>\n<td>设置操作成功并指定结果，通知所有监听器。</td>\n</tr>\n<tr>\n<td><code>setFailure(Throwable cause)</code></td>\n<td>设置操作失败并指定失败原因，通知所有监听器。</td>\n</tr>\n<tr>\n<td><code>trySuccess(V result)</code></td>\n<td>尝试设置操作成功，成功时返回 <code>true</code>，如果操作已经完成则返回 <code>false</code>。</td>\n</tr>\n<tr>\n<td><code>tryFailure(Throwable cause)</code></td>\n<td>尝试设置操作失败，成功时返回 <code>true</code>，如果操作已经完成则返回 <code>false</code>。</td>\n</tr>\n<tr>\n<td><code>addListener(GenericFutureListener)</code></td>\n<td>添加一个监听器，在操作完成时触发回调。</td>\n</tr>\n<tr>\n<td><code>sync()</code></td>\n<td>阻塞当前线程直到操作完成，失败时抛出异常。</td>\n</tr>\n<tr>\n<td><code>await()</code></td>\n<td>等待操作完成，但不抛出异常。</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-5-Promise-与-Future-的对比\"><a href=\"#3-5-Promise-与-Future-的对比\" class=\"headerlink\" title=\"3.5 Promise 与 Future 的对比\"></a><strong>3.5 Promise 与 Future 的对比</strong></h4><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Future</strong></th>\n<th><strong>Promise</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>结果设置</strong></td>\n<td>只读，结果由操作完成后自动设置。</td>\n<td>可写，开发者可以主动设置操作的结果或失败原因。</td>\n</tr>\n<tr>\n<td><strong>监听支持</strong></td>\n<td>支持回调监听，通过 <code>addListener</code> 处理结果。</td>\n<td>支持回调监听，同时允许主动触发回调。</td>\n</tr>\n<tr>\n<td><strong>适合场景</strong></td>\n<td>用于被动等待结果的操作。</td>\n<td>用于需要主动控制结果的复杂异步操作。</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-Handler-和-Pipeline\"><a href=\"#5-Handler-和-Pipeline\" class=\"headerlink\" title=\"5. Handler 和 Pipeline\"></a>5. Handler 和 Pipeline</h3><p>在 Netty 中，<strong>Handler</strong> 是用于处理 I&#x2F;O 事件和数据的核心组件。负责在 Channel 的生命周期中处理各种事件，例如连接建立、数据读取、异常捕获等。</p>\n<p><strong>Pipeline</strong>（即 <code>ChannelPipeline</code>）是一个 <strong>双向链表</strong>，用于管理和组织多个 <strong>Handler</strong>，实现事件的分层处理和流式处理。每个 <code>Channel</code> 都关联一个 <code>ChannelPipeline</code>，它是 I&#x2F;O 事件从生成到完成的核心通道。</p>\n<h4 id=\"5-1-Handler-分类与作用\"><a href=\"#5-1-Handler-分类与作用\" class=\"headerlink\" title=\"5.1 Handler 分类与作用\"></a><strong>5.1 Handler 分类与作用</strong></h4><p>Handler 分为两种类型：</p>\n<ol>\n<li><code>ChannelInboundHandler</code></li>\n</ol>\n<p>作用：处理入站事件</p>\n<p><strong>常用方法：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>channelRead</code></td>\n<td>当有数据读取到时触发，处理入站数据。</td>\n</tr>\n<tr>\n<td><code>channelActive</code></td>\n<td>当 Channel 处于活跃状态（已连接）时触发。</td>\n</tr>\n<tr>\n<td><code>channelInactive</code></td>\n<td>当 Channel 处于非活跃状态（断开连接）时触发。</td>\n</tr>\n<tr>\n<td><code>exceptionCaught</code></td>\n<td>捕获处理过程中抛出的异常。</td>\n</tr>\n<tr>\n<td><code>userEventTriggered</code></td>\n<td>当用户自定义事件触发时调用。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>ChannelOutboundHandler</code></li>\n</ol>\n<p>作用：处理出站事件</p>\n<p><strong>常用方法：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>write</code></td>\n<td>当有数据写入时触发，处理出站数据。</td>\n</tr>\n<tr>\n<td><code>flush</code></td>\n<td>刷新写入的缓冲区数据。</td>\n</tr>\n<tr>\n<td><code>read</code></td>\n<td>触发从通道中读取数据的操作。</td>\n</tr>\n<tr>\n<td><code>close</code></td>\n<td>关闭连接时触发。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>CombinedChannelDuplexHandler</code></li>\n</ol>\n<p>作用：将一个 <code>ChannelInboundHandler</code> 和一个 <code>ChannelOutboundHandler</code> 合并到一个类中，便于同时处理入站和出站事件。</p>\n<h4 id=\"5-2-Handler和Pipeline-的工作机制\"><a href=\"#5-2-Handler和Pipeline-的工作机制\" class=\"headerlink\" title=\"5.2 Handler和Pipeline 的工作机制\"></a><strong>5.2 Handler和Pipeline 的工作机制</strong></h4><p><code>Handler</code> 是通过 <strong>ChannelPipeline</strong> 进行组织和管理的（ChannelPipeline管理着Handler）。每个 Channel 都有一个 <code>ChannelPipeline</code>，它是一个双向链表，包含一组 <code>Handler</code>。当有 I&#x2F;O 事件发生时，事件会在 <code>ChannelPipeline</code> 中沿链表传播。</p>\n<ul>\n<li><strong>入站事件传播</strong>：从链表头开始，事件依次传递给 <code>ChannelInboundHandler</code><strong>(handler的一个实现类)</strong>。</li>\n<li><strong>出站事件传播</strong>：从链表尾开始，事件依次传递给 <code>ChannelOutboundHandler</code><strong>(handler的一个实现类)</strong>。</li>\n</ul>\n<p>下面代码我们向服务端的 <strong>ChannelPipeline</strong> 中添加了 编码器、解码器、3个入站handler和3个出站handler</p>\n<p><img src=\"/post/Netty/image-20251118233811873.png\" alt=\"image-20251118233811873\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;   </span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>().group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())                </span><br><span class=\"line\">            .channel(NioServerSocketChannel.class)             </span><br><span class=\"line\">            .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;      </span><br><span class=\"line\">                <span class=\"meta\">@Override</span>                  </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;                        </span><br><span class=\"line\">                    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> ch.pipeline();         </span><br><span class=\"line\">                    pipeline.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());        </span><br><span class=\"line\">                    pipeline.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringDecoder</span>());   </span><br><span class=\"line\">                    pipeline.addLast(<span class=\"string\">&quot;h1&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;                           </span><br><span class=\"line\">                        <span class=\"meta\">@Override</span>                      </span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;                                log.info(<span class=\"string\">&quot;h1: &#123;&#125;&quot;</span>, msg);                                </span><br><span class=\"line\">\t\t\t\t\t\t\t <span class=\"built_in\">super</span>.channelRead(ctx, msg);\t<span class=\"comment\">// 将处理结果传递给下一个入站处理器                           \t\t\t\t\t &#125;                       </span></span><br><span class=\"line\">                    &#125;);                        </span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">&quot;h2&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;                            </span><br><span class=\"line\">                            <span class=\"meta\">@Override</span>                           </span><br><span class=\"line\">                            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span><br><span class=\"line\">                            &#123;                               </span><br><span class=\"line\">                                log.info(<span class=\"string\">&quot;h2: &#123;&#125;&quot;</span>, msg);                               </span><br><span class=\"line\">                                <span class=\"built_in\">super</span>.channelRead(ctx, msg);\t<span class=\"comment\">// 将处理结果传递给下一个入站处理器                            </span></span><br><span class=\"line\">                            &#125;                       </span><br><span class=\"line\">                        &#125;);                       </span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">&quot;h3&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;                            </span><br><span class=\"line\">                            <span class=\"meta\">@Override</span>                           </span><br><span class=\"line\">                            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span><br><span class=\"line\">                            &#123;                               </span><br><span class=\"line\">                                log.info(<span class=\"string\">&quot;h3: &#123;&#125;&quot;</span>, msg);                                </span><br><span class=\"line\">                                <span class=\"comment\">// super.channelRead(ctx, msg);\t\t// 没有入站处理器了，所以不用写                               \t\t\t\t </span></span><br><span class=\"line\">                                ch.writeAndFlush(msg);\t<span class=\"comment\">// 向客户端发送消息，触发出站事件                            </span></span><br><span class=\"line\">                            &#125;                       </span><br><span class=\"line\">                        &#125;);                        </span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">&quot;h4&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;                           </span><br><span class=\"line\">                            <span class=\"meta\">@Override</span>                         </span><br><span class=\"line\">                            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class=\"keyword\">throws</span> Exception &#123;                               </span><br><span class=\"line\">                                log.info(<span class=\"string\">&quot;h4 write: &#123;&#125;&quot;</span>, msg);                                </span><br><span class=\"line\">                                <span class=\"built_in\">super</span>.write(ctx, msg, promise);\t\t<span class=\"comment\">//保证了消息能够继续流动到下一个出站处理器                            </span></span><br><span class=\"line\">                            &#125;                        </span><br><span class=\"line\">                        &#125;);                       </span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">&quot;h5&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;                           </span><br><span class=\"line\">                            <span class=\"meta\">@Override</span>                         </span><br><span class=\"line\">                            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class=\"keyword\">throws</span> Exception &#123;                              </span><br><span class=\"line\">                                log.info(<span class=\"string\">&quot;h5 write: &#123;&#125;&quot;</span>, msg);                                </span><br><span class=\"line\">                                <span class=\"built_in\">super</span>.write(ctx, msg, promise);\t\t<span class=\"comment\">// 保证了消息能够继续流动到下一个出站处理器                           </span></span><br><span class=\"line\">                            &#125;                      </span><br><span class=\"line\">                        &#125;);                      </span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">&quot;h6&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;                           </span><br><span class=\"line\">                            <span class=\"meta\">@Override</span>                          </span><br><span class=\"line\">                            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class=\"keyword\">throws</span> Exception &#123;                               </span><br><span class=\"line\">                                log.info(<span class=\"string\">&quot;h6 write: &#123;&#125;&quot;</span>, msg);                                <span class=\"comment\">// </span></span><br><span class=\"line\">                                <span class=\"built_in\">super</span>.write(ctx, msg, promise);\t                       </span><br><span class=\"line\">                            &#125;                    </span><br><span class=\"line\">                        &#125;);                 </span><br><span class=\"line\">                    &#125;              </span><br><span class=\"line\">                                     &#125;).bind(<span class=\"number\">8888</span>);  </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                          <span class=\"comment\">// 当客户端发送 hello 时,输出</span></span><br><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">52</span>:<span class=\"number\">15.785</span> [nioEventLoopGroup-<span class=\"number\">2</span>-<span class=\"number\">2</span>] - h1: hello</span><br><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">52</span>:<span class=\"number\">15.787</span> [nioEventLoopGroup-<span class=\"number\">2</span>-<span class=\"number\">2</span>] - h2: hello</span><br><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">52</span>:<span class=\"number\">15.787</span> [nioEventLoopGroup-<span class=\"number\">2</span>-<span class=\"number\">2</span>] - h3: hello</span><br><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">52</span>:<span class=\"number\">15.787</span> [nioEventLoopGroup-<span class=\"number\">2</span>-<span class=\"number\">2</span>] - h6 write: hello</span><br><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">52</span>:<span class=\"number\">15.787</span> [nioEventLoopGroup-<span class=\"number\">2</span>-<span class=\"number\">2</span>] - h5 write: hello</span><br><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">52</span>:<span class=\"number\">15.787</span> [nioEventLoopGroup-<span class=\"number\">2</span>-<span class=\"number\">2</span>] - h4 write: hello</span><br></pre></td></tr></table></figure>\n\n<p><code>ChannelHandlerContext</code> 中也包含 <code>writeAndFlush</code>，如果我们把上面 h3 中的 <strong>ch.writeAndFlush(msg);</strong> 换成 <strong>ctx.writeAndFlush(msg);</strong>，可以发现写入事件并没有经过 h4，h5，h6事件处理。原因如下</p>\n<p><img src=\"/post/Netty/image-20251118233821506.png\" alt=\"image-20251118233821506\"></p>\n<h4 id=\"5-3-Handler-实现类和方法\"><a href=\"#5-3-Handler-实现类和方法\" class=\"headerlink\" title=\"5.3 Handler 实现类和方法\"></a><strong>5.3 Handler 实现类和方法</strong></h4><p>Netty 提供了以下常用的 <code>Handler</code> 实现：</p>\n<table>\n<thead>\n<tr>\n<th><strong>实现类</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ChannelInboundHandlerAdapter</code></td>\n<td><strong>入站事件</strong> 处理器的适配器，方便只实现需要的方法。(<strong>示例代码用到</strong>)</td>\n</tr>\n<tr>\n<td><code>ChannelOutboundHandlerAdapter</code></td>\n<td>**出站事件 **处理器的适配器，方便只实现需要的方法。(<strong>示例代码用到</strong>)</td>\n</tr>\n<tr>\n<td><code>SimpleChannelInboundHandler</code></td>\n<td>入站事件处理器，简化了数据类型的解析，避免手动释放 <code>ByteBuf</code>。</td>\n</tr>\n<tr>\n<td><code>ChannelDuplexHandler</code></td>\n<td>同时处理入站和出站事件的处理器。</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>方法名</strong></th>\n<th><strong>类型</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>channelRegistered</code></td>\n<td>入站</td>\n<td>Channel 被注册到 EventLoop 时触发。</td>\n</tr>\n<tr>\n<td><code>channelUnregistered</code></td>\n<td>入站</td>\n<td>Channel 从 EventLoop 中注销时触发。</td>\n</tr>\n<tr>\n<td><code>channelActive</code></td>\n<td>入站</td>\n<td>Channel 连接建立并活跃时触发（例如连接已建立）。</td>\n</tr>\n<tr>\n<td><code>channelInactive</code></td>\n<td>入站</td>\n<td>Channel 断开连接时触发。</td>\n</tr>\n<tr>\n<td><code>channelRead</code></td>\n<td>入站</td>\n<td>Channel 中有数据可读时触发。<strong>(上面的示例代码用到的就是这个)</strong></td>\n</tr>\n<tr>\n<td><code>channelReadComplete</code></td>\n<td>入站</td>\n<td>读操作完成时触发。</td>\n</tr>\n<tr>\n<td><code>write</code></td>\n<td>出站</td>\n<td>向远程发送数据时触发。<strong>(上面的示例代码用到的就是这个)</strong></td>\n</tr>\n<tr>\n<td><code>flush</code></td>\n<td>出站</td>\n<td>刷新缓冲区中的数据到远程。</td>\n</tr>\n<tr>\n<td><code>exceptionCaught</code></td>\n<td>入站&#x2F;出站</td>\n<td>捕获到异常时触发。</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-4-Pipeline-常用方法\"><a href=\"#5-4-Pipeline-常用方法\" class=\"headerlink\" title=\"5.4. Pipeline 常用方法\"></a>5.4. Pipeline 常用方法</h4><p><code>ChannelPipeline</code> 提供了一系列操作，用于管理 Handler 和触发事件。</p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>addFirst(handler)</code></td>\n<td>在链表的头部添加一个 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>addLast(handler)</code></td>\n<td>在链表的尾部添加一个 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>addBefore(baseName, handler)</code></td>\n<td>在指定的 <code>Handler</code> 之前插入一个新的 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>addAfter(baseName, handler)</code></td>\n<td>在指定的 <code>Handler</code> 之后插入一个新的 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>remove(handler)</code></td>\n<td>从 Pipeline 中移除指定的 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>replace(oldHandler, newHandler)</code></td>\n<td>替换一个现有的 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>get(handlerName)</code></td>\n<td>根据名称获取一个 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>first()</code></td>\n<td>获取第一个 <code>Handler</code>。</td>\n</tr>\n<tr>\n<td><code>last()</code></td>\n<td>获取最后一个 <code>Handler</code>。</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-ByteBuf\"><a href=\"#6-ByteBuf\" class=\"headerlink\" title=\"6. ByteBuf\"></a>6. ByteBuf</h3><p>在 Netty 中，<code>ByteBuf</code> 是一个高效的字节缓冲区，专为网络通信设计，用于替代 Java NIO 中的 <code>ByteBuffer</code>。它克服了 <code>ByteBuffer</code> 的一些局限性，如容量固定、API 繁琐等，提供了更灵活、强大的功能。</p>\n<h4 id=\"6-1-特点\"><a href=\"#6-1-特点\" class=\"headerlink\" title=\"6.1 特点\"></a><strong>6.1 特点</strong></h4><ol>\n<li><strong>动态扩容</strong>：<code>ByteBuf</code> 可以动态扩展大小，无需手动管理。</li>\n<li><strong>零拷贝</strong>：提供了一些优化数据复制的功能，如切片、复合缓冲区等。</li>\n<li><strong>读写分离</strong>：<code>ByteBuf</code> 提供了读索引和写索引，分别用于管理读写操作，避免了 <code>ByteBuffer</code> 中的 <code>flip</code> 和 <code>rewind</code>。</li>\n<li><strong>池化支持</strong>：Netty 提供了池化的 <code>ByteBuf</code>，重用池中实例，减少了内存分配和回收的开销。并且采用了内存分配算法，提升分配效率。</li>\n</ol>\n<h4 id=\"6-2-创建\"><a href=\"#6-2-创建\" class=\"headerlink\" title=\"6.2 创建\"></a><strong>6.2 创建</strong></h4><p>Netty 提供了几种方式来创建 <code>ByteBuf</code>，最常见的有以下几种：</p>\n<ol>\n<li><p><strong>堆内存 <code>ByteBuf</code></strong>：通过 <code>Unpooled.buffer()</code> 创建，分配在 JVM 堆上，适用于一般的数据处理。</p>\n</li>\n<li><p><strong>直接内存 <code>ByteBuf</code></strong>：通过 <code>Unpooled.directBuffer()</code> 创建，分配在操作系统的直接内存上，适合 I&#x2F;O 密集型应用，性能较高，但内存管理较为复杂。</p>\n</li>\n<li><p><strong>池化内存 <code>ByteBuf</code></strong>：通过 <code>PooledByteBufAllocator</code> 创建，分配的内存会存储在 Netty 内部的内存池中（堆内存或直接内存，PooledByteBufAllocator会维护一组大小不同的内存块）。在netty内存池中创建的 <code>Buffer</code> 会缓存，从而减少内存的分配和回收开销。</p>\n</li>\n</ol>\n<p>堆内存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> Unpooled.buffer(); <span class=\"comment\">// 创建一个默认大小的 ByteBuf(256)ByteBuf buf2 = Unpooled.buffer(512); // 创建一个指定大小（512字节）的 ByteBuf</span></span><br></pre></td></tr></table></figure>\n\n<p>直接内存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">directBuf</span> <span class=\"operator\">=</span> Unpooled.directBuffer(<span class=\"number\">512</span>); <span class=\"comment\">// 创建一个 512 字节的直接内存 ByteBuf</span></span><br></pre></td></tr></table></figure>\n\n<p>池化内存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">pooledBuf</span> <span class=\"operator\">=</span> PooledByteBufAllocator.DEFAULT.buffer(<span class=\"number\">512</span>); <span class=\"comment\">// 从内存池中分配 512 字节的 ByteBuf</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-常用方法\"><a href=\"#6-3-常用方法\" class=\"headerlink\" title=\"6.3 常用方法\"></a><strong>6.3 常用方法</strong></h4><table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>readByte()</code></td>\n<td>读取一个字节，并移动 <code>readerIndex</code>。</td>\n</tr>\n<tr>\n<td><code>writeByte(byte b)</code></td>\n<td>写入一个字节，并移动 <code>writerIndex</code>。</td>\n</tr>\n<tr>\n<td><code>getByte(int index)</code></td>\n<td>获取指定索引处的字节，不会改变 <code>readerIndex</code>。</td>\n</tr>\n<tr>\n<td><code>setByte(int index, byte b)</code></td>\n<td>设置指定索引处的字节，不会改变 <code>writerIndex</code>。</td>\n</tr>\n<tr>\n<td><code>readableBytes()</code></td>\n<td>返回可读字节数，即 <code>writerIndex - readerIndex</code>。</td>\n</tr>\n<tr>\n<td><code>writableBytes()</code></td>\n<td>返回可写字节数，即 <code>capacity - writerIndex</code>。</td>\n</tr>\n<tr>\n<td><code>capacity()</code></td>\n<td>返回缓冲区的容量。</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>重置 <code>readerIndex</code> 和 <code>writerIndex</code>，但数据不会被清空。</td>\n</tr>\n<tr>\n<td><code>slice(int index, int length)</code></td>\n<td>返回一个 <code>ByteBuf</code> 的切片，引用原缓冲区的数据。</td>\n</tr>\n<tr>\n<td><code>retain()</code></td>\n<td>增加引用计数，避免缓冲区被释放。</td>\n</tr>\n<tr>\n<td><code>release()</code></td>\n<td>减少引用计数，释放缓冲区。如果引用计数为 0，则缓冲区会被回收。</td>\n</tr>\n</tbody></table>\n<h4 id=\"6-4-ByteBuf-内存回收\"><a href=\"#6-4-ByteBuf-内存回收\" class=\"headerlink\" title=\"6.4 ByteBuf 内存回收\"></a><strong>6.4 ByteBuf 内存回收</strong></h4><p>在 Netty 中，<code>ByteBuf</code> 实现了 <code>ReferenceCounted</code> 接口，利用 <strong>引用计数（Reference Counting）</strong> 来管理内存的生命周期。</p>\n<ul>\n<li><strong><code>retain()</code></strong>：增加引用计数，防止缓冲区被释放。</li>\n<li><strong><code>release()</code></strong>：减少引用计数，当计数为 0 时，缓冲区会被释放。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> Unpooled.buffer(<span class=\"number\">10</span>);buf.retain();  <span class=\"comment\">// 增加引用计数buf.release(); // 减少引用计数buf.release(); // 引用计数为 0，缓冲区被释放</span></span><br></pre></td></tr></table></figure>\n\n<p>补充：对于 <strong>channelPipeline</strong> 的 <code>header</code> 和 <code>tail</code> 会检查传递到最后的如果msg依然是<strong>ByteBuf</strong>，并且没有释放的话，它会自动地调用<strong>release</strong>来释放。</p>\n<h4 id=\"6-5-零拷贝\"><a href=\"#6-5-零拷贝\" class=\"headerlink\" title=\"6.5 零拷贝\"></a><strong>6.5 零拷贝</strong></h4><h5 id=\"1-slice\"><a href=\"#1-slice\" class=\"headerlink\" title=\"1. slice\"></a>1. slice</h5><p><strong>切片操作</strong>：通过 <code>slice()</code> 可以把一个 <strong>ByteBuf</strong> 分割成多个 <strong>子ByteBuf</strong>，并且这个 <code>ByteBuf</code> 与原始 <code>ByteBuf</code> 共享内存空间，不会涉及内存拷贝。通过<code>slice()</code>获取到的新Bytebuf有独立的读写索引。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ByteBufTest</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;     </span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">bf</span> <span class=\"operator\">=</span> PooledByteBufAllocator.DEFAULT.buffer();    </span><br><span class=\"line\">        bf.writeBytes(<span class=\"string\">&quot;hello world&quot;</span>.getBytes());     </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, bf.toString(StandardCharsets.UTF_8));        </span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">bf1</span> <span class=\"operator\">=</span> bf.slice(<span class=\"number\">0</span>, <span class=\"number\">5</span>);\t<span class=\"comment\">// 下标0，5个字节       </span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, bf1.toString(StandardCharsets.UTF_8));       </span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">bf2</span> <span class=\"operator\">=</span> bf.slice(<span class=\"number\">5</span>, <span class=\"number\">6</span>);\t<span class=\"comment\">// 下标5，6个字节     </span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, bf2.toString(StandardCharsets.UTF_8));  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">33</span>:<span class=\"number\">46.831</span> [main] - hello world</span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">33</span>:<span class=\"number\">46.833</span> [main] - hello</span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">33</span>:<span class=\"number\">46.833</span> [main] -  world</span><br></pre></td></tr></table></figure>\n\n<p>注意：通过 <code>slice()</code> 获取的 ByteBuf 不存在内存的复制，它的内存还是原本 ByteBuf 的一部分，并且获取到的 ByteBuf (<code>bf1</code>，<code>bf2</code>) <strong>不会再自动增长</strong>，即不能再向其中添加字节。</p>\n<h5 id=\"2-duplicate\"><a href=\"#2-duplicate\" class=\"headerlink\" title=\"2. duplicate\"></a>2. duplicate</h5><p><code>duplicate()</code> 可以创建一个新的 ByteBuf，这个 <code>ByteBuf</code> 与原始 <code>ByteBuf</code> 共享内存空间，不会涉及内存拷贝。跟 Slice 不同的是它创建的ByteBuf是一个<strong>完整</strong>的副本，而且可以 <strong>自增长</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ByteBufTest</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class); </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;      </span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">bf</span> <span class=\"operator\">=</span> PooledByteBufAllocator.DEFAULT.buffer();    </span><br><span class=\"line\">        bf.writeBytes(<span class=\"string\">&quot;hello world&quot;</span>.getBytes());       </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, bf.toString(StandardCharsets.UTF_8));        </span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">bf1</span> <span class=\"operator\">=</span> bf.duplicate();      </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, bf1.toString(StandardCharsets.UTF_8));     </span><br><span class=\"line\">        bf1.writeByte((<span class=\"type\">byte</span>) <span class=\"string\">&#x27;W&#x27;</span>);\t<span class=\"comment\">// 可以向里面写入, 但是通过slice获取的不可以       </span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, bf1.toString(StandardCharsets.UTF_8));   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">16</span>:<span class=\"number\">51.138</span> [main] - hello world</span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">16</span>:<span class=\"number\">51.140</span> [main] - hello world</span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">16</span>:<span class=\"number\">51.140</span> [main] - hello worldW</span><br></pre></td></tr></table></figure>\n\n<p>补充：<strong>copy()</strong> 方法是深拷贝。</p>\n<h5 id=\"3-CompositeByteBuf\"><a href=\"#3-CompositeByteBuf\" class=\"headerlink\" title=\"3. CompositeByteBuf\"></a>3. CompositeByteBuf</h5><p><code>CompositeByteBuf</code> 可以用来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ByteBufTest</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;     </span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">bf1</span> <span class=\"operator\">=</span> PooledByteBufAllocator.DEFAULT.buffer();    </span><br><span class=\"line\">        bf1.writeBytes(<span class=\"string\">&quot;hello&quot;</span>.getBytes());      </span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">bf2</span> <span class=\"operator\">=</span> PooledByteBufAllocator.DEFAULT.buffer();    </span><br><span class=\"line\">        bf2.writeBytes(<span class=\"string\">&quot;world&quot;</span>.getBytes());      </span><br><span class=\"line\">        <span class=\"type\">CompositeByteBuf</span> <span class=\"variable\">bf</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();    </span><br><span class=\"line\">        bf.addComponents(<span class=\"literal\">true</span>, bf1, bf2);       </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, bf.toString(StandardCharsets.UTF_8));   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、netty进阶\"><a href=\"#三、netty进阶\" class=\"headerlink\" title=\"三、netty进阶\"></a>三、netty进阶</h2><p><strong>粘包和半包</strong>通常出现在网络编程中，尤其是在使用 TCP 协议进行数据传输时。它们是由于 TCP 是<strong>面向字节流</strong>的协议，数据发送和接收的边界并不一定和应用层数据的边界一致，从而导致的问题。</p>\n<h3 id=\"1-粘包和半包\"><a href=\"#1-粘包和半包\" class=\"headerlink\" title=\"1. 粘包和半包\"></a>1. 粘包和半包</h3><p><strong>粘包</strong>：多个小的数据包被合并在一起，接收方无法区分每个数据包的边界。通常是因为接收端的缓冲区足够大、Nagle 算法等原因。</p>\n<p>例如，发送方依次发送两个数据包：第一个包：<code>abc</code>、第二个包：<code>def</code>，如果发生粘包，接收方可能会一次性接收到合并后的数据 <code>abcdef</code>，无法知道原来是两个独立的数据包。</p>\n<p><strong>原因</strong>：</p>\n<ol>\n<li><strong>TCP 是面向字节流的</strong>：TCP 协议在发送数据时，并没有定义数据包的边界。多个小的数据包可能会被合并为一个大的数据包一起发送给接收端，接收端就无法正确识别每个数据包的开始和结束。</li>\n<li><strong>接收方的缓冲区足够大</strong>：如果接收端的缓冲区（如 <code>ByteBuf</code>）很大，可以一次性接收多个数据包而没有及时处理，就会导致多个报文被“粘”在一起。</li>\n<li><strong>Nagle 算法</strong>：Nagle 算法将小的数据包合并，以减少网络中的小包数。如果发送的数据量比较小（比如 1 字节），Nagle 算法可能会将多个小包合并为一个大包来发送，导致接收方一次接收到多个数据包，产生粘包。</li>\n</ol>\n<p><strong>半包</strong>：一个数据包被拆分成多个 TCP 包，接收方一次接收到的数据不完整。通常是由于接收缓冲区不足、MSS 限制、滑动窗口等原因。</p>\n<p>例如，发送方发送的数据包 <code>abcdef</code>，由于大小问题，接收方可能只接收到 <code>abc</code> 或 <code>def</code> 的一部分数据，剩下的部分需要等待后续的包才能拼接完整。</p>\n<p><strong>原因</strong>：</p>\n<ol>\n<li><strong>接收方缓冲区不够大</strong>：如果接收方的缓冲区（如 <code>ByteBuf</code>）小于发送的数据包大小，接收方无法一次性接收完整的数据包，只能接收部分数据。此时，剩余的数据就会继续等待。</li>\n<li><strong>滑动窗口机制</strong>：TCP 协议有一个滑动窗口机制控制流量。如果接收方的窗口（缓冲区）空间不够，它可能会分批接收数据。例如，接收方的窗口剩余空间仅有 128 字节，但发送方发送的数据包大小为 256 字节，接收方就只能先接收 128 字节，剩余部分在窗口足够时继续接收。</li>\n<li><strong>MSS 限制</strong>：MSS（最大报文段大小）是 TCP 协议中规定的最大单个数据包大小。发送的数据如果超过了 MSS，TCP 会将数据切割成多个小包进行传输。接收方可能需要多次接收才能拼接出完整的数据包。</li>\n</ol>\n<h3 id=\"2-解决粘包和半包问题\"><a href=\"#2-解决粘包和半包问题\" class=\"headerlink\" title=\"2. 解决粘包和半包问题\"></a>2. 解决粘包和半包问题</h3><h4 id=\"2-1-固定消息长度\"><a href=\"#2-1-固定消息长度\" class=\"headerlink\" title=\"2.1 固定消息长度\"></a>2.1 固定消息长度</h4><p><code>FixedLengthFrameDecoder</code> 用来指定服务端每次接受消息的长度len，如果接受到的消息小于 len，那么它会等待下个消息，并把这两个消息合并成 len 长度，然后发送；如果发送的消息长度超过 len，那么这个消息会被切割，先发送 len 长度的消息。</p>\n<p>所以，FixedLengthFrameDecoder 适合定长消息的场景，对于定长消息的场景下可以解决粘包和半包问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class); </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;    </span><br><span class=\"line\">        <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();    </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);     </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();      </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;        </span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">bind</span> <span class=\"operator\">=</span> serverBootstrap       </span><br><span class=\"line\">                .group(boss, worker)                 </span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)          </span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;    </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span>                    </span><br><span class=\"line\">                    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;                           </span><br><span class=\"line\">                        <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();                   </span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">FixedLengthFrameDecoder</span>(<span class=\"number\">10</span>));\t<span class=\"comment\">// &lt;----- 指定每次接受的长度是10                           </span></span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));      </span><br><span class=\"line\">                    &#125;                 </span><br><span class=\"line\">                &#125;).bind(<span class=\"number\">8888</span>).sync();         </span><br><span class=\"line\">            bind.channel().closeFuture().sync();     </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;          </span><br><span class=\"line\">            boss.shutdownGracefully();           </span><br><span class=\"line\">            worker.shutdownGracefully();       </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-分割符\"><a href=\"#2-2-分割符\" class=\"headerlink\" title=\"2.2 分割符\"></a>2.2 分割符</h4><ol>\n<li><code>LineBasedFrameDecoder</code> ：可以根据 <code>\\n</code> 来作为消息的分隔符，只有遇到 <code>\\n</code> 时才会发送和接受消息，同时，它可以设置一个最大消息长度，当消息长度超过这个值时会抛出异常。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class); </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;    </span><br><span class=\"line\">        <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();   </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);      </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();    </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;          </span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">bind</span> <span class=\"operator\">=</span> serverBootstrap        </span><br><span class=\"line\">                .group(boss, worker)               </span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)<span class=\"comment\">//                    </span></span><br><span class=\"line\">                .childOption(ChannelOption.RCVBUF_ALLOCATOR, <span class=\"keyword\">new</span> <span class=\"title class_\">AdaptiveRecvByteBufAllocator</span>(<span class=\"number\">16</span>, <span class=\"number\">16</span>, <span class=\"number\">16</span>))                   .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;        </span><br><span class=\"line\">                <span class=\"meta\">@Override</span>                   </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;                            </span><br><span class=\"line\">                    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();            </span><br><span class=\"line\">                    pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LineBasedFrameDecoder</span>(<span class=\"number\">16</span>));\t<span class=\"comment\">// &lt;----- 指定最大长度                            </span></span><br><span class=\"line\">                    pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));        </span><br><span class=\"line\">                &#125;                 </span><br><span class=\"line\">            &#125;).bind(<span class=\"number\">8888</span>).sync();           </span><br><span class=\"line\">            bind.channel().closeFuture().sync();     </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;          </span><br><span class=\"line\">            boss.shutdownGracefully();     </span><br><span class=\"line\">            worker.shutdownGracefully();     </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>DelimiterBasedFrameDecoder</code> ：跟 <code>LineBasedFrameDecoder</code>类似，只不过它可以指定分隔符是什么。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;  </span><br><span class=\"line\">        <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>(); </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);   </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();      </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;          </span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">bind</span> <span class=\"operator\">=</span> serverBootstrap            </span><br><span class=\"line\">                .group(boss, worker)         </span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)<span class=\"comment\">//                    </span></span><br><span class=\"line\">                .childOption(ChannelOption.RCVBUF_ALLOCATOR, <span class=\"keyword\">new</span> <span class=\"title class_\">AdaptiveRecvByteBufAllocator</span>(<span class=\"number\">16</span>, <span class=\"number\">16</span>, <span class=\"number\">16</span>))                   .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;                        <span class=\"meta\">@Override</span>                       </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;   </span><br><span class=\"line\">                    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();             </span><br><span class=\"line\">                    pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">DelimiterBasedFrameDecoder</span>(<span class=\"number\">16</span>, Unpooled.wrappedBuffer(<span class=\"string\">&quot;A&quot;</span>.getBytes())));\t<span class=\"comment\">// &lt;---- 指定最大长度和分割符                    </span></span><br><span class=\"line\">                    pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));     </span><br><span class=\"line\">                &#125;                 </span><br><span class=\"line\">            &#125;).bind(<span class=\"number\">8888</span>).sync();   </span><br><span class=\"line\">            bind.channel().closeFuture().sync();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">            boss.shutdownGracefully();     </span><br><span class=\"line\">            worker.shutdownGracefully(); </span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-LengthFieldBasedFrameDecoder\"><a href=\"#2-3-LengthFieldBasedFrameDecoder\" class=\"headerlink\" title=\"2.3 LengthFieldBasedFrameDecoder\"></a>2.3 <code>LengthFieldBasedFrameDecoder</code></h4><p><code>LengthFieldBasedFrameDecoder</code> 通过指定每个消息前面携带一些额外的信息来解决粘包和半包问题，是比较常用的处理粘包和半包的处理器</p>\n<p><code>LengthFieldBasedFrameDecoder</code> 是要求每个单独的消息前面都加上一个len，来指定 content 有多长（content是我们真正需要的消息）。当content长度小于len时，消息不会继续向下传递，而是在 <code>pip.addLast(new LengthFieldBasedFrameDecoder(128, 0, 4, 0, 4));</code> 这里等待，直到content的长度等于len时，才会继续向下传递，所以 <code>LengthFieldBasedFrameDecoder</code> 可以解决粘包和半包问题。</p>\n<p><code>LengthFieldBasedFrameDecoder</code> 接受5个参数，第一个参数是消息的最大长度，超过最大长度会抛出异常。其余四个参数含义如下</p>\n<p><img src=\"/post/Netty/image-20251118233833884.png\" alt=\"image-20251118233833884\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;    </span><br><span class=\"line\">        <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();  </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);     </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();       </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;        </span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">bind</span> <span class=\"operator\">=</span> serverBootstrap      </span><br><span class=\"line\">                .group(boss, worker)               </span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)    </span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;          </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span>                </span><br><span class=\"line\">                    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;   </span><br><span class=\"line\">                        <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();       </span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(<span class=\"number\">128</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>));                           </span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));      </span><br><span class=\"line\">                    &#125;              </span><br><span class=\"line\">                &#125;).bind(<span class=\"number\">8888</span>).sync();           </span><br><span class=\"line\">            bind.channel().closeFuture().sync(); </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;        </span><br><span class=\"line\">            boss.shutdownGracefully();      </span><br><span class=\"line\">            worker.shutdownGracefully();  </span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 发送的消息是 5hello// 接受到的是 hello，因为我们的第5个参数是4，去除4个字节，即数字5</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-http-和-自定义协议\"><a href=\"#3-http-和-自定义协议\" class=\"headerlink\" title=\"3. http 和 自定义协议\"></a>3. http 和 自定义协议</h3><p>针对不同的协议，netty提供了很多封装好的 <strong>编解码处理器</strong>，通过这个处理器我们可以很容易的基于某个协议来<strong>解析</strong>收到的消息和对发送的消息<strong>编码</strong>。当然我们也可以自定义协议，通过实现接口自定义编解码器。</p>\n<h4 id=\"3-1-http\"><a href=\"#3-1-http\" class=\"headerlink\" title=\"3.1 http\"></a>3.1 http</h4><p>添加<code>HttpServerCodec</code> 后，对于接的所有消息都会根据 http 协议 进行解析，所有发送的消息也会根据http协议封装。对于一个传入的消息，经过http协议解析后会分成两次消息，分别是 <code>HttpRequest</code> （请求头）或 <code>HttpContent</code> （请求体, get 的请求体为空）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4jpublic</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HttpTest</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;   </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);   </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();   </span><br><span class=\"line\">        <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();       </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;          </span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">bind</span> <span class=\"operator\">=</span> bootstrap        </span><br><span class=\"line\">            .group(boss, worker)                 </span><br><span class=\"line\">            .channel(NioServerSocketChannel.class)             </span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;   </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span>                      </span><br><span class=\"line\">                    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;  </span><br><span class=\"line\">                        <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();         </span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));                            </span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">HttpServerCodec</span>());            </span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123; </span><br><span class=\"line\">                            <span class=\"comment\">// 指定类型，只接受HttpRequest的消息                                @Override                               </span></span><br><span class=\"line\">                            <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class=\"keyword\">throws</span> Exception &#123;                               </span><br><span class=\"line\">                                log.info(msg.uri());             </span><br><span class=\"line\">                                <span class=\"type\">byte</span>[] resp = <span class=\"string\">&quot;&lt;h1&gt;hello world&lt;h1/&gt;&quot;</span>.getBytes();                                   </span><br><span class=\"line\">                                <span class=\"type\">DefaultFullHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultFullHttpResponse</span>(msg.protocolVersion(),                                            HttpResponseStatus.OK);</span><br><span class=\"line\">                                <span class=\"comment\">// 设置响应的http版本和状态码                                    </span></span><br><span class=\"line\">                                response.headers().setInt(CONTENT_LENGTH, resp.length); <span class=\"comment\">// 设置http的内容长度，如果不设置浏览器会一直尝试获取content                      </span></span><br><span class=\"line\">                                response.content().writeBytes(resp);    <span class=\"comment\">// 把要返回的内容写道content中                                    </span></span><br><span class=\"line\">                                ctx.writeAndFlush(response);    <span class=\"comment\">// 通过channel发送数据给客户端                               </span></span><br><span class=\"line\">                            &#125;                        </span><br><span class=\"line\">                        &#125;);            </span><br><span class=\"line\">                    &#125;                 </span><br><span class=\"line\">                &#125;)                </span><br><span class=\"line\">                .bind(<span class=\"number\">8888</span>)                 </span><br><span class=\"line\">                .sync();         </span><br><span class=\"line\">            bind.channel().closeFuture().sync();    </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;        </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);     </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;    </span><br><span class=\"line\">            boss.shutdownGracefully();           </span><br><span class=\"line\">            worker.shutdownGracefully();     </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-自定义协议\"><a href=\"#3-2-自定义协议\" class=\"headerlink\" title=\"3.2 自定义协议\"></a>3.2 自定义协议</h4><p>上面我们简介介绍了一下http的编解码器，我们也可以根据 <strong>自定义的协议</strong>可以实现<strong>自定义解码器</strong>中的 decode 方法，编码器中的 edcode方法，也可以继承 <code>ByteToMessageCodec</code> 或 <code>MessageToMessageCodec</code>, 实现其中的 decode 和 encode 方法</p>\n<ul>\n<li><strong>解码器</strong>（<code>ByteToMessageDecoder</code>）：将字节流解析为应用层的消息。</li>\n<li><strong>编码器</strong>（<code>MessageToByteEncoder</code>）：将应用层的消息编码为字节流。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于将 二进制 与 消息 对象之间进行转换的工具类。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodec</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ByteToMessageCodec</span>&lt;MyMessage&gt; &#123;   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>   </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, MyMessage msg, ByteBuf out)</span> <span class=\"keyword\">throws</span> Exception &#123;\t</span><br><span class=\"line\">        <span class=\"comment\">// 将 msg 转化成 按照自定义协议的 二进制字节流   </span></span><br><span class=\"line\">        <span class=\"comment\">// 编码后的字节流将被写入这个 ByteBuf 中，最终通过 Netty 传输到网络  </span></span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;\t\t</span><br><span class=\"line\">        <span class=\"comment\">// 将从网络接收到的字节流 in 解码成 MyMessage 对象。       </span></span><br><span class=\"line\">        <span class=\"comment\">// List&lt;Object&gt; out：解码后的消息对象将被添加到这个列表中，供后续的处理流程使用。   </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于将 消息 与 消息 对象之间进行转换的工具类。这里设置的输入消息类型是 ByteBuf，输出的类型是MyMessage</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodec</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MessageToMessageCodec</span>&lt;ByteBuf, MyMessage&gt; &#123;  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, MyMessage msg, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;            </span><br><span class=\"line\">        &#125;     </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>   </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-线程安全性\"><a href=\"#4-线程安全性\" class=\"headerlink\" title=\"4. 线程安全性\"></a>4. 线程安全性</h3><p><strong><code>@ChannelHandler.Sharable</code></strong> 标记用于表明该 <code>ChannelHandler</code> 是线程安全的，并且可以在多个 <code>Channel</code> 之间共享。</p>\n<p>观察可以发现对于 <code>LengthFieldBasedFrameDecoder</code>，我们并没有把他提取成一个变量，这是由于它是线程不安全的，每个客户端发送消息到服务端都会经过各自<strong>channel</strong>的<strong>pipeLine</strong>进行加工，当发送的消息的 content 不足时，由于 <strong>LengthFieldBasedFrameDecoder</strong>的存在，消息并不会继续向下传递，而是保存当前消息的状态，直到content满足len时才会被发送。在多线程的环境下每个channel都需要一个 LengthFieldBasedFrameDecoder 才可以。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4jpublic</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;    </span><br><span class=\"line\">        <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();    </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);    </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();    </span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">logHandler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);    </span><br><span class=\"line\">        <span class=\"type\">MessageCodec</span> <span class=\"variable\">messageCodec</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodec</span>();       </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;        </span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">bind</span> <span class=\"operator\">=</span> bootstrap         </span><br><span class=\"line\">                .group(boss, worker)            </span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)   </span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;        </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span>                 </span><br><span class=\"line\">                    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;     </span><br><span class=\"line\">                        <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();           </span><br><span class=\"line\">                        pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(<span class=\"number\">128</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>));\t<span class=\"comment\">// 处理粘包、半包                           </span></span><br><span class=\"line\">                        pip.addLast(logHandler);\t<span class=\"comment\">// &lt;------ 打印输出日志                            </span></span><br><span class=\"line\">                        pip.addLast(messageCodec);\t<span class=\"comment\">// &lt;------ 自定义消息编解码器                        &#125;                   </span></span><br><span class=\"line\">                    &#125;)              </span><br><span class=\"line\">                        .bind(<span class=\"number\">8888</span>)               </span><br><span class=\"line\">                        .sync();          </span><br><span class=\"line\">                    bind.channel().closeFuture().sync();   </span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;       </span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);       </span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;    </span><br><span class=\"line\">                    boss.shutdownGracefully();      </span><br><span class=\"line\">                    worker.shutdownGracefully();   </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>补充：在 <code>3.2</code> 中 <strong>ByteToMessageCodec</strong> 和 <strong>MessageToMessageCodec</strong> 除了输入的消息类型不同外，通过继承 <strong>ByteToMessageCodec</strong> 实现的自定义编解码器默认是线程不安全的，不能加 <code>@ChannelHandler.Sharable</code> 注解，因为<strong>ByteToMessageCodec</strong> 中会检测，如果其子类加这个注解的话会报错。但其实是否线程安全还要看代码逻辑，对于不存储状态、可以在多个 <code>Channel</code> 中共享的handler都可以作为线程安全的。</p>\n<h3 id=\"5-空闲检测和心脏跳动\"><a href=\"#5-空闲检测和心脏跳动\" class=\"headerlink\" title=\"5. 空闲检测和心脏跳动\"></a>5. 空闲检测和心脏跳动</h3><h4 id=\"5-1-空闲检测\"><a href=\"#5-1-空闲检测\" class=\"headerlink\" title=\"5.1 空闲检测\"></a>5.1 空闲检测</h4><p><code>IdleStateHandler</code> 是 Netty 中一个用于处理 <strong>空闲状态</strong>（idle state）事件的 <code>ChannelHandler</code>。它用于检测 <strong>连接在指定时间内是否处于空闲状态</strong>，并触发相应的事件。常用于 <strong>连接超时、心跳检测</strong> 等场景。</p>\n<p>如果在指定的时间段内没有发生任何入站（读）或出站（写）的操作，<code>IdleStateHandler</code> 就会触发一个 <code>IdleStateEvent</code>。触发<code>IdleStateEvent</code>事件时，会调用 <code>userEventTriggered</code> 来处理超时逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IdleStateHandler 接受四个参数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">IdleStateHandler</span><span class=\"params\">(   </span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">long</span> readerIdleTime, // 读空闲时间 </span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">long</span> writerIdleTime, // 写空闲时间   </span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">long</span> allIdleTime,    // 读写空闲时间 </span></span><br><span class=\"line\"><span class=\"params\">    TimeUnit unit        // 时间单位</span></span><br><span class=\"line\"><span class=\"params\">)</span> </span><br><span class=\"line\">    <span class=\"meta\">@Slf4j</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;   </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;     </span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();       </span><br><span class=\"line\">            <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);      </span><br><span class=\"line\">            <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();       </span><br><span class=\"line\">            <span class=\"type\">LoggingHandler</span> <span class=\"variable\">logHandler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG); </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;         </span><br><span class=\"line\">                <span class=\"type\">ChannelFuture</span> <span class=\"variable\">bind</span> <span class=\"operator\">=</span> bootstrap       </span><br><span class=\"line\">                    .group(boss, worker)                  </span><br><span class=\"line\">                    .channel(NioServerSocketChannel.class)          </span><br><span class=\"line\">                    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;                        </span><br><span class=\"line\">                        <span class=\"meta\">@Override</span>                   </span><br><span class=\"line\">                        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;                            </span><br><span class=\"line\">                            <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();                           </span><br><span class=\"line\">                            pip.addLast(logHandler);         </span><br><span class=\"line\">                            pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateHandler</span>(<span class=\"number\">5</span>,<span class=\"number\">0</span>, <span class=\"number\">0</span>, TimeUnit.SECONDS));                           </span><br><span class=\"line\">                            pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelDuplexHandler</span>() &#123;\t</span><br><span class=\"line\">                                <span class=\"comment\">// 双向的 处理器，既能处理 入站事件,也可以处理 出站事件                               </span></span><br><span class=\"line\">                                <span class=\"meta\">@Override</span>\t                 </span><br><span class=\"line\">                                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception &#123;                                 </span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (evt <span class=\"keyword\">instanceof</span> IdleStateEvent) &#123;\t<span class=\"comment\">// 判断是否是 IdleStateEvent 事件                                        </span></span><br><span class=\"line\">                                        <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> (IdleStateEvent) evt;                                       </span><br><span class=\"line\">                                        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, event.state());                                       </span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (event.state() == IdleState.READER_IDLE) &#123;                                            </span><br><span class=\"line\">                                            log.info(<span class=\"string\">&quot;读超时 &#123;&#125;&quot;</span>, event.state());                                            </span><br><span class=\"line\">                                            ctx.close(); <span class=\"comment\">// 关闭通道                     </span></span><br><span class=\"line\">                                        &#125;                 </span><br><span class=\"line\">                                    &#125;                        </span><br><span class=\"line\">                                &#125;                           </span><br><span class=\"line\">                            &#125;);                  </span><br><span class=\"line\">                        &#125;            </span><br><span class=\"line\">                    &#125;)                   </span><br><span class=\"line\">                    .bind(<span class=\"number\">8888</span>)           </span><br><span class=\"line\">                    .sync();         </span><br><span class=\"line\">                bind.channel().closeFuture().sync();     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;      </span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);      </span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;         </span><br><span class=\"line\">                boss.shutdownGracefully();   </span><br><span class=\"line\">                worker.shutdownGracefully();   </span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-心脏跳动\"><a href=\"#5-2-心脏跳动\" class=\"headerlink\" title=\"5.2 心脏跳动\"></a>5.2 心脏跳动</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBufAllocator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.timeout.IdleState;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory; </span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Main.class);  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;    </span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();     </span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">connectFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()            </span><br><span class=\"line\">            .group(group)            </span><br><span class=\"line\">            .channel(NioSocketChannel.class)   </span><br><span class=\"line\">            .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;       </span><br><span class=\"line\">                <span class=\"meta\">@Override</span>                </span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;  </span><br><span class=\"line\">                    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pip</span> <span class=\"operator\">=</span> ch.pipeline();          </span><br><span class=\"line\">                    pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateHandler</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>, <span class=\"number\">0</span>, TimeUnit.SECONDS));</span><br><span class=\"line\">                    <span class=\"comment\">// 添加写空闲时间                  </span></span><br><span class=\"line\">                    pip.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelDuplexHandler</span>() &#123;\t     </span><br><span class=\"line\">                        <span class=\"meta\">@Override</span>\t              </span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception &#123;                         </span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (evt <span class=\"keyword\">instanceof</span> IdleStateEvent) &#123;         </span><br><span class=\"line\">                                <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> (IdleStateEvent) evt;                                   </span><br><span class=\"line\">                                log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, event.state());         </span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;                                       </span><br><span class=\"line\">                                    ctx.writeAndFlush(<span class=\"string\">&quot;心脏跳动&quot;</span>);\t<span class=\"comment\">// 每三秒向服务端发送一次消息                                       </span></span><br><span class=\"line\">                                    log.info(<span class=\"string\">&quot;发送数据，心脏跳动 &#123;&#125;&quot;</span>, event.state());                                 </span><br><span class=\"line\">                                &#125;                               </span><br><span class=\"line\">                            &#125;                         </span><br><span class=\"line\">                        &#125;                     </span><br><span class=\"line\">                    &#125;);                  </span><br><span class=\"line\">                &#125;            </span><br><span class=\"line\">            &#125;)              </span><br><span class=\"line\">            .connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>);      </span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">closeFuture</span> <span class=\"operator\">=</span> connectFuture.channel().closeFuture(); </span><br><span class=\"line\">        <span class=\"comment\">// 获取关闭的结果      </span></span><br><span class=\"line\">        closeFuture.sync(); <span class=\"comment\">// 阻塞, 直到调用close      </span></span><br><span class=\"line\">        group.shutdownGracefully();    </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, closeFuture);  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、netty的调优参数\"><a href=\"#四、netty的调优参数\" class=\"headerlink\" title=\"四、netty的调优参数\"></a>四、netty的调优参数</h2><p>Netty 的参数调整通常分为两类：<strong>服务端参数</strong> 和 <strong>客户端参数</strong>，以及<strong>与性能相关的其他细节</strong>。具体来说，Netty 调整的参数可以从以下几个方面来分类：</p>\n<h4 id=\"1-服务端\"><a href=\"#1-服务端\" class=\"headerlink\" title=\"1. 服务端\"></a>1. <strong>服务端</strong></h4><p>这些参数主要用于配置服务端的 <code>ServerBootstrap</code> 和监听的 <code>ServerSocketChannel</code>，它们影响服务器接受连接的方式及性能。</p>\n<ul>\n<li><p><strong><code>option</code></strong>：设置与服务端 <code>ServerSocketChannel</code> 本身相关的选项。 </p>\n<ul>\n<li><code>SO_BACKLOG</code>：连接请求队列的大小。增加队列大小可以处理更多的并发连接请求。(全连接，半连接)</li>\n<li><code>SO_REUSEADDR</code>：允许端口地址重用，通常用于服务器重启时快速复用端口。</li>\n<li><code>SO_RCVBUF</code>：接收缓冲区的大小。调整该值可以控制接收数据的能力。</li>\n<li><code>SO_SNDBUF</code>：发送缓冲区的大小。调整该值可以控制发送数据的能力。</li>\n</ul>\n</li>\n<li><p><strong><code>childOption</code></strong>：设置与每个客户端连接的 <code>SocketChannel</code> 相关的网络选项。 </p>\n<ul>\n<li><code>TCP_NODELAY</code>：是否启用 Nagle 算法，适用于需要低延迟的场景。</li>\n<li><code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code>：调整每个客户端连接的接收和发送缓冲区大小。</li>\n<li><code>SO_KEEPALIVE</code>：启用 TCP 保持活动（即连接活跃检测），用于防止连接超时。</li>\n<li><code>SO_LINGER</code>：控制关闭连接时的延迟。设置为 0 则会立即关闭连接。</li>\n<li><code>IP_TOS</code>：设置 IP 服务类型，用于区分不同类型的流量优先级。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-客户端\"><a href=\"#2-客户端\" class=\"headerlink\" title=\"2. 客户端\"></a>2. <strong>客户端</strong></h4><p>这些参数用于配置客户端 <code>Bootstrap</code> 和 <code>SocketChannel</code>，主要影响客户端连接和通信的行为。</p>\n<ul>\n<li><p><strong><code>option</code></strong>：设置与客户端连接的 <code>SocketChannel</code> 相关的网络选项。 </p>\n<ul>\n<li><code>CONNECT_TIMEOUT_MILLIS</code>：设置客户端连接超时的最大时长，超时则连接失败。</li>\n<li><code>SO_RCVBUF</code>：客户端接收缓冲区的大小。</li>\n<li><code>SO_SNDBUF</code>：客户端发送缓冲区的大小。</li>\n<li><code>SO_KEEPALIVE</code>：启用 TCP 保持活动。</li>\n</ul>\n</li>\n<li><p><strong><code>handler</code></strong>：用于配置客户端的事件处理器，例如请求的编码解码、业务逻辑处理等。</p>\n</li>\n</ul>\n","feature":true,"text":"Netty网络框架详细讲解一、Netty基本内容1.什么是netty？Netty是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器...","permalink":"/post/Netty","photos":[],"count_time":{"symbolsCount":"57k","symbolsTime":"52 mins."},"categories":[{"name":"网络通信","slug":"网络通信","count":3,"path":"api/categories/网络通信.json"}],"tags":[{"name":"网络通信","slug":"网络通信","count":3,"path":"api/tags/网络通信.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Netty%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3\"><span class=\"toc-text\">Netty网络框架详细讲解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Netty%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">一、Netty基本内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFnetty%EF%BC%9F\"><span class=\"toc-text\">1.什么是netty？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Netty-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">2. Netty 的核心特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%88%9D%E8%AF%86-netty\"><span class=\"toc-text\">3. 初识 netty</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Netty-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">二、Netty 的核心组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-EventLoop-%E5%92%8C-EventLoopGroup\"><span class=\"toc-text\">1. EventLoop 和 EventLoopGroup</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E4%B8%8E-Channel-%E5%85%B3%E8%81%94\"><span class=\"toc-text\">1.2 与 Channel 关联</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-EventLoopGroup-%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">1.3 EventLoopGroup 的实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.4 常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-5-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">1.5 执行任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-6-%E7%BB%86%E5%88%86-EventLoopGroup\"><span class=\"toc-text\">1.6 细分 EventLoopGroup</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Channel\"><span class=\"toc-text\">2. Channel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-Channel-%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.1 Channel 的类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-Channel-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">2.2 Channel 的基本功能</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.3 常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-ChannelPipeline\"><span class=\"toc-text\">2.4 ChannelPipeline</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E8%8E%B7%E5%8F%96%E5%92%8C%E5%85%B3%E9%97%ADchannel\"><span class=\"toc-text\">2.5 获取和关闭channel</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Future-%E5%92%8C-Promise\"><span class=\"toc-text\">3. Future 和 Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-Future-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">3.1 Future 异步回调</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-Future-%E7%8A%B6%E6%80%81-%E5%92%8C-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.2 Future 状态 和 方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-Promise-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">3.3 Promise 设置状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-Promise-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.4 Promise 的常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-Promise-%E4%B8%8E-Future-%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">3.5 Promise 与 Future 的对比</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Handler-%E5%92%8C-Pipeline\"><span class=\"toc-text\">5. Handler 和 Pipeline</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-Handler-%E5%88%86%E7%B1%BB%E4%B8%8E%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">5.1 Handler 分类与作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-Handler%E5%92%8CPipeline-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">5.2 Handler和Pipeline 的工作机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-Handler-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">5.3 Handler 实现类和方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-4-Pipeline-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">5.4. Pipeline 常用方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-ByteBuf\"><span class=\"toc-text\">6. ByteBuf</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">6.1 特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">6.2 创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">6.3 常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-4-ByteBuf-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">6.4 ByteBuf 内存回收</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-5-%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">6.5 零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-slice\"><span class=\"toc-text\">1. slice</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-duplicate\"><span class=\"toc-text\">2. duplicate</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-CompositeByteBuf\"><span class=\"toc-text\">3. CompositeByteBuf</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81netty%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">三、netty进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">1. 粘包和半包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2. 解决粘包和半包问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E5%9B%BA%E5%AE%9A%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">2.1 固定消息长度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E5%88%86%E5%89%B2%E7%AC%A6\"><span class=\"toc-text\">2.2 分割符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-LengthFieldBasedFrameDecoder\"><span class=\"toc-text\">2.3 LengthFieldBasedFrameDecoder</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-http-%E5%92%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">3. http 和 自定义协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-http\"><span class=\"toc-text\">3.1 http</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">3.2 自定义协议</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7\"><span class=\"toc-text\">4. 线程安全性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B%E5%92%8C%E5%BF%83%E8%84%8F%E8%B7%B3%E5%8A%A8\"><span class=\"toc-text\">5. 空闲检测和心脏跳动</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">5.1 空闲检测</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E5%BF%83%E8%84%8F%E8%B7%B3%E5%8A%A8\"><span class=\"toc-text\">5.2 心脏跳动</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81netty%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">四、netty的调优参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">1. 服务端</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">2. 客户端</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"WebSocket","uid":"2db4480eaccada3af93deb830f4fe8c2","slug":"WebSocket","date":"2025-11-16T03:28:45.000Z","updated":"2025-11-16T03:44:20.763Z","comments":true,"path":"api/articles/WebSocket.json","keywords":"VUE、Python、JAVA","cover":"/medias/WebSocket.png","text":"一、 简介1.1 什么是 WebSocketWebSocket是一种 协议，用于在Web应用程序和服务器之间建立实时、双向的通信连接。它通过一个单一的TCP连接...","permalink":"/post/WebSocket","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"网络通信","slug":"网络通信","count":3,"path":"api/categories/网络通信.json"}],"tags":[{"name":"网络通信","slug":"网络通信","count":3,"path":"api/tags/网络通信.json"}],"author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}},"feature":true}}