{"title":"Ai Tool","uid":"f3cc45dde1c6d3f1266c71ae166c094a","slug":"Ai-Tool","date":"2025-11-08T14:48:33.000Z","updated":"2025-11-08T14:53:25.082Z","comments":true,"path":"api/articles/Ai-Tool.json","keywords":"VUE、Python、JAVA","cover":"/medias/tool.png","content":"<h2 id=\"一、需求分析\"><a href=\"#一、需求分析\" class=\"headerlink\" title=\"一、需求分析\"></a>一、需求分析</h2><p>之前我们通过 RAG 技术让 AI 应用具备了根据外部知识库来获取信息并回答的能力，但是直到目前为止，AI 应用还只是个 “知识问答助手”。本节我们可以利用 <strong>工具调用</strong> 特性，实现更多需求。</p>\n<p>1）联网搜索</p>\n<p>比如智能推荐约会地点，示例用户提问：</p>\n<ul>\n<li>周末想带女朋友去上海约会，推荐几个适合情侣的小众打卡地？</li>\n<li>女朋友生气了，有哪些温柔的哄人技巧？</li>\n</ul>\n<p>2）网页抓取</p>\n<p>比如分析恋爱案例，示例用户提问：</p>\n<ul>\n<li>最近和对象吵架了，看看其他情侣是怎么解决矛盾的？</li>\n</ul>\n<p>3）资源下载</p>\n<p>比如恋爱相关的图片 &#x2F; 音视频下载，示例用户提问：</p>\n<ul>\n<li>下载一张适合做手机壁纸的星空情侣图片</li>\n<li>推荐并下载几首适合约会时播放的钢琴曲</li>\n</ul>\n<p>4）终端操作</p>\n<p>比如执行代码来生成恋爱报告，示例用户提问：</p>\n<ul>\n<li>执行 Python 脚本来生成数据分析报告</li>\n</ul>\n<p>5）文件操作</p>\n<p>比如保存用户恋爱档案，示例用户提问：</p>\n<ul>\n<li>帮我保存我的恋爱档案为文件</li>\n</ul>\n<p>6）PDF 生成</p>\n<p>比如恋爱计划、情感分析报告 PDF 生成，示例用户提问：</p>\n<ul>\n<li>生成一份《七夕约会计划》PDF，包含餐厅预订、活动流程和礼物清单</li>\n<li>分析我和对象近一个月的聊天记录，生成情感报告</li>\n</ul>\n<p>而且这些需求还⁠可以进行组合，比如用户先让 ‌AI 联网搜索约会地点、再下载约会地点的图片、最后将获取‎到的内容组合生成 PDF、并‌保存到本地，一条龙服务。</p>\n<p>如果 AI⁠ 能够完成上述需求，‌就不再只是一个有知识的 “大脑”，而是有‎手有脚，会利用工具完‌成任务的 “智能体” 了。</p>\n<p>下面我们就来学习下实现上述需求的关键 —— <strong>工具调用</strong> 技术。</p>\n<h2 id=\"二、工具调用介绍\"><a href=\"#二、工具调用介绍\" class=\"headerlink\" title=\"二、工具调用介绍\"></a>二、工具调用介绍</h2><h3 id=\"什么是工具调用？\"><a href=\"#什么是工具调用？\" class=\"headerlink\" title=\"什么是工具调用？\"></a>什么是工具调用？</h3><p>工具调用（Tool Calling）可以理解为让 AI 大模型 <strong>借用外部工具</strong> 来完成它自己做不到的事情。</p>\n<p>跟人类一样⁠，如果只凭手脚完成‌不了工作，那么就可以利用工具箱来完成‎。</p>\n<p>工具可以是⁠任何东西，比如网页‌搜索、对外部 API 的调用、访问外‎部数据、或执行特定‌的代码等。</p>\n<p>比如用户提⁠问 “帮我查询上海最‌新的天气”，AI 本身并没有这些知识，它‎就可以调用 “查询天‌气工具”，来完成任务。</p>\n<p>目前工具调⁠用技术发展的已经比较‌成熟了，几乎所有主流的、新出的 AI 大‎模型和 AI 应用开‌发平台都支持工具调用。</p>\n<h3 id=\"工具调用的工作原理\"><a href=\"#工具调用的工作原理\" class=\"headerlink\" title=\"工具调用的工作原理\"></a>工具调用的工作原理</h3><p>其实，工具调用的工作原理非常简单，<strong>并不是 AI 服务器自己调用这些工具、也不是把工具的代码发送给 AI 服务器让它执行</strong>，它只能提出要求，表示 “我需要执行 XX 工具完成任务”。而真正执行工具的是我们自己的应用程序，执行后再把结果告诉 AI，让它继续工作。</p>\n<p>举个例子，⁠假如用户提问 “github网站有哪些热门文章？”，就需要‎经历下列流程：</p>\n<ol>\n<li>用户提出问题：”github网站有哪些热门文章？”</li>\n<li>程序将问题传递给大模型</li>\n<li>大模型分析问题，判断需要使用工具（网页抓取工具）来获取信息</li>\n<li>大模型输出工具名称和参数（网页抓取工具）</li>\n<li>程序接收工具调用请求，执行网页抓取操作</li>\n<li>工具执行抓取并返回文章数据</li>\n<li>程序将抓取结果传回给大模型</li>\n<li>大模型分析网页内容，生成关于github热门文章的回答</li>\n<li>程序将大模型的回答返回给用户</li>\n</ol>\n<p><img src=\"/post/Ai-Tool/image-20251108134043880.png\" alt=\"image-20251108134043880\"></p>\n<p>虽然看起来是 AI 在调用工具，但实际上整个过程是 <strong>由我们的应用程序控制的</strong>。AI 只负责决定什么时候需要用工具，以及需要传递什么参数，真正执行工具的是我们的程序。</p>\n<p>你可能会好⁠奇，为啥要这么设计‌呢？这样不是要让程序请求 AI 多次‎么？为啥不让 AI‌ 服务器直接调用工具程序？</p>\n<p>有这个想法很正常，但如果让你自己设计一个 AI 大模型服务，你就能理解了。很关键的一点是 <strong>安全性</strong>，AI 模型永远无法直接接触你的 API 或系统资源，所有操作都必须通过你的程序来执行，这样你可以完全控制 AI 能做什么、不能做什么。</p>\n<p>举个例子，你有一个爆破工具⁠，用户像 AI 提了需求 ” 我要拆这栋房子 “，虽然‌ AI 表示可以用爆破工具，但是需要经过你的同意，才能执行爆破。反之，如果把爆破工具植入给 AI，A‎I 觉得自己能炸了，就炸了，不需要再问你的意见。而‌且这样也给 AI 服务器本身增加了压力。</p>\n<h3 id=\"工具调用和功能调用\"><a href=\"#工具调用和功能调用\" class=\"headerlink\" title=\"工具调用和功能调用\"></a>工具调用和功能调用</h3><p>大家可能看到过 F⁠unction Calling（功‌能调用）这个概念，别担心，其实它和 Tool Calling（工具调‎用）完全是同一概念！只是不同平台或‌每个人习惯的叫法不同而已。</p>\n<p><a href=\"https://docs.spring.io/spring-ai/reference/api/tools.html\">Spring AI 工具调用文档</a> 的开头就说明了这一点：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108134105559.png\" alt=\"image-20251108134105559\"></p>\n<h3 id=\"工具调用的技术选型\"><a href=\"#工具调用的技术选型\" class=\"headerlink\" title=\"工具调用的技术选型\"></a>工具调用的技术选型</h3><p>我们先来梳理一下工具调用的流程：</p>\n<ol>\n<li>工具定义：程序告诉 AI “你可以使用这些工具”，并描述每个工具的功能和所需参数</li>\n<li>工具选择：AI 在对话中判断需要使用某个工具，并准备好相应的参数</li>\n<li>返回意图：AI 返回 “我想用 XX 工具，参数是 XXX” 的信息</li>\n<li>工具执行：我们的程序接收请求，执行相应的工具操作</li>\n<li>结果返回：程序将工具执行的结果发回给 AI</li>\n<li>继续对话：AI 根据工具返回的结果，生成最终回答给用户</li>\n</ol>\n<p>通过上述流程，我们会发现，⁠程序需要和 AI 多次进行交互、还要能够执行对应的‌工具，怎么实现这些呢？我们当然可以自主开发，不过还是更推荐使用 Spring AI、LangChai‎n 等开发框架。此外，有些 AI 大模型服务商也提‌供了对应的 SDK，都能够简化代码编写。</p>\n<p>💡 需要注意的是，不是所有大模型都支持工具调用。有些基础模型或早期版本可能不支持这个能力。可以在 <a href=\"https://docs.spring.io/spring-ai/reference/api/chat/comparison.html\">Spring AI 官方文档</a> 中查看各模型支持情况。</p>\n<h2 id=\"三、Spring-AI-工具开发\"><a href=\"#三、Spring-AI-工具开发\" class=\"headerlink\" title=\"三、Spring AI 工具开发\"></a>三、Spring AI 工具开发</h2><p>首先我们通过 <a href=\"https://docs.spring.io/spring-ai/reference/api/tools.html\">Spring AI 官方</a> 提供的图片来理解 Spring AI 在实现工具调用时都帮我们做了哪些事情？</p>\n<p><img src=\"/post/Ai-Tool/image-20251108134135431.png\" alt=\"image-20251108134135431\"></p>\n<ol>\n<li>工具定义与注册：Spring AI 可以通过简洁的注解自动生成工具定义和 JSON Schema，让 Java 方法轻松转变为 AI 可调用的工具。</li>\n<li>工具调用请求：Spring AI 自动处理与 AI 模型的通信并解析工具调用请求，并且支持多个工具链式调用。</li>\n<li>工具执行：Spring AI 提供统一的工具管理接口，自动根据 AI 返回的工具调用请求找到对应的工具并解析参数进行调用，让开发者专注于业务逻辑实现。</li>\n<li>处理工具结果：Spring AI 内置结果转换和异常处理机制，支持各种复杂 Java 对象作为返回值并优雅处理错误情况。</li>\n<li>返回结果给模型：Spring AI 封装响应结果并管理上下文，确保工具执行结果正确传递给模型或直接返回给用户。</li>\n<li>生成最终响应：Spring AI 自动整合工具调用结果到对话上下文，支持多轮复杂交互，确保 AI 回复的连贯性和准确性。</li>\n</ol>\n<p>下面是一个较早版本的流程图，也能帮助我们理解这个过程：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108134250665.png\" alt=\"image-20251108134250665\"></p>\n<h3 id=\"定义工具\"><a href=\"#定义工具\" class=\"headerlink\" title=\"定义工具\"></a>定义工具</h3><h4 id=\"工具定义模式\"><a href=\"#工具定义模式\" class=\"headerlink\" title=\"工具定义模式\"></a>工具定义模式</h4><p>在 Spr⁠ing AI 中，定‌义工具主要有两种模式：基于 Method‎s 方法或者 Fun‌ctions 函数式编程。</p>\n<p>记结论就行了，我们只用学习 <strong>基于 Methods 方法</strong> 来定义工具，另外一种了解即可。原因是 Methods 方式更容易编写、更容易理解、支持的参数和返回类型更多。</p>\n<p>二者的详细对比：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Methods 方式</th>\n<th>Functions 方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义方式</td>\n<td>使用 @Tool 和 @ToolParam 注解标记类方法</td>\n<td>使用函数式接口并通过 Spring Bean 定义</td>\n</tr>\n<tr>\n<td>语法复杂度</td>\n<td>简单，直观</td>\n<td>较复杂，需要定义请求 &#x2F;⁠响应对象</td>\n</tr>\n<tr>\n<td>支持的参数类型</td>\n<td>大多数 Java 类型，包括基本类型、POJO、集合等</td>\n<td>不支持基本类型、O‌ptional、集合类型</td>\n</tr>\n<tr>\n<td>支持的返回类型</td>\n<td>几乎所有可序列化类型，包括 void</td>\n<td>不支持基本类型、Optional、集合类型等</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>适合大多数新项目开发</td>\n<td>适合与现有函数式 API 集成</td>\n</tr>\n<tr>\n<td>注册方式</td>\n<td>‎支持按需注册和全局注册</td>\n<td>通常在配置类中预先定义</td>\n</tr>\n<tr>\n<td>类型转换</td>\n<td>自动处理</td>\n<td>需要更多手动配置</td>\n</tr>\n<tr>\n<td>文档支持 ‌</td>\n<td>通过注解提供描述</td>\n<td>通过 Bean 描述和 JSON 属性注解</td>\n</tr>\n</tbody></table>\n<p>举个例子来对比这两种定义模式：</p>\n<p>1）Methods 模式：通过 <code>@Tool</code> 注解定义工具，通过 <code>tools</code> 方法绑定工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class WeatherTools &#123;</span><br><span class=\"line\">    @Tool(description = &quot;Get current weather for a location&quot;)</span><br><span class=\"line\">    public String getWeather(@ToolParam(description = &quot;The city name&quot;) String city) &#123;</span><br><span class=\"line\">        return &quot;Current weather in &quot; + city + &quot;: Sunny, 25°C&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ChatClient.create(chatModel)</span><br><span class=\"line\">    .prompt(&quot;What&#x27;s the weather in Beijing?&quot;)</span><br><span class=\"line\">    .tools(new WeatherTools())</span><br><span class=\"line\">    .call();</span><br></pre></td></tr></table></figure>\n\n<p>2）Functions 模式：通过 <code>@Bean</code> 注解定义工具，通过 <code>functions</code> 方法绑定工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class ToolConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    @Description(&quot;Get current weather for a location&quot;)</span><br><span class=\"line\">    public Function&lt;WeatherRequest, WeatherResponse&gt; weatherFunction() &#123;</span><br><span class=\"line\">        return request -&gt; new WeatherResponse(&quot;Weather in &quot; + request.getCity() + &quot;: Sunny, 25°C&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ChatClient.create(chatModel)</span><br><span class=\"line\">    .prompt(&quot;What&#x27;s the weather in Beijing?&quot;)</span><br><span class=\"line\">    .functions(&quot;weatherFunction&quot;)</span><br><span class=\"line\">    .call();</span><br></pre></td></tr></table></figure>\n\n<p>显然 Met⁠hods 模式的开发量更‌少（我估计很多同学都没写过 Function 函‎数式编程），更推荐这种方‌式，所以下面重点讲解这种方式。</p>\n<h4 id=\"定义工具-1\"><a href=\"#定义工具-1\" class=\"headerlink\" title=\"定义工具\"></a>定义工具</h4><p>Spring AI 提供了两种定义工具的方法 —— <strong>注解式</strong> 和 <strong>编程式</strong>。</p>\n<p>1）注解式：只需使用 <code>@Tool</code> 注解标记普通 Java 方法，就可以定义工具了，简单直观。</p>\n<p>每个工具最好都添加详细清晰的描述，帮助 AI 理解何时应该调用这个工具。对于工具方法的参数，可以使用 <code>@ToolParam</code> 注解提供额外的描述信息和是否必填。</p>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class WeatherTools &#123;</span><br><span class=\"line\">    @Tool(description = &quot;获取指定城市的当前天气情况&quot;)</span><br><span class=\"line\">    String getWeather(@ToolParam(description = &quot;城市名称&quot;) String city) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return &quot;北京今天晴朗，气温25°C&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）编程式⁠：如果想在运行时动‌态创建工具，可以选择编程式来定义工具，‎更灵活。</p>\n<p>先定义工具类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class WeatherTools &#123;</span><br><span class=\"line\">    String getWeather(String city) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return &quot;北京今天晴朗，气温25°C&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后将工具类⁠转换为 ToolCall‌back 工具定义类，之后就可以把这个类绑定给 ‎ChatClient，从‌而让 AI 使用工具了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method method = ReflectionUtils.findMethod(WeatherTools.class, &quot;getWeather&quot;, String.class);</span><br><span class=\"line\">ToolCallback toolCallback = MethodToolCallback.builder()</span><br><span class=\"line\">    .toolDefinition(ToolDefinition.builder(method)</span><br><span class=\"line\">            .description(&quot;获取指定城市的当前天气情况&quot;)</span><br><span class=\"line\">            .build())</span><br><span class=\"line\">    .toolMethod(method)</span><br><span class=\"line\">    .toolObject(new WeatherTools())</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<p>其实你会发⁠现，编程式就是把注‌解式的那些参数，改成通过调用方法来设置‎了而已。</p>\n<p>在定义工具时，需要注⁠意方法参数和返回值类型的选择。Sprin‌g AI 支持大多数常见的 Java 类型作为参数和返回值，包括基本类型、复杂对象、‎集合等。而且返回值需要是可序列化的，‌因为它将被发送给 AI 大模型。</p>\n<p>以下类型目前不支持作为工具方法的参数或返回类型：</p>\n<ul>\n<li>Optional</li>\n<li>异步类型（如 CompletableFuture, Future）</li>\n<li>响应式类型（如 Flow, Mono, Flux）</li>\n<li>函数式类型（如 Function, Supplier, Consumer）</li>\n</ul>\n<h3 id=\"使用工具\"><a href=\"#使用工具\" class=\"headerlink\" title=\"使用工具\"></a>使用工具</h3><p>定义好工具后⁠，Spring AI ‌提供了多种灵活的方式将工具提供给 ChatC‎lient，让 AI ‌能够在需要时调用这些工具。</p>\n<p>1）按需使用：这是最简单的方式，直接在构建 ChatClient 请求时通过 <code>tools()</code> 方法附加工具。这种方式适合只在特定对话中使用某些工具的场景。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String response = ChatClient.create(chatModel)</span><br><span class=\"line\">    .prompt(&quot;北京今天天气怎么样？&quot;)</span><br><span class=\"line\">    .tools(new WeatherTools())  </span><br><span class=\"line\">    .call()</span><br><span class=\"line\">    .content();</span><br></pre></td></tr></table></figure>\n\n<p>2）全局使用：如⁠果某些工具需要在所有对话中都可用‌，可以在构建 ChatClient 时注册默认工具。这样，这些工‎具将对从同一个 ChatClie‌nt 发起的所有对话可用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChatClient chatClient = ChatClient.builder(chatModel)</span><br><span class=\"line\">    .defaultTools(new WeatherTools(), new TimeTools())  </span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<p>3）更底层的使用方⁠式：除了给 ChatClient ‌绑定工具外，也可以给更底层的 ChatModel 绑定工具（毕竟工具‎调用是 AI 大模型支持的能力），‌适合需要更精细控制的场景。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ToolCallback[] weatherTools = ToolCallbacks.from(new WeatherTools());</span><br><span class=\"line\"></span><br><span class=\"line\">ChatOptions chatOptions = ToolCallingChatOptions.builder()</span><br><span class=\"line\">    .toolCallbacks(weatherTools)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Prompt prompt = new Prompt(&quot;北京今天天气怎么样？&quot;, chatOptions);</span><br><span class=\"line\">chatModel.call(prompt);</span><br></pre></td></tr></table></figure>\n\n<p>4）动态解析：一般情况下，使用前面 3 种方式即可。对于更复杂的应用，Spring AI 还支持通过 <code>ToolCallbackResolver</code> 在运行时动态解析工具。这种方式特别适合工具需要根据上下文动态确定的场景，比如从数据库中根据工具名搜索要调用的工具。在本节的工具进阶知识中会讲到，先了解到有这种方式即可。</p>\n<p>总结一下，在使用工具时，Spring AI 会自动处理工具调用的全过程：从 AI 模型决定调用工具 &#x3D;&gt; 到执行工具方法 &#x3D;&gt; 再到将结果返回给模型 &#x3D;&gt; 最后模型基于工具结果生成最终回答。这整个过程对开发者来说是透明的，我们只需专注于 <strong>实现工具</strong> 的业务逻辑即可。</p>\n<p>那么，怎么实现工具呢？</p>\n<h3 id=\"工具生态\"><a href=\"#工具生态\" class=\"headerlink\" title=\"工具生态\"></a>工具生态</h3><p>首先，工具的本质就是一种插件。能不自己写的插件，就尽量不要自己写。我们可以直接在网上找一些优秀的工具实现，比如 <a href=\"https://java2ai.com/docs/1.0.0-M6.1/integrations/tools/\">Spring AI Alibaba 官方文档</a> 中提到了社区插件。</p>\n<p>虽然文档里只提到了屈指可数的插件数，但我们可以顺藤摸瓜，在 GitHub 社区找到官方提供的更多 <a href=\"https://github.com/alibaba/spring-ai-alibaba/tree/main/community/tool-calls\">工具源码</a>，包含大量有用的工具！比如翻译工具、网页搜索工具、爬虫工具、地图工具等：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108134310373.png\" alt=\"image-20251108134310373\"></p>\n<p> 这种搜⁠集资源的能力，希望大家也‌能够掌握，尤其是学新技术的时候，即使官方文档写的‎不够清晰完善，我们也可以‌从开源社区中获取到一手信息。</p>\n<h2 id=\"四、主流工具开发\"><a href=\"#四、主流工具开发\" class=\"headerlink\" title=\"四、主流工具开发\"></a>四、主流工具开发</h2><p>如果社区中没找到合⁠适的工具，我们就要自主开发。需要注‌意的是，AI 自身能够实现的功能通常没必要定义为额外的工具，因为这会‎增加一次额外的交互，我们应该将工具‌用于 AI 无法直接完成的任务。</p>\n<p>下面我们依次来实现需求分析中提到的 6 大工具，开发过程中我们要 <strong>格外注意工具描述的定义</strong>，因为它会影响 AI 决定是否使用工具。</p>\n<p>先在项目根包下新建 <code>tools</code> 包，将所有工具类放在该包下；并且工具的返回值尽量使用 String 类型，让结果的含义更加明确。</p>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><p>文件操作工具主要提供 2 大功能：保存文件、读取文件。</p>\n<p>由于会影响系统资源，所以我们需要将文件统一存放到一个隔离的目录进行存储，在 <code>constant</code> 包下新建文件常量类，约定文件保存目录为项目根目录下的 <code>/tmp</code> 目录中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">FileConstant</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">FILE_SAVE_DIR</span> <span class=\"operator\">=</span> System.getProperty(<span class=\"string\">&quot;user.dir&quot;</span>) + <span class=\"string\">&quot;/tmp&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>建议同时将这个目录添加到 <code>.gitignore</code> 文件中，避免提交隐私信息。</p>\n<p>编写文件操作工具类，通过注解式定义工具，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileOperationTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">FILE_DIR</span> <span class=\"operator\">=</span> FileConstant.FILE_SAVE_DIR + <span class=\"string\">&quot;/file&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Tool(description = &quot;Read content from a file&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">readFile</span><span class=\"params\">(<span class=\"meta\">@ToolParam(description = &quot;Name of the file to read&quot;)</span> String fileName)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">filePath</span> <span class=\"operator\">=</span> FILE_DIR + <span class=\"string\">&quot;/&quot;</span> + fileName;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> FileUtil.readUtf8String(filePath);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Error reading file: &quot;</span> + e.getMessage();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Tool(description = &quot;Write content to a file&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">writeFile</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"meta\">@ToolParam(description = &quot;Name of the file to write&quot;)</span> String fileName,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"meta\">@ToolParam(description = &quot;Content to write to the file&quot;)</span> String content)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">filePath</span> <span class=\"operator\">=</span> FILE_DIR + <span class=\"string\">&quot;/&quot;</span> + fileName;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            FileUtil.mkdir(FILE_DIR);</span><br><span class=\"line\">            FileUtil.writeUtf8String(content, filePath);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;File written successfully to: &quot;</span> + filePath;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Error writing to file: &quot;</span> + e.getMessage();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写单元测试验证工具功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileOperationToolTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testReadFile</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">FileOperationTool</span> <span class=\"variable\">tool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOperationTool</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;github.txt&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> tool.readFile(fileName);</span><br><span class=\"line\">        assertNotNull(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testWriteFile</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">FileOperationTool</span> <span class=\"variable\">tool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOperationTool</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;github.txt&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https://github.io&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> tool.writeFile(fileName, content);</span><br><span class=\"line\">        assertNotNull(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"联网搜索\"><a href=\"#联网搜索\" class=\"headerlink\" title=\"联网搜索\"></a>联网搜索</h3><p>联网搜索工具的作用是根据关键词搜索网页列表。</p>\n<p>我们可以使用专业的网页搜索 API，如 <a href=\"https://www.searchapi.io/baidu\">Search API</a> 来实现从多个网站搜索内容，这类服务通常按量计费。当然也可以直接使用 Google 或 Bing 的搜索 API（甚至是通过爬虫和网页解析从某个搜索引擎获取内容）。</p>\n<p>1）阅读 Search API 的 <a href=\"https://www.searchapi.io/baidu\">官方文档</a>，重点关注 API 的请求参数和返回结果。从 API 返回的结果中，我们只需要提取关键部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;organic_results&quot;</span>: [</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;position&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;title&quot;</span>: <span class=\"string\">&quot;github&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;link&quot;</span>: <span class=\"string\">&quot;https://github.io&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;displayed_link&quot;</span>: <span class=\"string\">&quot;https://github.io&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;snippet&quot;</span>: <span class=\"string\">&quot;github&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;snippet_highlighted_words&quot;</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;编程&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;github&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;程序员&quot;</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"string\">&quot;thumbnail&quot;</span>: <span class=\"string\">&quot;github.io&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）可以把⁠接口文档喂给 AI‌，让它帮我们生成工具代码，网页搜索工‎具代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebSearchTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">SEARCH_API_URL</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https://www.searchapi.io/api/v1/search&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String apiKey;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">WebSearchTool</span><span class=\"params\">(String apiKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.apiKey = apiKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Tool(description = &quot;Search for information from Baidu Search Engine&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">searchWeb</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@ToolParam(description = &quot;Search query keyword&quot;)</span> String query)</span> &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; paramMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        paramMap.put(<span class=\"string\">&quot;q&quot;</span>, query);</span><br><span class=\"line\">        paramMap.put(<span class=\"string\">&quot;api_key&quot;</span>, apiKey);</span><br><span class=\"line\">        paramMap.put(<span class=\"string\">&quot;engine&quot;</span>, <span class=\"string\">&quot;baidu&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> HttpUtil.get(SEARCH_API_URL, paramMap);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> JSONUtil.parseObj(response);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">JSONArray</span> <span class=\"variable\">organicResults</span> <span class=\"operator\">=</span> jsonObject.getJSONArray(<span class=\"string\">&quot;organic_results&quot;</span>);</span><br><span class=\"line\">            List&lt;Object&gt; objects = organicResults.subList(<span class=\"number\">0</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> objects.stream().map(obj -&gt; &#123;</span><br><span class=\"line\">                <span class=\"type\">JSONObject</span> <span class=\"variable\">tmpJSONObject</span> <span class=\"operator\">=</span> (JSONObject) obj;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tmpJSONObject.toString();</span><br><span class=\"line\">            &#125;).collect(Collectors.joining(<span class=\"string\">&quot;,&quot;</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Error searching Baidu: &quot;</span> + e.getMessage();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）我们需⁠要获取 API K‌ey 来调用网页搜索，注意不要泄露哦‎~</p>\n<p><img src=\"/post/Ai-Tool/image-20251108151001602.png\" alt=\"image-20251108151001602\"></p>\n<p>4）在配置文件中添加 API Key：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">search-api:</span></span><br><span class=\"line\">  <span class=\"attr\">api-key:</span> <span class=\"string\">你的</span> <span class=\"string\">API</span> <span class=\"string\">Key</span></span><br></pre></td></tr></table></figure>\n\n<p>5）编写单元⁠测试代码，读取配置文件‌中的密钥来创建网页搜索工具：        ‎           ‌             </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootTest</span><br><span class=\"line\">public class WebSearchToolTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;search-api.api-key&#125;&quot;)</span><br><span class=\"line\">    private String searchApiKey;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testSearchWeb() &#123;</span><br><span class=\"line\">        WebSearchTool tool = new WebSearchTool(searchApiKey);</span><br><span class=\"line\">        String query = &quot;程序员鱼皮编程导航 codefather.cn&quot;;</span><br><span class=\"line\">        String result = tool.searchWeb(query);</span><br><span class=\"line\">        assertNotNull(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行效果如图，成功搜索到了网页：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108153513617.png\" alt=\"image-20251108153513617\"></p>\n<p>在实际应用⁠中，我们可以进一步‌过滤结果，只保留 title、lin‎k 和 snipp‌et 等关键信息就够了。</p>\n<h3 id=\"网页抓取\"><a href=\"#网页抓取\" class=\"headerlink\" title=\"网页抓取\"></a>网页抓取</h3><p>网页抓取工具的作用是根据网址解析到网页的内容。</p>\n<p>1）可以使⁠用 jsoup 库‌实现网页内容抓取和解析，首先给项目添‎加依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.19.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2）编写网页抓取工具类，几行代码就搞定了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WebScrapingTool &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Tool(description = &quot;Scrape the content of a web page&quot;)</span><br><span class=\"line\">    public String scrapeWebPage(@ToolParam(description = &quot;URL of the web page to scrape&quot;) String url) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Document doc = Jsoup.connect(url).get();</span><br><span class=\"line\">            return doc.html();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            return &quot;Error scraping web page: &quot; + e.getMessage();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）编写单元测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootTest</span><br><span class=\"line\">public class WebScrapingToolTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testScrapeWebPage() &#123;</span><br><span class=\"line\">        WebScrapingTool tool = new WebScrapingTool();</span><br><span class=\"line\">        String url = &quot;https://www.codefather.cn&quot;;</span><br><span class=\"line\">        String result = tool.scrapeWebPage(url);</span><br><span class=\"line\">        assertNotNull(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"终端操作\"><a href=\"#终端操作\" class=\"headerlink\" title=\"终端操作\"></a>终端操作</h3><p>终端操作工⁠具的作用是在终端执‌行命令，比如执行 python 命令来运‎行脚本。</p>\n<p>1）可以通过 ⁠Java 的 Proces‌s API 实现终端命令执行，注意 Windows ‎和其他操作系统下的实现略‌有区别）。工具类代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TerminalOperationTool &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Tool(description = &quot;Execute a command in the terminal&quot;)</span><br><span class=\"line\">    public String executeTerminalCommand(@ToolParam(description = &quot;Command to execute in the terminal&quot;) String command) &#123;</span><br><span class=\"line\">        StringBuilder output = new StringBuilder();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Process process = Runtime.getRuntime().exec(command);</span><br><span class=\"line\">            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) &#123;</span><br><span class=\"line\">                String line;</span><br><span class=\"line\">                while ((line = reader.readLine()) != null) &#123;</span><br><span class=\"line\">                    output.append(line).append(&quot;\\n&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int exitCode = process.waitFor();</span><br><span class=\"line\">            if (exitCode != 0) &#123;</span><br><span class=\"line\">                output.append(&quot;Command execution failed with exit code: &quot;).append(exitCode);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">            output.append(&quot;Error executing command: &quot;).append(e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return output.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果是 W⁠indows 操作‌系统，要使用下面这段代码，否则命令执‎行会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TerminalOperationTool &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Tool(description = &quot;Execute a command in the terminal&quot;)</span><br><span class=\"line\">    public String executeTerminalCommand(@ToolParam(description = &quot;Command to execute in the terminal&quot;) String command) &#123;</span><br><span class=\"line\">        StringBuilder output = new StringBuilder();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            ProcessBuilder builder = new ProcessBuilder(&quot;cmd.exe&quot;, &quot;/c&quot;, command);</span><br><span class=\"line\"></span><br><span class=\"line\">            Process process = builder.start();</span><br><span class=\"line\">            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) &#123;</span><br><span class=\"line\">                String line;</span><br><span class=\"line\">                while ((line = reader.readLine()) != null) &#123;</span><br><span class=\"line\">                    output.append(line).append(&quot;\\n&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int exitCode = process.waitFor();</span><br><span class=\"line\">            if (exitCode != 0) &#123;</span><br><span class=\"line\">                output.append(&quot;Command execution failed with exit code: &quot;).append(exitCode);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">            output.append(&quot;Error executing command: &quot;).append(e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return output.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）编写单元测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootTest</span><br><span class=\"line\">public class TerminalOperationToolTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testExecuteTerminalCommand() &#123;</span><br><span class=\"line\">        TerminalOperationTool tool = new TerminalOperationTool();</span><br><span class=\"line\">        String command = &quot;ls -l&quot;;</span><br><span class=\"line\">        String result = tool.executeTerminalCommand(command);</span><br><span class=\"line\">        assertNotNull(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"资源下载\"><a href=\"#资源下载\" class=\"headerlink\" title=\"资源下载\"></a>资源下载</h3><p>资源下载工具的作用是通过链接下载文件到本地。</p>\n<p>1）使用 Hutool 的 <code>HttpUtil.downloadFile</code> 方法实现资源下载。资源下载工具类的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ResourceDownloadTool &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Tool(description = &quot;Download a resource from a given URL&quot;)</span><br><span class=\"line\">    public String downloadResource(@ToolParam(description = &quot;URL of the resource to download&quot;) String url, @ToolParam(description = &quot;Name of the file to save the downloaded resource&quot;) String fileName) &#123;</span><br><span class=\"line\">        String fileDir = FileConstant.FILE_SAVE_DIR + &quot;/download&quot;;</span><br><span class=\"line\">        String filePath = fileDir + &quot;/&quot; + fileName;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            FileUtil.mkdir(fileDir);</span><br><span class=\"line\">            </span><br><span class=\"line\">            HttpUtil.downloadFile(url, new File(filePath));</span><br><span class=\"line\">            return &quot;Resource downloaded successfully to: &quot; + filePath;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return &quot;Error downloading resource: &quot; + e.getMessage();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）编写单元测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootTest</span><br><span class=\"line\">public class ResourceDownloadToolTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testDownloadResource() &#123;</span><br><span class=\"line\">        ResourceDownloadTool tool = new ResourceDownloadTool();</span><br><span class=\"line\">        String url = &quot;https://www.codefather.cn/logo.png&quot;;</span><br><span class=\"line\">        String fileName = &quot;logo.png&quot;;</span><br><span class=\"line\">        String result = tool.downloadResource(url, fileName);</span><br><span class=\"line\">        assertNotNull(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PDF-生成\"><a href=\"#PDF-生成\" class=\"headerlink\" title=\"PDF 生成\"></a>PDF 生成</h3><p>PDF 生⁠成工具的作用是根据‌文件名和内容生成 PDF 文档并保存‎。</p>\n<p>可以使用 <a href=\"https://github.com/itext/itext-java\">itext 库</a> 实现 PDF 生成。需要注意的是，itext 对中文字体的支持需要额外配置，不同操作系统提供的字体也不同，如果真要做生产级应用，建议自行下载所需字体。</p>\n<p>不过对于学⁠习来说，不建议在这里‌浪费太多时间，可以使用内置中文字体（不引‎入 font-asi‌an 字体依赖也可以使用）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PdfFont font = PdfFontFactory.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;);</span><br><span class=\"line\">document.setFont(font);</span><br></pre></td></tr></table></figure>\n\n<p>1）给项目添加依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;itext-core&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;9.1.0&lt;/version&gt;</span><br><span class=\"line\">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;font-asian&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;9.1.0&lt;/version&gt;</span><br><span class=\"line\">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2）编写工具类实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PDFGenerationTool &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Tool(description = &quot;Generate a PDF file with given content&quot;)</span><br><span class=\"line\">    public String generatePDF(</span><br><span class=\"line\">            @ToolParam(description = &quot;Name of the file to save the generated PDF&quot;) String fileName,</span><br><span class=\"line\">            @ToolParam(description = &quot;Content to be included in the PDF&quot;) String content) &#123;</span><br><span class=\"line\">        String fileDir = FileConstant.FILE_SAVE_DIR + &quot;/pdf&quot;;</span><br><span class=\"line\">        String filePath = fileDir + &quot;/&quot; + fileName;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            FileUtil.mkdir(fileDir);</span><br><span class=\"line\">            </span><br><span class=\"line\">            try (PdfWriter writer = new PdfWriter(filePath);</span><br><span class=\"line\">                 PdfDocument pdf = new PdfDocument(writer);</span><br><span class=\"line\">                 Document document = new Document(pdf)) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                </span><br><span class=\"line\">                PdfFont font = PdfFontFactory.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;);</span><br><span class=\"line\">                document.setFont(font);</span><br><span class=\"line\">                </span><br><span class=\"line\">                Paragraph paragraph = new Paragraph(content);</span><br><span class=\"line\">                </span><br><span class=\"line\">                document.add(paragraph);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return &quot;PDF generated successfully to: &quot; + filePath;</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            return &quot;Error generating PDF: &quot; + e.getMessage();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，为了实现⁠方便，我们是直接保存 PDF 到本地文件系‌统。此外，你还可以将生成的文件上传到对象存储服务，然后返回可访问的 UR‎L 给 AI 去输出；或者将本地文件临‌时返回给前端，让用户直接访问。</p>\n<p>3）编写单元测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootTest</span><br><span class=\"line\">public class PDFGenerationToolTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testGeneratePDF() &#123;</span><br><span class=\"line\">        PDFGenerationTool tool = new PDFGenerationTool();</span><br><span class=\"line\">        String fileName = &quot;azer.pdf&quot;;</span><br><span class=\"line\">        String content = &quot;azer-2025.github.io&quot;;</span><br><span class=\"line\">        String result = tool.generatePDF(fileName, content);</span><br><span class=\"line\">        assertNotNull(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集中注册\"><a href=\"#集中注册\" class=\"headerlink\" title=\"集中注册\"></a>集中注册</h3><p>开发好了这么多工具类后，结合我们自己的需求，可以给 AI 一次性提供所有工具，让它自己决定何时调用。所以我们可以创建 <strong>工具注册类</strong>，方便统一管理和绑定所有工具。</p>\n<p>代码如下：⁠         ‌                  ‎     </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class ToolRegistration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;search-api.api-key&#125;&quot;)</span><br><span class=\"line\">    private String searchApiKey;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ToolCallback[] allTools() &#123;</span><br><span class=\"line\">        FileOperationTool fileOperationTool = new FileOperationTool();</span><br><span class=\"line\">        WebSearchTool webSearchTool = new WebSearchTool(searchApiKey);</span><br><span class=\"line\">        WebScrapingTool webScrapingTool = new WebScrapingTool();</span><br><span class=\"line\">        ResourceDownloadTool resourceDownloadTool = new ResourceDownloadTool();</span><br><span class=\"line\">        TerminalOperationTool terminalOperationTool = new TerminalOperationTool();</span><br><span class=\"line\">        PDFGenerationTool pdfGenerationTool = new PDFGenerationTool();</span><br><span class=\"line\">        return ToolCallbacks.from(</span><br><span class=\"line\">            fileOperationTool,</span><br><span class=\"line\">            webSearchTool,</span><br><span class=\"line\">            webScrapingTool,</span><br><span class=\"line\">            resourceDownloadTool,</span><br><span class=\"line\">            terminalOperationTool,</span><br><span class=\"line\">            pdfGenerationTool</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>💡 可别小瞧这段代码，其实它暗含了好几种设计模式：</p>\n<ol>\n<li>工厂模式：allTools() 方法作为一个工厂方法，负责创建和配置多个工具实例，然后将它们包装成统一的数组返回。这符合工厂模式的核心思想 - 集中创建对象并隐藏创建细节。</li>\n<li>依赖注入模式：通过 <code>@Value</code> 注解注入配置值，以及将创建好的工具通过 Spring 容器注入到需要它们的组件中。</li>\n<li>注册模式：该类作为一个中央注册点，集中管理和注册所有可用的工具，使它们能够被系统其他部分统一访问。</li>\n<li>适配器模式的应用：ToolCallbacks.from 方法可以看作是一种适配器，它将各种不同的工具类转换为统一的 ToolCallback 数组，使系统能够以一致的方式处理它们。</li>\n</ol>\n<p>有了这个注⁠册类，如果需要添加‌或移除工具，只需修改这一个类即可，更利‎于维护。</p>\n<h3 id=\"使用工具-1\"><a href=\"#使用工具-1\" class=\"headerlink\" title=\"使用工具\"></a>使用工具</h3><p>在 Lov⁠eApp 类中添加‌工具调用的代码，通过 tools 方‎法绑定所有已注册的‌工具：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Resource</span><br><span class=\"line\">private ToolCallback[] allTools;</span><br><span class=\"line\"></span><br><span class=\"line\">public String doChatWithTools(String message, String chatId) &#123;</span><br><span class=\"line\">    ChatResponse response = chatClient</span><br><span class=\"line\">            .prompt()</span><br><span class=\"line\">            .user(message)</span><br><span class=\"line\">            .advisors(spec -&gt; spec.param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)</span><br><span class=\"line\">                    .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 10))</span><br><span class=\"line\">            </span><br><span class=\"line\">            .advisors(new MyLoggerAdvisor())</span><br><span class=\"line\">            .tools(allTools)</span><br><span class=\"line\">            .call()</span><br><span class=\"line\">            .chatResponse();</span><br><span class=\"line\">    String content = response.getResult().getOutput().getText();</span><br><span class=\"line\">    log.info(&quot;content: &#123;&#125;&quot;, content);</span><br><span class=\"line\">    return content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试使用工具\"><a href=\"#测试使用工具\" class=\"headerlink\" title=\"测试使用工具\"></a>测试使用工具</h3><p>最后，编写⁠单元测试代码，通过‌特定的提示词精准触发工具调用（不过由‎于 AI 的随机性‌，仍然有小概率失败）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">void doChatWithTools() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    testMessage(&quot;周末想带女朋友去上海约会，推荐几个适合情侣的小众打卡地？&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    testMessage(&quot;最近和对象吵架了，看看稀土掘金的其他情侣是怎么解决矛盾的？&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    testMessage(&quot;直接下载一张适合做手机壁纸的星空情侣图片为文件&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    testMessage(&quot;执行 Python3 脚本来生成数据分析报告&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    testMessage(&quot;保存我的恋爱档案为文件&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    testMessage(&quot;生成一份‘七夕约会计划’PDF，包含餐厅预订、活动流程和礼物清单&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void testMessage(String message) &#123;</span><br><span class=\"line\">    String chatId = UUID.randomUUID().toString();</span><br><span class=\"line\">    String answer = loveApp.doChatWithTools(message, chatId);</span><br><span class=\"line\">    Assertions.assertNotNull(answer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、工具进阶知识\"><a href=\"#五、工具进阶知识\" class=\"headerlink\" title=\"五、工具进阶知识\"></a>五、工具进阶知识</h2><p>其实关于工具调用，⁠掌握核心概念和工具开发方法就足够了‌，但是为了帮大家更好地理解 Spring AI 的工具调用机制（更好‎地吊打面试官），还是给大家讲一些进‌阶知识，无需记忆，了解即可。</p>\n<h3 id=\"工具底层数据结构\"><a href=\"#工具底层数据结构\" class=\"headerlink\" title=\"工具底层数据结构\"></a>工具底层数据结构</h3><p>让我们思考⁠一个问题：AI 怎‌么知道要如何调用工具？输出结果中应该‎包含哪些参数来调用‌工具呢？</p>\n<p>Spring AI 工具调用的核心在于 <code>ToolCallback</code> 接口，它是所有工具实现的基础。先分析下该接口的源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ToolCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    ToolDefinition getToolDefinition();</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    ToolMetadata getToolMetadata();</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    String call(String toolInput);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    String call(String toolInput, ToolContext tooContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个接口中：</p>\n<ul>\n<li><code>getToolDefinition()</code> 提供了工具的基本定义，包括名称、描述和调用参数，这些信息会传递给 AI 模型，帮助模型了解什么时候应该调用这个工具、以及如何构造参数</li>\n<li><code>getToolMetadata()</code> 提供了处理工具的附加信息，比如是否直接返回结果等控制选项</li>\n<li>两个 <code>call()</code> 方法是工具的执行入口，分别支持有上下文和无上下文的调用场景</li>\n</ul>\n<p>工具定义类⁠ ToolDefi‌nition 的结构如下图，包含名称‎、描述和调用工具的‌参数：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161304472.png\" alt=\"image-20251108161304472\"></p>\n<p>可以利用构造器手动创建一个工具定义：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161322397.png\" alt=\"image-20251108161322397\"></p>\n<p>但为什么我⁠们刚刚定义工具时，‌直接通过注解就能把方法变成工具呢？</p>\n<p>这是因为，⁠当使用注解定义工具‌时，Spring AI 会做大量幕后‎工作：</p>\n<ol>\n<li><code>JsonSchemaGenerator</code> 会解析方法签名和注解，自动生成符合 JSON Schema 规范的参数定义，作为 ToolDefinition 的一部分提供给 AI 大模型</li>\n<li><code>ToolCallResultConverter</code> 负责将各种类型的方法返回值统一转换为字符串，便于传递给 AI 大模型处理</li>\n<li><code>MethodToolCallback</code> 实现了对注解方法的封装，使其符合 <code>ToolCallback</code> 接口规范</li>\n</ol>\n<p>这种设计使我们可以专注于业务逻辑实现，无需关心底层通信和参数转换的复杂细节。如果需要更精细的控制，我们可以自定义 <code>ToolCallResultConverter</code> 来实现特定的转换逻辑，例如对某些特殊对象的自定义序列化。</p>\n<h3 id=\"工具上下文\"><a href=\"#工具上下文\" class=\"headerlink\" title=\"工具上下文\"></a>工具上下文</h3><p>在实际应用中，工具执行可能需要额外的上下文信息，比如登录用户信息、会话 ID 或者其他环境参数。Spring AI 通过 <code>ToolContext</code> 提供了这一能力。如图：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161519738.png\" alt=\"image-20251108161519738\"></p>\n<p>我们可以在⁠调用 AI 大模型‌时，传递上下文参数。比如传递用户名为‎ Azer：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String loginUserName = getLoginUserName();</span><br><span class=\"line\"></span><br><span class=\"line\">String response = chatClient</span><br><span class=\"line\">        .prompt(&quot;帮我查询用户信息&quot;)</span><br><span class=\"line\">        .tools(new CustomerTools())</span><br><span class=\"line\">        .toolContext(Map.of(&quot;userName&quot;, &quot;Azer&quot;))</span><br><span class=\"line\">        .call()</span><br><span class=\"line\">        .content();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response);</span><br></pre></td></tr></table></figure>\n\n<p>在工具中使⁠用上下文参数。比如‌从数据库中查询 Azer 的信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomerTools &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Tool(description = &quot;Retrieve customer information&quot;)</span><br><span class=\"line\">    Customer getCustomerInfo(Long id, ToolContext toolContext) &#123;</span><br><span class=\"line\">        return customerRepository.findById(id, toolContext.get(&quot;userName&quot;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码我们会发现，<code>ToolContext</code> 本质上就是一个 Map：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161531319.png\" alt=\"image-20251108161531319\"></p>\n<p>它可以携带任何与当前请求相关的信息，但这些信息 <strong>不会传递给 AI 模型</strong>，只在应用程序内部使用。这样做既增强了工具的安全性，也很灵活。适用于下面的场景：</p>\n<ul>\n<li>用户认证信息：可以在上下文中传递用户 token，而不暴露给模型</li>\n<li>请求追踪：在上下文中添加请求 ID，便于日志追踪和调试</li>\n<li>自定义配置：根据不同场景传递特定配置参数</li>\n</ul>\n<p>举个应用例子，假如做了⁠一个用户自助退款功能，如果已登录用户跟 AI‌ 说：” 我要退款 “，AI 就不需要再问用户 “你是谁？”，让用户自己输入退款信息了；而是‎直接从系统中读取到 userId，在工具调用‌时根据 userId 操作退款即可。</p>\n<h3 id=\"立即返回\"><a href=\"#立即返回\" class=\"headerlink\" title=\"立即返回\"></a>立即返回</h3><p>有时候，工具执行的结果不需要再经过 AI 模型处理，而是希望直接返回给用户（比如生成 PDF 文档）。Spring AI 通过 <code>returnDirect</code> 属性支持这一功能，流程如图：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161544953.png\" alt=\"image-20251108161544953\"></p>\n<p>立即返回模式改变了工具调用的基本流程：</p>\n<ol>\n<li>定义工具时，将 <code>returnDirect</code> 属性设为 <code>true</code></li>\n<li>当模型请求调用这个工具时，应用程序执行工具并获取结果</li>\n<li>结果直接返回给调用者，<strong>不再</strong> 发送回模型进行进一步处理</li>\n</ol>\n<p>这种模式很适合⁠需要返回二进制数据（比如图‌片 &#x2F; 文件）的工具、返回大量数据而不需要 AI 解‎释的工具，以及产生明确结果‌的操作（如数据库操作）。</p>\n<p>启用立即返回的⁠方法非常简单，使用注解方式‌时指定 returnDirect 参数：      ‎             ‌             </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomerTools &#123;</span><br><span class=\"line\">    @Tool(description = &quot;Retrieve customer information&quot;, returnDirect = true)</span><br><span class=\"line\">    Customer getCustomerInfo(Long id) &#123;</span><br><span class=\"line\">        return customerRepository.findById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用编程方式时，手动构造 ToolMetadata 对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ToolMetadata toolMetadata = ToolMetadata.builder()</span><br><span class=\"line\">    .returnDirect(true)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Method method = ReflectionUtils.findMethod(CustomerTools.class, &quot;getCustomerInfo&quot;, Long.class);</span><br><span class=\"line\">ToolCallback toolCallback = MethodToolCallback.builder()</span><br><span class=\"line\">    .toolDefinition(ToolDefinition.builder(method)</span><br><span class=\"line\">            .description(&quot;Retrieve customer information&quot;)</span><br><span class=\"line\">            .build())</span><br><span class=\"line\">    .toolMethod(method)</span><br><span class=\"line\">    .toolObject(new CustomerTools())</span><br><span class=\"line\">    .toolMetadata(toolMetadata)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"工具底层执行原理\"><a href=\"#工具底层执行原理\" class=\"headerlink\" title=\"工具底层执行原理\"></a>工具底层执行原理</h3><p>Spring AI 提供了两种工具执行模式：框架控制的工具执行和用户控制的工具执行。这两种模式都离不开一个核心组件 <code>ToolCallingManager</code> 。</p>\n<h4 id=\"ToolCallingManager\"><a href=\"#ToolCallingManager\" class=\"headerlink\" title=\"ToolCallingManager\"></a>ToolCallingManager</h4><p><code>ToolCallingManager</code> 接口可以说是 Spring AI 工具调用中最值得学习的类了。它是 <strong>管理 AI 工具调用全过程</strong> 的核心组件，负责根据 AI 模型的响应执行对应的工具并返回执行结果给大模型。此外，它还支持异常处理，可以统一处理工具执行过程中的错误情况。</p>\n<p>接口定义如图：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161602177.png\" alt=\"image-20251108161602177\"></p>\n<p>其中的 2 个核心方法：</p>\n<ol>\n<li>resolveToolDefinitions：从模型的工具调用选项中解析工具定义</li>\n<li>executeToolCalls：执行模型请求对应的工具调用</li>\n</ol>\n<p>如果你使用的是任何 Spring AI 相关的 Spring Boot Starter，都会默认初始化一个 <code>DefaultToolCallingManager</code>。如下图，我们可以看到工具观察器、工具解析器、工具执行异常处理器的定义：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161618693.png\" alt=\"image-20251108161618693\"></p>\n<p>如果不想用⁠默认的，也可以自己‌定义 ToolCallingMana‎ger Bean。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">ToolCallingManager toolCallingManager() &#123;</span><br><span class=\"line\">    return ToolCallingManager.builder().build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ToolCallingManager</code> 怎么知道是否要调用工具呢？</p>\n<p>由于这块的实现⁠可能会更新，建议大家学会看源‌码来分析，比如查看执行工具调用的源码，会发现它其实是从 ‎AI 返回的 toolCal‌ls 参数中获取要调用的工具：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161704540.png\" alt=\"image-20251108161704540\"></p>\n<p>然后依次执行并构造 <code>工具响应消息对象</code> 作为返回结果：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161732434.png\" alt=\"image-20251108161732434\"></p>\n<h4 id=\"框架控制的工具执行\"><a href=\"#框架控制的工具执行\" class=\"headerlink\" title=\"框架控制的工具执行\"></a>框架控制的工具执行</h4><p>这是默认且最简单⁠的模式，由 Spring AI‌ 框架自动管理整个工具调用流程。所以我们刚刚开发时，基本没写‎几行非业务逻辑的代码，大多数活‌儿都交给框架负重前行了。</p>\n<p>在这种模式下：</p>\n<ul>\n<li>框架自动检测模型是否请求调用工具</li>\n<li>自动执行工具调用并获取结果</li>\n<li>自动将结果发送回模型</li>\n<li>管理整个对话流程直到得到最终答案</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161753716.png\" alt=\"image-20251108161753716\"></p>\n<p>上图中，我们会发现 <code>ToolCallingManager</code> 起到了关键作用，由框架使用默认初始化的 <code>DefaultToolCallingManager</code> 来自动管理整个工具调用流程，适合大多数简单场景。</p>\n<h4 id=\"用户控制的工具执行\"><a href=\"#用户控制的工具执行\" class=\"headerlink\" title=\"用户控制的工具执行\"></a>用户控制的工具执行</h4><p>对于需要更精细控制的复⁠杂场景，Spring AI 提供了用户控制模‌式，可以通过设置 ToolCallingChatOptions 的 internalTo‎olExecutionEnabled 属性为‌ false 来禁用内部工具执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChatOptions chatOptions = ToolCallingChatOptions.builder()</span><br><span class=\"line\">    .toolCallbacks(ToolCallbacks.from(new WeatherTools()))</span><br><span class=\"line\">    .internalToolExecutionEnabled(false)  </span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<p>然后我们就⁠可以自己从 AI ‌的响应结果中提取工具调用列表，再依次‎执行了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ToolCallingManager toolCallingManager = DefaultToolCallingManager.builder().build();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Prompt prompt = new Prompt(&quot;获取github的热门项目教程&quot;, chatOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">ChatResponse chatResponse = chatModel.call(prompt);</span><br><span class=\"line\"></span><br><span class=\"line\">while (chatResponse.hasToolCalls()) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(prompt, chatResponse);</span><br><span class=\"line\">    </span><br><span class=\"line\">    prompt = new Prompt(toolExecutionResult.conversationHistory(), chatOptions);</span><br><span class=\"line\">    </span><br><span class=\"line\">    chatResponse = chatModel.call(prompt);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(chatResponse.getResult().getOutput().getText());</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，我们就可以：</p>\n<ul>\n<li>在工具执行前后插入自定义逻辑</li>\n<li>实现更复杂的工具调用链和条件逻辑</li>\n<li>和其他系统集成，比如追踪 AI 调用进度、记录日志等</li>\n<li>实现更精细的错误处理和重试机制</li>\n</ul>\n<p>官方还提供了一个更复杂的代码示例，结合用户控制的工具执行 + 会话记忆特性，感兴趣的同学 <a href=\"https://docs.spring.io/spring-ai/reference/1.0/api/tools.html#_user_controlled_tool_execution\">参考文档</a> 了解即可。</p>\n<h4 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h4><p>工具执行过程中可⁠能会发生各种异常，Spring‌ AI 提供了灵活的异常处理机制，通过 ToolExecut‎ionExceptionPro‌cessor 接口实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface ToolExecutionExceptionProcessor &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    String process(ToolExecutionException exception);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认实现类 <code>DefaultToolExecutionExceptionProcessor</code> 提供了两种处理策略：</p>\n<ol>\n<li>alwaysThrow 参数为 false：将异常信息作为错误消息返回给 AI 模型，允许模型根据错误信息调整策略</li>\n<li>alwaysThrow 参数为 true：直接抛出异常，中断当前对话流程，由应用程序处理</li>\n</ol>\n<p><img src=\"/post/Ai-Tool/image-20251108161823569.png\" alt=\"image-20251108161823569\"></p>\n<p>看源码发现，Sp⁠ring Boot Start‌er 自动注入的 DefaultToolExecutionE‎xceptionProcess‌or 默认使用第一种策略：</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161838913.png\" alt=\"image-20251108161838913\"></p>\n<p>可以根据需要定制处理策略，声明一个 <code>ToolExecutionExceptionProcessor</code> Bean 即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">ToolExecutionExceptionProcessor toolExecutionExceptionProcessor() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return new DefaultToolExecutionExceptionProcessor(true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以⁠自定义异常处理器来实‌现更复杂的策略，比如根据异常类型决定是返‎回错误消息还是抛出异‌常，或者实现重试逻辑：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">ToolExecutionExceptionProcessor customExceptionProcessor() &#123;</span><br><span class=\"line\">    return exception -&gt; &#123;</span><br><span class=\"line\">        if (exception.getCause() instanceof IOException) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            return &quot;Unable to access external resource. Please try a different approach.&quot;;</span><br><span class=\"line\">        &#125; else if (exception.getCause() instanceof SecurityException) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            throw exception;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return &quot;Error executing tool: &quot; + exception.getMessage();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"工具解析\"><a href=\"#工具解析\" class=\"headerlink\" title=\"工具解析\"></a>工具解析</h3><p>前面提到，除了直接提供 <code>ToolCallback</code> 实例外，Spring AI 还支持通过名称动态解析工具，这是通过<code>ToolCallbackResolver</code> 接口实现的。代码如下，作用就是将名称解析为 ToolCallback 工具对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ToolCallbackResolver &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Nullable</span><br><span class=\"line\">    ToolCallback resolve(String toolName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring AI 默认使用 <code>DelegatingToolCallbackResolver</code>，它将工具解析任务委托给一系列解析器：</p>\n<ul>\n<li><code>SpringBeanToolCallbackResolver</code>：从 Spring 容器中查找工具，支持函数式接口 Bean</li>\n<li><code>StaticToolCallbackResolver</code>：从预先注册的 ToolCallback 工具列表中查找。当使用 Spring Boot 自动配置时，该解析器会自动配置应用上下文中定义的所有 <code>ToolCallback</code> 类型的 Bean。</li>\n</ul>\n<p><img src=\"/post/Ai-Tool/image-20251108161855173.png\" alt=\"image-20251108161855173\"></p>\n<p>这种解析机制使得工具调用更加灵活：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String response = ChatClient.create(chatModel)</span><br><span class=\"line\">        .prompt(&quot;What&#x27;s the weather in Beijing?&quot;)</span><br><span class=\"line\">        .toolNames(&quot;weatherTool&quot;, &quot;timeTool&quot;)  </span><br><span class=\"line\">        .call()</span><br><span class=\"line\">        .content();</span><br></pre></td></tr></table></figure>\n\n<p>如果需要自定义解析逻辑，可以提供自己的 <code>ToolCallbackResolver</code> Bean：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">ToolCallbackResolver customToolCallbackResolver() &#123;</span><br><span class=\"line\">    Map&lt;String, ToolCallback&gt; toolMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">    toolMap.put(&quot;weatherTool&quot;, new WeatherToolCallback());</span><br><span class=\"line\">    toolMap.put(&quot;timeTool&quot;, new TimeToolCallback());</span><br><span class=\"line\">    </span><br><span class=\"line\">    return toolName -&gt; toolMap.get(toolName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者更常见的情况是扩展现有的解析器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">ToolCallbackResolver toolCallbackResolver(List&lt;ToolCallback&gt; toolCallbacks) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    StaticToolCallbackResolver staticResolver = new StaticToolCallbackResolver(toolCallbacks);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    ToolCallbackResolver customResolver = toolName -&gt; &#123;</span><br><span class=\"line\">        if (toolName.startsWith(&quot;dynamic-&quot;)) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            return createDynamicTool(toolName.substring(8));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    return new DelegatingToolCallbackResolver(List.of(customResolver, staticResolver));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可观测性\"><a href=\"#可观测性\" class=\"headerlink\" title=\"可观测性\"></a>可观测性</h3><p>目前 Sp⁠ring AI 的‌工具调用可观测性功能仍在开发中，不过‎系统已经提供了基础的‌日志功能。</p>\n<p>前面分析源码的时候就发现了，工具调用的所有主要操作都在 <code>DEBUG</code> 级别记录日志。</p>\n<p><img src=\"/post/Ai-Tool/image-20251108161909994.png\" alt=\"image-20251108161909994\"></p>\n<p>要启用这些日志，可以在配置文件中设置 <code>org.springframework.ai</code> 包的日志级别为 <code>DEBUG</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logging:</span><br><span class=\"line\">  level:</span><br><span class=\"line\">    org.springframework.ai: DEBUG</span><br></pre></td></tr></table></figure>\n\n<p>启用调试日⁠志后，就能看到工具‌调用的过程了，学习的时候建议打开。</p>\n<p>随着 Sp⁠ring AI 的‌发展，未来可能会提供更完善的可观测性‎工具，比如：</p>\n<ul>\n<li>工具调用指标收集</li>\n<li>分布式追踪集成</li>\n<li>可视化控制台</li>\n<li>性能监控功能</li>\n</ul>\n<p>当然，这些只是鱼皮强行画的饼，希望官方能实现吧（</p>\n<p>这里还有一种高级的可观⁠测性实现方式，可以利用代理模式，结合 To‌olCallback 类或 ToolCallingManager 类自定义工具的调用‎过程，自己添加额外的监控和日志记录逻辑。</p>\n","feature":true,"text":"一、需求分析之前我们通过 RAG 技术让 AI 应用具备了根据外部知识库来获取信息并回答的能力，但是直到目前为止，AI 应用还只是个 “知识问答助手”。本节我们...","permalink":"/post/Ai-Tool","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":7,"path":"api/categories/SpringBoot.json"},{"name":"Spring AI","slug":"SpringBoot/Spring-AI","count":6,"path":"api/categories/SpringBoot/Spring-AI.json"}],"tags":[{"name":"Spring AI","slug":"Spring-AI","count":7,"path":"api/tags/Spring-AI.json"},{"name":"大模型","slug":"大模型","count":7,"path":"api/tags/大模型.json"},{"name":"AI","slug":"AI","count":6,"path":"api/tags/AI.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90\"><span class=\"toc-text\">一、需求分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">二、工具调用介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">什么是工具调用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">工具调用的工作原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%92%8C%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">工具调用和功能调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B\"><span class=\"toc-text\">工具调用的技术选型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Spring-AI-%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">三、Spring AI 工具开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">定义工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">工具定义模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7-1\"><span class=\"toc-text\">定义工具</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">使用工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E7%94%9F%E6%80%81\"><span class=\"toc-text\">工具生态</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E4%B8%BB%E6%B5%81%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">四、主流工具开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">文件操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%94%E7%BD%91%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">联网搜索</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96\"><span class=\"toc-text\">网页抓取</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">终端操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">资源下载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PDF-%E7%94%9F%E6%88%90\"><span class=\"toc-text\">PDF 生成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%86%E4%B8%AD%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">集中注册</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7-1\"><span class=\"toc-text\">使用工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">测试使用工具</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">五、工具进阶知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">工具底层数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">工具上下文</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">立即返回</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">工具底层执行原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ToolCallingManager\"><span class=\"toc-text\">ToolCallingManager</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A1%86%E6%9E%B6%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">框架控制的工具执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">用户控制的工具执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">异常处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">工具解析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7\"><span class=\"toc-text\">可观测性</span></a></li></ol></li></ol>","author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"RAG(2)","uid":"759217f82967d9e83558b0196a1e2331","slug":"RAG-2","date":"2025-11-08T05:13:53.000Z","updated":"2025-11-08T05:37:59.129Z","comments":true,"path":"api/articles/RAG-2.json","keywords":"VUE、Python、JAVA","cover":"/medias/RAG(2).png","text":"具体内容包括： RAG 核心特性 文档收集和切割（ETL） 向量转换和存储（向量数据库） 文档过滤和检索（文档检索器） 查询增强和关联（上下文查询增强器） RA...","permalink":"/post/RAG-2","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":7,"path":"api/categories/SpringBoot.json"},{"name":"Spring AI","slug":"SpringBoot/Spring-AI","count":6,"path":"api/categories/SpringBoot/Spring-AI.json"}],"tags":[{"name":"Spring AI","slug":"Spring-AI","count":7,"path":"api/tags/Spring-AI.json"},{"name":"大模型","slug":"大模型","count":7,"path":"api/tags/大模型.json"},{"name":"AI","slug":"AI","count":6,"path":"api/tags/AI.json"}],"author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}},"feature":true}}