{"title":"agent","uid":"6c03615222d1e2ccb10d78d4232256eb","slug":"agent","date":"2025-11-12T05:59:06.000Z","updated":"2025-11-12T06:01:45.423Z","comments":true,"path":"api/articles/agent.json","keywords":"VUE、Python、JAVA","cover":"/medias/agent.png","content":"<h2 id=\"一、什么是智能体？\"><a href=\"#一、什么是智能体？\" class=\"headerlink\" title=\"一、什么是智能体？\"></a>一、什么是智能体？</h2><p>智能体（Agent）是一个能够感知环境、进行推理、制定计划、做出决策并自主采取行动以实现特定目标的 AI 系统。它以大语言模型为核心，集成 <strong>记忆、知识库和工具</strong> 等能力为一体，构造了完整的决策能力、执行能力和记忆能力，就像一个有主观能动性的人类一样。</p>\n<p>与普通的 AI 大模型不同，智能体能够：</p>\n<ol>\n<li>感知环境：通过各种输入渠道获取信息（多模态），理解用户需求和环境状态</li>\n<li>自主规划任务步骤：将复杂任务分解为可执行的子任务，并设计执行顺序</li>\n<li>主动调用工具完成任务：根据需要选择并使用各种外部工具和 API，扩展自身能力边界</li>\n<li>进行多步推理：通过思维链（Chain of Thought）逐步分析问题并推导解决方案</li>\n<li>持续学习和记忆过去的交互：保持上下文连贯性，利用历史交互改进决策</li>\n<li>根据环境反馈调整行为：根据执行结果动态调整策略，实现闭环优化</li>\n</ol>\n<p>大多数人⁠第一次感受到智能体‌应该是 “深度思考” 功能，这是 A‎I 逐步智能化的体‌现： </p>\n<h3 id=\"智能体的分类\"><a href=\"#智能体的分类\" class=\"headerlink\" title=\"智能体的分类\"></a>智能体的分类</h3><p>跟人的生长⁠阶段一样，智能体也‌是可以不断进化的。按照自主性和规划能‎力，智能体可以分为‌几个层次：</p>\n<p>1）反应式智能⁠体：仅根据当前输入和固定规则‌做出反应，类似简单的聊天机器人，没有真正的规划能力。23‎ 年时的大多数 AI 聊天机‌器人应用，几乎都是反应式智能体。</p>\n<p><img src=\"/post/agent/image-20251111105604263.png\" alt=\"image-20251111105604263\"></p>\n<p>2）有限规划智能体：能进⁠行简单地多步骤执行，但执行路径通常是预设的或有‌严格限制的。鉴定为 “能干事、但干不了复杂的大事”。24 年流行的很多可联网搜索内容、调用知‎识库和工具的 AI 应用，都属于这类智能体。比‌如 ChatGPT + Plugins：</p>\n<p><img src=\"/post/agent/image-20251111105614939.png\" alt=\"image-20251111105614939\"></p>\n<p>3）自主规⁠划智能体：也叫目标导‌向智能体，能够根据任务目标自主分解任务、‎制定计划、选择工具并‌一步步执行，直到完成任务。</p>\n<p>比如 25 年初很火的 M⁠anus 项目，它的核心亮点在于其 “自主执行” 能‌力。据官方介绍，Manus 能够在虚拟机中调用各种工具（如编写代码、爬取数据）完成任务。其应用场景‎覆盖旅行规划、股票分析、教育内容生成等 40 余个‌领域，所以在当时给了很多人震撼感。</p>\n<p><img src=\"/post/agent/image-20251111105625194.png\" alt=\"image-20251111105625194\"></p>\n<p>但其实早在这之前，就有类似的项目了，比如 AutoGPT，所以 Manus 大火的同时也被人诟病 “会营销而已”。甚至没隔多久就有小团队开源了 Manus 的复刻版 —— <a href=\"https://github.com/FoundationAgents/OpenManus\">OpenManus</a>，这类智能体通过 “思考 - 行动 - 观察” 的循环模式工作，能够持续推进任务直至完成目标。</p>\n<p><img src=\"/post/agent/image-20251111105635508.png\" alt=\"image-20251111105635508\"></p>\n<p>需要注意，自主⁠规划能力是智能体发展的重要‌方向，但并非所有应用场景都需要完全的自主规划能力。在‎某些场景中，限制智能体的自‌主性反而能提高效率和安全性。</p>\n<h2 id=\"二、智能体实现关键技术\"><a href=\"#二、智能体实现关键技术\" class=\"headerlink\" title=\"二、智能体实现关键技术\"></a>二、智能体实现关键技术</h2><p>在自主开发⁠智能体前，我们要先‌了解一下智能体的关键实现技术，也就是‎方案设计阶段做的事‌情。</p>\n<h3 id=\"CoT-思维链\"><a href=\"#CoT-思维链\" class=\"headerlink\" title=\"CoT 思维链\"></a>CoT 思维链</h3><p>CoT（Chain of⁠ Thought）思维链是一种让 AI 像人类一‌样 “思考” 的技术，帮助 AI 在处理复杂问题时能够按步骤思考。对于复杂的推理类问题，先思考后‎执行，效果往往更好。而且还可以让模型在生成答案时‌展示推理过程，便于我们理解和优化 AI。</p>\n<p>CoT 的实现方式其实很简单⁠，可以在输入 Prompt 时，给模型提供额外的提示或‌引导，比如 “让我们一步一步思考这个问题”，让模型以逐步推理的方式生成回答。还可以运用 Prompt 的优化‎技巧 few shot，给模型提供包含思维链的示例问题‌和答案，让模型学习如何构建自己的思维链。</p>\n<p>在 Ope⁠nManus 早期‌版本中，可以看到实现 CoT 的系统‎提示词：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You are an assistant focused on Chain of Thought reasoning. For each question, please follow these steps:  </span><br><span class=\"line\">  </span><br><span class=\"line\">1. Break down the problem: Divide complex problems into smaller, more manageable parts  </span><br><span class=\"line\">2. Think step by step: Think through each part in detail, showing your reasoning process  </span><br><span class=\"line\">3. Synthesize conclusions: Integrate the thinking from each part into a complete solution  </span><br><span class=\"line\">4. Provide an answer: Give a final concise answer  </span><br><span class=\"line\">  </span><br><span class=\"line\">Your response should follow this format:  </span><br><span class=\"line\">Thinking: [Detailed thought process, including problem decomposition, reasoning for each step, and analysis]  </span><br><span class=\"line\">Answer: [Final answer based on the thought process, clear and concise]  </span><br><span class=\"line\">  </span><br><span class=\"line\">Remember, the thinking process is more important than the final answer, as it demonstrates how you reached your conclusion.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Agent-Loop-执行循环\"><a href=\"#Agent-Loop-执行循环\" class=\"headerlink\" title=\"Agent Loop 执行循环\"></a>Agent Loop 执行循环</h3><p>Agent⁠ Loop 是智能体‌最核心的工作机制，指智能体在没有用户输入‎的情况下，自主重复执‌行推理和工具调用的过程。</p>\n<p>在传统的聊天模型中，⁠每次用户提问后，AI 回复一次就结束‌了。但在智能体中，AI 回复后可能会继续自主执行后续动作（如调用工具、处理结果、继续‎推理），形成一个自主执行的循环，直到任务‌完成（或者超出预设的最大步骤数）。</p>\n<p>Agent Loop 的实现很简单，参考代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String execute() &#123;  </span><br><span class=\"line\">    List&lt;String&gt; results = new ArrayList&lt;&gt;();  </span><br><span class=\"line\">    while (currentStep &lt; MAX_STEPS &amp;&amp; !isFinished) &#123;  </span><br><span class=\"line\">        currentStep++;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        String stepResult = executeStep();  </span><br><span class=\"line\">        results.add(&quot;步骤 &quot; + currentStep + &quot;: &quot; + stepResult);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (currentStep &gt;= MAX_STEPS) &#123;  </span><br><span class=\"line\">        results.add(&quot;达到最大步骤数: &quot; + MAX_STEPS);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return String.join(&quot;\\n&quot;, results);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ReAct-模式\"><a href=\"#ReAct-模式\" class=\"headerlink\" title=\"ReAct 模式\"></a>ReAct 模式</h3><p>ReAct（Reas⁠oning + Acting）是一种结合‌推理和行动的智能体架构，它模仿人类解决问题时 ” 思考 - 行动 - 观察” 的循‎环，目的是通过交互式决策解决复杂任务，是‌目前最常用的智能体工作模式之一。</p>\n<p>核心思想：</p>\n<ol>\n<li>推理（Reason）：将原始问题拆分为多步骤任务，明确当前要执行的步骤，比如 “第一步需要打开编程导航网站”。</li>\n<li>行动（Act）：调用外部工具执行动作，比如调用搜索引擎、打开浏览器访问网页等。</li>\n<li>观察（Observe）：获取工具返回的结果，反馈给智能体进行下一步决策。比如将打开的网页代码输入给 AI。</li>\n<li>循环迭代：不断重复上述 3 个过程，直到任务完成或达到终止条件。</li>\n</ol>\n<p>ReAct 流程如图：</p>\n<p><img src=\"/post/agent/image-20251111110613130.png\" alt=\"image-20251111110613130\"></p>\n<p>示例实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void executeReAct(String task) &#123;  </span><br><span class=\"line\">    String state = &quot;开始&quot;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    while (!state.equals(&quot;完成&quot;)) &#123;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        String thought = &quot;思考下一步行动&quot;;  </span><br><span class=\"line\">        System.out.println(&quot;推理: &quot; + thought);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        </span><br><span class=\"line\">        String action = &quot;执行具体操作&quot;;  </span><br><span class=\"line\">        System.out.println(&quot;行动: &quot; + action);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        </span><br><span class=\"line\">        String observation = &quot;观察执行结果&quot;;  </span><br><span class=\"line\">        System.out.println(&quot;观察: &quot; + observation);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        </span><br><span class=\"line\">        state = &quot;完成&quot;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"所需支持系统\"><a href=\"#所需支持系统\" class=\"headerlink\" title=\"所需支持系统\"></a>所需支持系统</h3><p>除了基本的工作机制外，智能体的实现还依赖于很多支持系统。</p>\n<p>1）首先是 ⁠AI 大模型，这个就不‌多说了，大模型提供了思考、推理和决策的核心能‎力，越强的 AI 大模‌型通常执行任务的效果越好。</p>\n<p>2）记忆系统</p>\n<p>智能体需要记忆系统⁠来存储对话历史、中间结果和执行状态，‌这样它才能够进行连续对话并根据历史对话分析接下来的工作步骤。之前我们学习‎过如何使用 Spring AI 的 ‌ChatMemory 实现对话记忆。</p>\n<p>3）知识库</p>\n<p>尽管大语言模型拥有⁠丰富的参数知识，但针对特定领域的专‌业知识往往需要额外的知识库支持。之前我们学习过，通过 RAG 检索增‎强生成 + 向量数据库等技术，智能‌体可以检索并利用专业知识回答问题。</p>\n<p>4）工具调用</p>\n<p>工具是扩展智能体⁠能力边界的关键，智能体通过工具调‌用可以访问搜索引擎、数据库、API 接口等外部服务，极大地增强了‎其解决实际问题的能力。当然，MC‌P 也可以算是工具调用的一种。</p>\n<p>💡 这里分享一种特⁠殊的工具调用 —— Compute U‌se，它允许智能体直接与计算环境交互，比如执行代码、操作文件系统等。目前 C‎laude 等平台已提供此类能力，感兴‌趣的同学可以阅读下面的资料学习：</p>\n<ul>\n<li>Claude 支持 Compute Use：<a href=\"https://docs.anthropic.com/en/docs/agents-and-tools/computer-use\">https://docs.anthropic.com/en/docs/agents-and-tools/computer-use</a></li>\n<li>Compute Use 实现示例：<a href=\"https://github.com/anthropics/anthropic-quickstarts/tree/main/computer-use-demo\">https://github.com/anthropics/anthropic-quickstarts/tree/main/computer-use-demo</a></li>\n<li>Compute Use 开源实现：<a href=\"https://github.com/e2b-dev/open-computer-use%E3%80%81https://github.com/showlab/computer_use_ootb\">https://github.com/e2b-dev/open-computer-use、https://github.com/showlab/computer_use_ootb</a></li>\n</ul>\n<p>使用 Com⁠pute Use 功能‌时需要注意，这些操作会在我们自己的系统上执行‎，建议在虚拟环境中运行‌，防止意外操作影响实际系统。</p>\n<p>综合上面 4 类⁠技术，并且结合 CoT、Agen‌t Loop、ReAct 等机制（可以总称为 “规划执行机制”）‎，我们就可以构建一个完整的、有自‌主规划能力的智能体系统啦。</p>\n<h2 id=\"三、使用-AI-智能体\"><a href=\"#三、使用-AI-智能体\" class=\"headerlink\" title=\"三、使用 AI 智能体\"></a>三、使用 AI 智能体</h2><p>有 3 种⁠方式可以使用 AI‌ 智能体，之前的教程中其实我们已经有‎接触过，这里再快速‌复习一遍。</p>\n<h3 id=\"1、平台中使用\"><a href=\"#1、平台中使用\" class=\"headerlink\" title=\"1、平台中使用\"></a>1、平台中使用</h3><p>许多 AI⁠ 大模型开发平台已‌经提供了智能体创建和使用功能，最简单‎的方式就是直接在这‌些平台上创建和使用智能体。</p>\n<p>比如可以在阿里云百炼、Dify 等平台上创建智能体</p>\n<h3 id=\"2、软件中使用\"><a href=\"#2、软件中使用\" class=\"headerlink\" title=\"2、软件中使用\"></a>2、软件中使用</h3><p>AI 开发工具 C⁠ursor 就集成了 AI 智能体‌，可以帮我们生成完整的项目代码、或者解释项目代码。选择 Agent ‎模式就可以直接使用了，建议同时开启‌ Thinking 深度思考：</p>\n<p><img src=\"/post/agent/image-20251111110936173.png\" alt=\"image-20251111110936173\"></p>\n<p>运行效果如⁠图，典型的 CoT‌ + Agent Loop + Re‎Act 模式：</p>\n<p><img src=\"/post/agent/image-20251111111133877.png\" alt=\"image-20251111111133877\"></p>\n<h3 id=\"3、程序中使用\"><a href=\"#3、程序中使用\" class=\"headerlink\" title=\"3、程序中使用\"></a>3、程序中使用</h3><p>之前有讲解过⁠，如果使用 AI 大模‌型开发平台创建了智能体，那么可以直接通过 S‎DK 或 API 在自‌己的程序中调用智能体。</p>\n<p>当然也可以完全通⁠过编程自主开发智能体，之前我们‌通过 Spring AI 创建的恋爱大师 APP 就已经是个‎智能体了，包含了大模型决策、记‌忆能力、知识库集成和工具调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChatResponse response = chatClient  </span><br><span class=\"line\">        .prompt()  </span><br><span class=\"line\">        .user(message)  </span><br><span class=\"line\">        </span><br><span class=\"line\">        .advisors(spec -&gt; spec.param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)  </span><br><span class=\"line\">                .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 10))  </span><br><span class=\"line\">        </span><br><span class=\"line\">        .advisors(new MyLoggerAdvisor())  </span><br><span class=\"line\">        </span><br><span class=\"line\">        .advisors(new QuestionAnswerAdvisor(loveAppVectorStore))  </span><br><span class=\"line\">        </span><br><span class=\"line\">        .tools(toolCallbackProvider)  </span><br><span class=\"line\">        .call()  </span><br><span class=\"line\">        .chatResponse();</span><br></pre></td></tr></table></figure>\n\n<p>但是，这个⁠实现还不具备完整的‌自主规划和执行能力，下面我们将学习更‎高级的自主规划智‌能体架构。</p>\n<h2 id=\"四、OpenManus-实现原理\"><a href=\"#四、OpenManus-实现原理\" class=\"headerlink\" title=\"四、OpenManus 实现原理\"></a>四、OpenManus 实现原理</h2><p>在我们开发超级智能体前，可以先学习下优秀的开源项目。下面以 <a href=\"https://github.com/FoundationAgents/OpenManus\">OpenManus 项目</a> 为例，带大家从 0 开始阅读项目源码，学到超级智能体实现方式的同时，帮助大家掌握快速学习开源项目的方法。</p>\n<p>💡 友情提⁠示，带大家分析的源‌码是 2025 年 5 月 16 日的，后续‎源码可能会持续更新，重‌点在于学习分析源码的套路。</p>\n<h3 id=\"快速运行\"><a href=\"#快速运行\" class=\"headerlink\" title=\"快速运行\"></a>快速运行</h3><p>学习开源项目的第一步是阅读官方提供的 <code>README.md</code> 项目介绍文档，先把项目跑起来，借此熟悉业务流程，而不是一上来就啃源码。</p>\n<p>OpenM⁠anus 官方提供‌了一个 Demo 视频，我们就不必再‎自己搭建环境来跑项‌目了：</p>\n<p>下面让我们看一⁠个 OpenManus 的‌对话示例，帮助我们了解它的工作流程。假设用户要完成一‎个任务 —— 在编程导航网‌站上寻找热门文章，对话如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户：帮我在github网站上找到最近的几篇热门文章  </span><br><span class=\"line\">  </span><br><span class=\"line\">系统：OpenManus 已启动，正在处理您的请求...  </span><br><span class=\"line\">  </span><br><span class=\"line\">助手：我会帮您在github网站查找最近的热门文章。让我先用浏览器工具访问编程导航网站。  </span><br><span class=\"line\">  </span><br><span class=\"line\">系统：正在调用浏览器工具...  </span><br><span class=\"line\">  </span><br><span class=\"line\">助手：我成功打开了浏览器并访问了github网站。从网站内容来看，我现在需要导航到热门文章区域，然后提取这些文章的信息。  </span><br><span class=\"line\">  </span><br><span class=\"line\">系统：正在执行浏览器操作...  </span><br><span class=\"line\">  </span><br><span class=\"line\">助手：我已在github网站找到了热门文章区域，以下是最近的几篇热门文章：  </span><br><span class=\"line\">  </span><br><span class=\"line\">1. 《Spring Boot 实战：构建微服务应用》- 阅读量：3200  </span><br><span class=\"line\">2. 《前端框架对比：React vs Vue vs Angular》- 阅读量：2850  </span><br><span class=\"line\">3. 《Python 数据分析入门：从 Pandas 到可视化》- 阅读量：2400  </span><br><span class=\"line\">4. 《Docker 容器化应用部署最佳实践》- 阅读量：2150  </span><br><span class=\"line\">5. 《算法学习路线：从入门到精通》- 阅读量：1980  </span><br><span class=\"line\">  </span><br><span class=\"line\">这些文章是根据网站显示的阅读量排序的热门文章。  </span><br><span class=\"line\">  </span><br><span class=\"line\">系统：正在调用终止工具...  </span><br><span class=\"line\">  </span><br><span class=\"line\">助手：已完成任务，成功找到github网站上的热门文章。如果您对某篇文章感兴趣或有其他需求，请随时告诉我。</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，OpenMa⁠nus 首先理解用户任务，然后选择合适的工具（浏览‌器工具）来执行任务，最后整理信息并返回结果。整个过程体现了 ReAct 模式的核心要素：思考（Thi‎nking）、行动（Action）和观察（Obse‌rvation）的循环，直到任务完成。</p>\n<h3 id=\"OpenManus-整体架构\"><a href=\"#OpenManus-整体架构\" class=\"headerlink\" title=\"OpenManus 整体架构\"></a>OpenManus 整体架构</h3><p>了解了 OpenManus 的核心功能后，先 <strong>从整体到局部</strong> 地观察 OpenManus 的架构，简单来说就是看文件夹的组织形式、文件的命名规则、以及文件之间的关联，暂时不用深入源码。</p>\n<h4 id=\"1、整体文件夹组织形式\"><a href=\"#1、整体文件夹组织形式\" class=\"headerlink\" title=\"1、整体文件夹组织形式\"></a>1、整体文件夹组织形式</h4><p>先看文件夹的组织形式，见名知意：</p>\n<p><img src=\"/post/agent/image-20251111111206853.png\" alt=\"image-20251111111206853\"></p>\n<h4 id=\"2、agent-目录\"><a href=\"#2、agent-目录\" class=\"headerlink\" title=\"2、agent 目录\"></a>2、agent 目录</h4><p>agent ⁠目录是 OpenMan‌us 实现的核心，采用了分层的代理架构，不同‎层次的代理负责不同的功‌能，这样更利于系统的扩展。</p>\n<p><img src=\"/post/agent/image-20251111111219397.png\" alt=\"image-20251111111219397\"></p>\n<p>OpenManus 的代理架构主要包含以下几层：</p>\n<ul>\n<li>BaseAgent：最基础的代理抽象类，定义了所有代理的基本状态管理和执行循环</li>\n<li>ReActAgent：实现 ReAct 模式的代理，具有思考（Think）和行动（Act）两个主要步骤</li>\n<li>ToolCallAgent：能够调用工具的代理，继承自 ReActAgent 并扩展了工具调用能力</li>\n<li>Manus：具体实现的智能体实例，集成了所有能力并添加了更多专业工具</li>\n</ul>\n<p>还有更多适用于特定领域⁠的智能体实例，比如 DataAnalysis‌ 数据分析 Agent、SWE 软件开发工程师 Agent、MCP 服务交互 Agent‎、Browser 浏览器操作 Agent，它‌们都继承了 ToolCallAgent。</p>\n<p><img src=\"/post/agent/image-20251111113232712.png\" alt=\"image-20251111113232712\"></p>\n<h4 id=\"3、tool-目录\"><a href=\"#3、tool-目录\" class=\"headerlink\" title=\"3、tool 目录\"></a>3、tool 目录</h4><p>tool ⁠目录定义了各种各样‌的工具，比如网页搜索、文件操作、询求‎用户帮助、代码执行‌器等等：</p>\n<p><img src=\"/post/agent/image-20251111113350138.png\" alt=\"image-20251111113350138\"></p>\n<h4 id=\"4、prompt-目录\"><a href=\"#4、prompt-目录\" class=\"headerlink\" title=\"4、prompt 目录\"></a>4、prompt 目录</h4><p>promp⁠t 目录定义了整个项‌目中可能会用到的提示词。从下图中我们可以‎看到提示词写的比较专‌业，这块也是比较值得学习的。</p>\n<p><img src=\"/post/agent/image-20251111113400077.png\" alt=\"image-20251111113400077\"></p>\n<h4 id=\"5、其他支持\"><a href=\"#5、其他支持\" class=\"headerlink\" title=\"5、其他支持\"></a>5、其他支持</h4><p>为了实现完⁠整的智能体功能，O‌penManus 依赖以下关键组件：</p>\n<ul>\n<li>记忆系统：使用 Memory 类存储对话历史和中间状态</li>\n<li>LLM 大模型：通过 LLM 类提供思考和决策能力</li>\n<li>工具系统：提供 BaseTool 和 ToolCollection 类扩展智能体的能力边界</li>\n<li>流程控制：通过 AgentState 和执行循环管理状态转换和任务流程</li>\n</ul>\n<p>在 OpenManus 中，这些都是自主实现的：</p>\n<p><img src=\"/post/agent/image-20251111113409716.png\" alt=\"image-20251111113409716\"></p>\n<h3 id=\"AI-智能体核心实现\"><a href=\"#AI-智能体核心实现\" class=\"headerlink\" title=\"AI 智能体核心实现\"></a>AI 智能体核心实现</h3><p>了解整体架构后，我们重点学习 Agent 分层代理架构。</p>\n<h4 id=\"1、BaseAgent\"><a href=\"#1、BaseAgent\" class=\"headerlink\" title=\"1、BaseAgent\"></a>1、BaseAgent</h4><p>BaseAgent 是所有代理的基础，定义了代理状态管理和执行循环的核心逻辑。查看 <code>base.py</code> 文件，关键代码就是 Agent Loop 的实现，通过 while 实现循环，并且定义了死循环检查机制：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BaseAgent(BaseModel, ABC):  </span><br><span class=\"line\">    async def run(self, request: Optional[str] = None) -&gt; str:  </span><br><span class=\"line\">        &quot;&quot;&quot;执行代理的主循环&quot;&quot;&quot;  </span><br><span class=\"line\">        if self.state != AgentState.IDLE:  </span><br><span class=\"line\">            raise RuntimeError(f&quot;Cannot run agent from state: &#123;self.state&#125;&quot;)  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if request:  </span><br><span class=\"line\">            self.update_memory(&quot;user&quot;, request)  </span><br><span class=\"line\">  </span><br><span class=\"line\">        results: List[str] = []  </span><br><span class=\"line\">        async with self.state_context(AgentState.RUNNING):  </span><br><span class=\"line\">            while (self.current_step &lt; self.max_steps and   </span><br><span class=\"line\">                  self.state != AgentState.FINISHED):  </span><br><span class=\"line\">                self.current_step += 1  </span><br><span class=\"line\">                step_result = await self.step()  </span><br><span class=\"line\">                  </span><br><span class=\"line\">                </span><br><span class=\"line\">                if self.is_stuck():  </span><br><span class=\"line\">                    self.handle_stuck_state()  </span><br><span class=\"line\">                      </span><br><span class=\"line\">                results.append(f&quot;Step &#123;self.current_step&#125;: &#123;step_result&#125;&quot;)  </span><br><span class=\"line\">  </span><br><span class=\"line\">            if self.current_step &gt;= self.max_steps:  </span><br><span class=\"line\">                self.current_step = 0  </span><br><span class=\"line\">                self.state = AgentState.IDLE  </span><br><span class=\"line\">                results.append(f&quot;Terminated: Reached max steps (&#123;self.max_steps&#125;)&quot;)  </span><br><span class=\"line\">          </span><br><span class=\"line\">        return &quot;\\n&quot;.join(results) if results else &quot;No steps executed&quot;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    @abstractmethod  </span><br><span class=\"line\">    async def step(self) -&gt; str:  </span><br><span class=\"line\">        &quot;&quot;&quot;执行单步操作，必须由子类实现&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里其实使⁠用了模板方法设计模‌式，父类定义执行流程，具体的执行方法‎（step）交给‌子类实现。</p>\n<h4 id=\"2、ReActAgent\"><a href=\"#2、ReActAgent\" class=\"headerlink\" title=\"2、ReActAgent\"></a>2、ReActAgent</h4><p>ReActAgent 实现了 ReAct 模式，将代理的执行过程分为思考（Think）和行动（Act）两个关键步骤。查看 <code>react.py</code> 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ReActAgent(BaseAgent, ABC):  </span><br><span class=\"line\">    @abstractmethod  </span><br><span class=\"line\">    async def think(self) -&gt; bool:  </span><br><span class=\"line\">        &quot;&quot;&quot;处理当前状态并决定下一步行动&quot;&quot;&quot;  </span><br><span class=\"line\">          </span><br><span class=\"line\">    @abstractmethod  </span><br><span class=\"line\">    async def act(self) -&gt; str:  </span><br><span class=\"line\">        &quot;&quot;&quot;执行决定的行动&quot;&quot;&quot;  </span><br><span class=\"line\">          </span><br><span class=\"line\">    async def step(self) -&gt; str:  </span><br><span class=\"line\">        &quot;&quot;&quot;执行单步：思考和行动&quot;&quot;&quot;  </span><br><span class=\"line\">        should_act = await self.think()  </span><br><span class=\"line\">        if not should_act:  </span><br><span class=\"line\">            return &quot;Thinking complete - no action needed&quot;  </span><br><span class=\"line\">        return await self.act()</span><br></pre></td></tr></table></figure>\n\n<p>上述代码同样运用⁠了模板方法设计模式，这种设计体现‌了 ReAct 模式的核心思想，也就是 “思考 - 行动 - 观‎察” 的循环过程。但是具体怎么思‌考、怎么行动，交给子类去实现。</p>\n<h4 id=\"3、ToolCallAgent\"><a href=\"#3、ToolCallAgent\" class=\"headerlink\" title=\"3、ToolCallAgent\"></a>3、ToolCallAgent</h4><p>ToolCallAgent 在 ReAct 模式的基础上增加了工具调用能力，是 OpenManus 最重要的一个层次。查看 <code>toolcall.py</code> 文件，虽然代码比较复杂，但原理很简单，就是工具调用机制的具体实现：</p>\n<ol>\n<li>think：和 AI 交互思考使用什么工具</li>\n<li>act：程序执行工具</li>\n<li>observe：将结果返回给 AI</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ToolCallAgent(ReActAgent):  </span><br><span class=\"line\">    &quot;&quot;&quot;能够执行工具调用的代理类&quot;&quot;&quot;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    available_tools: ToolCollection = ToolCollection(  </span><br><span class=\"line\">        CreateChatCompletion(), Terminate()  </span><br><span class=\"line\">    )  </span><br><span class=\"line\">    tool_choices: TOOL_CHOICE_TYPE = ToolChoice.AUTO  </span><br><span class=\"line\">    special_tool_names: List[str] = Field(default_factory=lambda: [Terminate().name])  </span><br><span class=\"line\">      </span><br><span class=\"line\">    async def think(self) -&gt; bool:  </span><br><span class=\"line\">        &quot;&quot;&quot;处理当前状态并使用工具决定下一步行动&quot;&quot;&quot;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        if self.next_step_prompt:  </span><br><span class=\"line\">            user_msg = Message.user_message(self.next_step_prompt)  </span><br><span class=\"line\">            self.messages += [user_msg]  </span><br><span class=\"line\">              </span><br><span class=\"line\">        </span><br><span class=\"line\">        response = await self.llm.ask_tool(  </span><br><span class=\"line\">            messages=self.messages,  </span><br><span class=\"line\">            system_msgs=([Message.system_message(self.system_prompt)]   </span><br><span class=\"line\">                        if self.system_prompt else None),  </span><br><span class=\"line\">            tools=self.available_tools.to_params(),  </span><br><span class=\"line\">            tool_choice=self.tool_choices,  </span><br><span class=\"line\">        )  </span><br><span class=\"line\">          </span><br><span class=\"line\">        </span><br><span class=\"line\">        self.tool_calls = tool_calls = (  </span><br><span class=\"line\">            response.tool_calls if response and response.tool_calls else []  </span><br><span class=\"line\">        )  </span><br><span class=\"line\">        content = response.content if response and response.content else &quot;&quot;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        </span><br><span class=\"line\">        assistant_msg = (  </span><br><span class=\"line\">            Message.from_tool_calls(content=content, tool_calls=self.tool_calls)  </span><br><span class=\"line\">            if self.tool_calls  </span><br><span class=\"line\">            else Message.assistant_message(content)  </span><br><span class=\"line\">        )  </span><br><span class=\"line\">        self.memory.add_message(assistant_msg)  </span><br><span class=\"line\">          </span><br><span class=\"line\">        </span><br><span class=\"line\">        return bool(self.tool_calls or content)  </span><br><span class=\"line\">      </span><br><span class=\"line\">    async def act(self) -&gt; str:  </span><br><span class=\"line\">        &quot;&quot;&quot;执行工具调用并处理结果&quot;&quot;&quot;  </span><br><span class=\"line\">        if not self.tool_calls:  </span><br><span class=\"line\">            </span><br><span class=\"line\">            return self.messages[-1].content or &quot;No content or commands to execute&quot;  </span><br><span class=\"line\">              </span><br><span class=\"line\">        results = []  </span><br><span class=\"line\">        for command in self.tool_calls:  </span><br><span class=\"line\">            </span><br><span class=\"line\">            result = await self.execute_tool(command)  </span><br><span class=\"line\">              </span><br><span class=\"line\">            </span><br><span class=\"line\">            tool_msg = Message.tool_message(  </span><br><span class=\"line\">                content=result,  </span><br><span class=\"line\">                tool_call_id=command.id,  </span><br><span class=\"line\">                name=command.function.name,  </span><br><span class=\"line\">                base64_image=self._current_base64_image,  </span><br><span class=\"line\">            )  </span><br><span class=\"line\">            self.memory.add_message(tool_msg)  </span><br><span class=\"line\">            results.append(result)  </span><br><span class=\"line\">              </span><br><span class=\"line\">        return &quot;\\n\\n&quot;.join(results)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、Manus\"><a href=\"#4、Manus\" class=\"headerlink\" title=\"4、Manus\"></a>4、Manus</h4><p>Manus 类是 OpenManus 的核心智能体实例，集成了各种工具和能力。查看 <code>manus.py</code> 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Manus(ToolCallAgent):  </span><br><span class=\"line\">    &quot;&quot;&quot;多功能通用智能体，支持本地和 MCP 工具&quot;&quot;&quot;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    name: str = &quot;Manus&quot;  </span><br><span class=\"line\">    description: str = &quot;A versatile agent that can solve various tasks using multiple tools&quot;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    </span><br><span class=\"line\">    available_tools: ToolCollection = Field(  </span><br><span class=\"line\">        default_factory=lambda: ToolCollection(  </span><br><span class=\"line\">            PythonExecute(),  </span><br><span class=\"line\">            BrowserUseTool(),  </span><br><span class=\"line\">            StrReplaceEditor(),  </span><br><span class=\"line\">            AskHuman(),  </span><br><span class=\"line\">            Terminate(),  </span><br><span class=\"line\">        )  </span><br><span class=\"line\">    )  </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"MCP-客户端用于远程工具访问\"><a href=\"#MCP-客户端用于远程工具访问\" class=\"headerlink\" title=\"MCP 客户端用于远程工具访问\"></a>MCP 客户端用于远程工具访问</h4><p>mcp_clients: MCPClients &#x3D; Field(default_factory&#x3D;MCPClients)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@classmethod  </span><br><span class=\"line\">async def create(cls, **kwargs) -&gt; &quot;Manus&quot;:  </span><br><span class=\"line\">    &quot;&quot;&quot;工厂方法创建并初始化 Manus 实例&quot;&quot;&quot;  </span><br><span class=\"line\">    instance = cls(**kwargs)  </span><br><span class=\"line\">    await instance.initialize_mcp_servers()  </span><br><span class=\"line\">    instance._initialized = True  </span><br><span class=\"line\">    return instance  </span><br><span class=\"line\">      </span><br><span class=\"line\">async def think(self) -&gt; bool:  </span><br><span class=\"line\">    &quot;&quot;&quot;处理当前状态并根据上下文决定下一步行动&quot;&quot;&quot;  </span><br><span class=\"line\">    if not self._initialized:  </span><br><span class=\"line\">        await self.initialize_mcp_servers()  </span><br><span class=\"line\">        self._initialized = True  </span><br><span class=\"line\">          </span><br><span class=\"line\">    </span><br><span class=\"line\">    original_prompt = self.next_step_prompt  </span><br><span class=\"line\">    browser_in_use = self._check_browser_in_use()  </span><br><span class=\"line\">      </span><br><span class=\"line\">    if browser_in_use:  </span><br><span class=\"line\">        self.next_step_prompt = (  </span><br><span class=\"line\">            await self.browser_context_helper.format_next_step_prompt()  </span><br><span class=\"line\">        )  </span><br><span class=\"line\">          </span><br><span class=\"line\">    result = await super().think()  </span><br><span class=\"line\">      </span><br><span class=\"line\">    </span><br><span class=\"line\">    self.next_step_prompt = original_prompt  </span><br><span class=\"line\">      </span><br><span class=\"line\">    return result</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键实现细节\"><a href=\"#关键实现细节\" class=\"headerlink\" title=\"关键实现细节\"></a>关键实现细节</h3><p>学完了超级智能体⁠的核心实现后，我们再学习一些项‌目中比较微妙的实现细节，对我们自己开发项目也会很有帮助   ‎               ‌              </p>\n<h4 id=\"1、工具系统设计\"><a href=\"#1、工具系统设计\" class=\"headerlink\" title=\"1、工具系统设计\"></a>1、工具系统设计</h4><p>1）工具抽象层 BaseTool</p>\n<p>所有工具均继承自 <code>BaseTool</code> 抽象基类，提供统一的接口和行为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BaseTool(ABC, BaseModel):  </span><br><span class=\"line\">    name: str  </span><br><span class=\"line\">    description: str  </span><br><span class=\"line\">    parameters: Optional[dict] = None  </span><br><span class=\"line\">      </span><br><span class=\"line\">    async def __call__(self, **kwargs) -&gt; Any:  </span><br><span class=\"line\">        &quot;&quot;&quot;使用给定参数执行工具&quot;&quot;&quot;  </span><br><span class=\"line\">        return await self.execute(**kwargs)  </span><br><span class=\"line\">          </span><br><span class=\"line\">    @abstractmethod  </span><br><span class=\"line\">    async def execute(self, **kwargs) -&gt; Any:  </span><br><span class=\"line\">        &quot;&quot;&quot;执行工具的具体逻辑，由子类实现&quot;&quot;&quot;  </span><br><span class=\"line\">          </span><br><span class=\"line\">    def to_param(self) -&gt; Dict:  </span><br><span class=\"line\">        &quot;&quot;&quot;将工具转换为函数调用格式&quot;&quot;&quot;  </span><br><span class=\"line\">        return &#123;  </span><br><span class=\"line\">            &quot;type&quot;: &quot;function&quot;,  </span><br><span class=\"line\">            &quot;function&quot;: &#123;  </span><br><span class=\"line\">                &quot;name&quot;: self.name,  </span><br><span class=\"line\">                &quot;description&quot;: self.description,  </span><br><span class=\"line\">                &quot;parameters&quot;: self.parameters,  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种设计使⁠得每个工具都有统一‌的调用方式，同时具有规范化的参数描述‎，便于 LLM 理‌解工具的使用方法。</p>\n<p>2）终止工具 Terminate</p>\n<p>Termi⁠nate 工具是一个‌特殊的工具，允许智能体通过 AI 大模型‎自主决定何时结束任务‌，避免无限循环或者过早结束。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Terminate(BaseTool):  </span><br><span class=\"line\">    name: str = &quot;terminate&quot;  </span><br><span class=\"line\">    description: str = &quot;&quot;&quot;Terminate the interaction when the request is met OR   </span><br><span class=\"line\">                          if the assistant cannot proceed further with the task.  </span><br><span class=\"line\">                          When you have finished all the tasks, call this tool to end the work.&quot;&quot;&quot;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    parameters: dict = &#123;  </span><br><span class=\"line\">        &quot;type&quot;: &quot;object&quot;,  </span><br><span class=\"line\">        &quot;properties&quot;: &#123;  </span><br><span class=\"line\">            &quot;status&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;string&quot;,  </span><br><span class=\"line\">                &quot;description&quot;: &quot;The finish status of the interaction.&quot;,  </span><br><span class=\"line\">                &quot;enum&quot;: [&quot;success&quot;, &quot;failure&quot;],  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        &quot;required&quot;: [&quot;status&quot;],  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    async def execute(self, status: str) -&gt; str:  </span><br><span class=\"line\">        &quot;&quot;&quot;完成当前执行&quot;&quot;&quot;  </span><br><span class=\"line\">        return f&quot;The interaction has been completed with status: &#123;status&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>在 agent 源码中，有一个 <code>special_tool_names</code> 变量，用于指定终止工具等特殊工具：</p>\n<p><img src=\"/post/agent/image-20251111133305916.png\" alt=\"image-20251111133305916\"></p>\n<p>在 <code>toolcall.py</code> 源码中，对特殊工具进行处理：</p>\n<p><img src=\"/post/agent/image-20251111133338531.png\" alt=\"image-20251111133338531\"></p>\n<p>3）询问工具 AskHuman</p>\n<p>AskHuma⁠n 工具允许智能体在遇到无‌法自主解决的问题时向人类寻求帮助，也就是给用户一个输‎入框，让我们能够更好地干预‌智能体完成任务的过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class AskHuman(BaseTool):  </span><br><span class=\"line\">    &quot;&quot;&quot;Add a tool to ask human for help.&quot;&quot;&quot;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    name: str = &quot;ask_human&quot;  </span><br><span class=\"line\">    description: str = &quot;Use this tool to ask human for help.&quot;  </span><br><span class=\"line\">    parameters: str = &#123;  </span><br><span class=\"line\">        &quot;type&quot;: &quot;object&quot;,  </span><br><span class=\"line\">        &quot;properties&quot;: &#123;  </span><br><span class=\"line\">            &quot;inquire&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;string&quot;,  </span><br><span class=\"line\">                &quot;description&quot;: &quot;The question you want to ask human.&quot;,  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        &quot;required&quot;: [&quot;inquire&quot;],  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    async def execute(self, inquire: str) -&gt; str:  </span><br><span class=\"line\">        return input(f&quot;&quot;&quot;Bot: &#123;inquire&#125;\\n\\nYou: &quot;&quot;&quot;).strip()</span><br></pre></td></tr></table></figure>\n\n<p>这个工具实⁠现虽然简单，但极大‌地提升了智能体的实用性和安全性。</p>\n<p>4）工具集合 ToolCollection</p>\n<p>OpenM⁠anus 设计了 T‌oolCollection 类来管理多个‎工具实例，提供统一的‌工具注册和执行接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ToolCollection:  </span><br><span class=\"line\">    &quot;&quot;&quot;A collection of defined tools.&quot;&quot;&quot;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    def __init__(self, *tools: BaseTool):  </span><br><span class=\"line\">        self.tools = tools  </span><br><span class=\"line\">        self.tool_map = &#123;tool.name: tool for tool in tools&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    def to_params(self) -&gt; List[Dict[str, Any]]:  </span><br><span class=\"line\">        return [tool.to_param() for tool in self.tools]  </span><br><span class=\"line\">  </span><br><span class=\"line\">    async def execute(self, *, name: str, tool_input: Dict[str, Any] = None) -&gt; ToolResult:  </span><br><span class=\"line\">        tool = self.tool_map.get(name)  </span><br><span class=\"line\">        if not tool:  </span><br><span class=\"line\">            return ToolFailure(error=f&quot;Tool &#123;name&#125; is invalid&quot;)  </span><br><span class=\"line\">        try:  </span><br><span class=\"line\">            result = await tool(**tool_input)  </span><br><span class=\"line\">            return result  </span><br><span class=\"line\">        except ToolError as e:  </span><br><span class=\"line\">            return ToolFailure(error=e.message)  </span><br><span class=\"line\">              </span><br><span class=\"line\">    def add_tools(self, *tools: BaseTool):  </span><br><span class=\"line\">        &quot;&quot;&quot;Add multiple tools to the collection.&quot;&quot;&quot;  </span><br><span class=\"line\">        for tool in tools:  </span><br><span class=\"line\">            self.add_tool(tool)  </span><br><span class=\"line\">        return self</span><br></pre></td></tr></table></figure>\n\n<p>这种设计使得 O⁠penManus 可以灵活地添‌加、移除和管理工具，实现了工具系统的可插拔性。我们之前利用 ‎Spring AI 开发工具调‌用时，也写了个类似的工具注册类。</p>\n<h4 id=\"2、MCP-协议支持\"><a href=\"#2、MCP-协议支持\" class=\"headerlink\" title=\"2、MCP 协议支持\"></a>2、MCP 协议支持</h4><p>1）MCP 与工具系统的集成</p>\n<p>还记得么，之前在教程中提到过 “MCP 的本质就是工具调用”，OpenManus 的实现也是遵循了这一思想。通过 <code>MCPClients</code> 类（继承自 ToolCollection）将 MCP 服务集成到现有工具系统中。查看 <code>tool/mcp.py</code> 的源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MCPClients(ToolCollection):  </span><br><span class=\"line\">    &quot;&quot;&quot;  </span><br><span class=\"line\">    A collection of tools that connects to multiple MCP servers and manages available tools through the Model Context Protocol.  </span><br><span class=\"line\">    &quot;&quot;&quot;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    sessions: Dict[str, ClientSession] = &#123;&#125;  </span><br><span class=\"line\">    exit_stacks: Dict[str, AsyncExitStack] = &#123;&#125;  </span><br><span class=\"line\">    description: str = &quot;MCP client tools for server interaction&quot;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    def __init__(self):  </span><br><span class=\"line\">        super().__init__()  </span><br><span class=\"line\">        self.name = &quot;mcp&quot;  </span><br></pre></td></tr></table></figure>\n\n<p>2）动态工具代理</p>\n<p>每当连接到 MCP 服务器时，OpenManus 会动态创建 <code>MCPClientTool</code> 实例（继承自 BaseTool）作为每个远程工具的代理。查看 <code>tool/mcp.py</code> 的源码，通过向 MCP 服务器发送远程请求来执行工具：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MCPClientTool(BaseTool):  </span><br><span class=\"line\">    &quot;&quot;&quot;Represents a tool proxy that can be called on the MCP server from the client side.&quot;&quot;&quot;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    session: Optional[ClientSession] = None  </span><br><span class=\"line\">    server_id: str = &quot;&quot;  </span><br><span class=\"line\">    original_name: str = &quot;&quot;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    async def execute(self, **kwargs) -&gt; ToolResult:  </span><br><span class=\"line\">        &quot;&quot;&quot;Execute the tool by making a remote call to the MCP server.&quot;&quot;&quot;  </span><br><span class=\"line\">        if not self.session:  </span><br><span class=\"line\">            return ToolResult(error=&quot;Not connected to MCP server&quot;)  </span><br><span class=\"line\">  </span><br><span class=\"line\">        try:  </span><br><span class=\"line\">            result = await self.session.call_tool(self.original_name, kwargs)  </span><br><span class=\"line\">            content_str = &quot;, &quot;.join(  </span><br><span class=\"line\">                item.text for item in result.content if isinstance(item, TextContent)  </span><br><span class=\"line\">            )  </span><br><span class=\"line\">            return ToolResult(output=content_str or &quot;No output returned.&quot;)  </span><br><span class=\"line\">        except Exception as e:  </span><br><span class=\"line\">            return ToolResult(error=f&quot;Error executing tool: &#123;str(e)&#125;&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>3）Manus 中的 MCP 集成机制</p>\n<p>Manus 智能体 <strong>通过工具调用</strong> 实现了与 MCP 服务器的无缝集成。查看 <code>agent/manus.py</code> 的源码，发现本质上是把 MCP 服务提供的工具动态添加到可用的工具集合中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async def connect_mcp_server(  </span><br><span class=\"line\">    self,  </span><br><span class=\"line\">    server_url: str,  </span><br><span class=\"line\">    server_id: str = &quot;&quot;,  </span><br><span class=\"line\">    use_stdio: bool = False,  </span><br><span class=\"line\">    stdio_args: List[str] = None,  </span><br><span class=\"line\">) -&gt; None:  </span><br><span class=\"line\">    &quot;&quot;&quot;Connect to an MCP server and add its tools.&quot;&quot;&quot;  </span><br><span class=\"line\">    if use_stdio:  </span><br><span class=\"line\">        await self.mcp_clients.connect_stdio(server_url, stdio_args or [], server_id)  </span><br><span class=\"line\">    else:  </span><br><span class=\"line\">        await self.mcp_clients.connect_sse(server_url, server_id)  </span><br><span class=\"line\">      </span><br><span class=\"line\">    </span><br><span class=\"line\">    new_tools = [  </span><br><span class=\"line\">        tool for tool in self.mcp_clients.tools if tool.server_id == server_id  </span><br><span class=\"line\">    ]  </span><br><span class=\"line\">    self.available_tools.add_tools(*new_tools)</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，⁠对大模型来说，MC‌P 工具与本地工具的调用方式一致，很‎巧妙地复用了代码。</p>\n<h4 id=\"3、其他值得学习的源码\"><a href=\"#3、其他值得学习的源码\" class=\"headerlink\" title=\"3、其他值得学习的源码\"></a>3、其他值得学习的源码</h4><p>1）Python 代码执行沙箱</p>\n<p><code>PythonExecute</code> 工具实现了一个安全的 Python 代码执行环境，这是一个值得学习的安全实现。查看 <code>tool/python_execute.py</code> 源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PythonExecute(BaseTool):  </span><br><span class=\"line\">    name: str = &quot;python_execute&quot;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    async def execute(self, code: str, timeout: int = 5) -&gt; Dict:  </span><br><span class=\"line\">        &quot;&quot;&quot;安全执行 Python 代码&quot;&quot;&quot;  </span><br><span class=\"line\">        with multiprocessing.Manager() as manager:  </span><br><span class=\"line\">            result = manager.dict(&#123;&quot;observation&quot;: &quot;&quot;, &quot;success&quot;: False&#125;)  </span><br><span class=\"line\">            </span><br><span class=\"line\">            safe_globals = &#123;&quot;__builtins__&quot;: __builtins__.__dict__.copy()&#125;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            proc = multiprocessing.Process(  </span><br><span class=\"line\">                target=self._run_code, args=(code, result, safe_globals)  </span><br><span class=\"line\">            )  </span><br><span class=\"line\">            proc.start()  </span><br><span class=\"line\">            proc.join(timeout)  </span><br><span class=\"line\">  </span><br><span class=\"line\">            </span><br><span class=\"line\">            if proc.is_alive():  </span><br><span class=\"line\">                proc.terminate()  </span><br><span class=\"line\">                proc.join(1)  </span><br><span class=\"line\">                return &#123;  </span><br><span class=\"line\">                    &quot;observation&quot;: f&quot;Execution timeout after &#123;timeout&#125; seconds&quot;,  </span><br><span class=\"line\">                    &quot;success&quot;: False,  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            return dict(result)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码展示了几个安全编程的最佳实践：</p>\n<ul>\n<li>使用独立进程隔离代码执行</li>\n<li>实现了超时机制防止无限循环</li>\n<li>截获和处理所有异常</li>\n<li>重定向标准输出以捕获打印内容</li>\n</ul>\n<p>2）状态管理与上下文切换机制</p>\n<p><code>BaseAgent</code> 实现了一个优雅的状态管理和上下文切换机制：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@asynccontextmanager  </span><br><span class=\"line\">async def state_context(self, new_state: AgentState):  </span><br><span class=\"line\">    &quot;&quot;&quot;Context manager for safe agent state transitions.&quot;&quot;&quot;  </span><br><span class=\"line\">    if not isinstance(new_state, AgentState):  </span><br><span class=\"line\">        raise ValueError(f&quot;Invalid state: &#123;new_state&#125;&quot;)  </span><br><span class=\"line\">  </span><br><span class=\"line\">    previous_state = self.state  </span><br><span class=\"line\">    self.state = new_state  </span><br><span class=\"line\">    try:  </span><br><span class=\"line\">        yield  </span><br><span class=\"line\">    except Exception as e:  </span><br><span class=\"line\">        self.state = AgentState.ERROR  </span><br><span class=\"line\">        raise e  </span><br><span class=\"line\">    finally:  </span><br><span class=\"line\">        self.state = previous_state  </span><br></pre></td></tr></table></figure>\n\n<p>这个上下文⁠管理器确保了状态转‌换的安全性和可靠性，即使在异常情况下‎也能正确恢复状态，‌是一个值得学习的设计模式。</p>\n<p>3）工具结果统一表示与组合</p>\n<p>OpenManus 设计了 <code>ToolResult</code> 类来统一表示工具执行结果，并支持结果组合。查看 <code>tool/base.py</code> 源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ToolResult(BaseModel):  </span><br><span class=\"line\">    &quot;&quot;&quot;Represents the result of a tool execution.&quot;&quot;&quot;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    output: Any = Field(default=None)  </span><br><span class=\"line\">    error: Optional[str] = Field(default=None)  </span><br><span class=\"line\">    base64_image: Optional[str] = Field(default=None)  </span><br><span class=\"line\">    system: Optional[str] = Field(default=None)  </span><br><span class=\"line\">      </span><br><span class=\"line\">    def __add__(self, other: &quot;ToolResult&quot;):  </span><br><span class=\"line\">        &quot;&quot;&quot;组合两个工具结果&quot;&quot;&quot;  </span><br><span class=\"line\">        def combine_fields(field: Optional[str], other_field: Optional[str], concatenate: bool = True):  </span><br><span class=\"line\">            if field and other_field:  </span><br><span class=\"line\">                if concatenate:  </span><br><span class=\"line\">                    return field + other_field  </span><br><span class=\"line\">                raise ValueError(&quot;Cannot combine tool results&quot;)  </span><br><span class=\"line\">            return field or other_field  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return ToolResult(  </span><br><span class=\"line\">            output=combine_fields(self.output, other.output),  </span><br><span class=\"line\">            error=combine_fields(self.error, other.error),  </span><br><span class=\"line\">            base64_image=combine_fields(self.base64_image, other.base64_image, False),  </span><br><span class=\"line\">            system=combine_fields(self.system, other.system),  </span><br><span class=\"line\">        )</span><br></pre></td></tr></table></figure>\n\n<p>这种设计使⁠得工具结果处理更加‌统一和灵活，特别是在需要组合多个工具‎结果或处理异常情况‌时。</p>\n<h2 id=\"五、自主实现-Manus-智能体\"><a href=\"#五、自主实现-Manus-智能体\" class=\"headerlink\" title=\"五、自主实现 Manus 智能体\"></a>五、自主实现 Manus 智能体</h2><p>虽然 OpenManus 代⁠码量很大，但其实很多代码都是在实现智能体所需的支持系统‌，比如调用大模型、会话记忆、工具调用能力等。如果使用 AI 开发框架，这些能力都不需要我们自己实现，代码量会简‎单很多。下面就让我们基于 Spring AI 框架，‌实现一个简化版的 Manus 智能体。</p>\n<h3 id=\"定义数据模型\"><a href=\"#定义数据模型\" class=\"headerlink\" title=\"定义数据模型\"></a>定义数据模型</h3><p>新建 <code>agent.model</code> 包，将所有用到的数据模型（实体类、枚举类等）都放到该包下。</p>\n<p>目前我们只⁠需要定义 Agen‌t 的状态枚举，用于控制智能体的执行‎。AgentSta‌te 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum AgentState &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    IDLE,  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    RUNNING,  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    FINISHED,  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    ERROR  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"核⁠心架构开发-‌-‎-‌\"><a href=\"#核⁠心架构开发-‌-‎-‌\" class=\"headerlink\" title=\"核⁠心架构开发    ‌                  ‎         ‌\"></a>核⁠心架构开发    ‌                  ‎         ‌</h3><p>首先定义智能体的核心架构，包括以下类：</p>\n<ul>\n<li>BaseAgent：智能体基类，定义基本信息和多步骤执行流程</li>\n<li>ReActAgent：实现思考和行动两个步骤的智能体</li>\n<li>ToolCallAgent：实现工具调用能力的智能体</li>\n<li>AzerManus：最终可使用的 Manus 实例</li>\n</ul>\n<h4 id=\"1、开发基础-Agent-类\"><a href=\"#1、开发基础-Agent-类\" class=\"headerlink\" title=\"1、开发基础 Agent 类\"></a>1、开发基础 Agent 类</h4><p>参考 Op⁠enManus 的‌实现方式，BaseAgent 的代码‎如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Data  </span><br><span class=\"line\">@Slf4j  </span><br><span class=\"line\">public abstract class BaseAgent &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private String name;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private String systemPrompt;  </span><br><span class=\"line\">    private String nextStepPrompt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private AgentState state = AgentState.IDLE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private int maxSteps = 10;  </span><br><span class=\"line\">    private int currentStep = 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private ChatClient chatClient;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private List&lt;Message&gt; messageList = new ArrayList&lt;&gt;();  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    public String run(String userPrompt) &#123;  </span><br><span class=\"line\">        if (this.state != AgentState.IDLE) &#123;  </span><br><span class=\"line\">            throw new RuntimeException(&quot;Cannot run agent from state: &quot; + this.state);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        if (StringUtil.isBlank(userPrompt)) &#123;  </span><br><span class=\"line\">            throw new RuntimeException(&quot;Cannot run agent with empty user prompt&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        state = AgentState.RUNNING;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        messageList.add(new UserMessage(userPrompt));  </span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;String&gt; results = new ArrayList&lt;&gt;();  </span><br><span class=\"line\">        try &#123;  </span><br><span class=\"line\">            for (int i = 0; i &lt; maxSteps &amp;&amp; state != AgentState.FINISHED; i++) &#123;  </span><br><span class=\"line\">                int stepNumber = i + 1;  </span><br><span class=\"line\">                currentStep = stepNumber;  </span><br><span class=\"line\">                log.info(&quot;Executing step &quot; + stepNumber + &quot;/&quot; + maxSteps);  </span><br><span class=\"line\">                </span><br><span class=\"line\">                String stepResult = step();  </span><br><span class=\"line\">                String result = &quot;Step &quot; + stepNumber + &quot;: &quot; + stepResult;  </span><br><span class=\"line\">                results.add(result);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            if (currentStep &gt;= maxSteps) &#123;  </span><br><span class=\"line\">                state = AgentState.FINISHED;  </span><br><span class=\"line\">                results.add(&quot;Terminated: Reached max steps (&quot; + maxSteps + &quot;)&quot;);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            return String.join(&quot;\\n&quot;, results);  </span><br><span class=\"line\">        &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">            state = AgentState.ERROR;  </span><br><span class=\"line\">            log.error(&quot;Error executing agent&quot;, e);  </span><br><span class=\"line\">            return &quot;执行错误&quot; + e.getMessage();  </span><br><span class=\"line\">        &#125; finally &#123;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            this.cleanup();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    public abstract String step();  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    protected void cleanup() &#123;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，我们要注意 3 点：</p>\n<ol>\n<li>包含 chatClient 属性，由调用方传入具体调用大模型的对象，而不是写死使用的大模型，更灵活</li>\n<li>包含 messageList 属性，用于维护消息上下文列表</li>\n<li>通过 state 属性来控制智能体的执行流程</li>\n</ol>\n<h4 id=\"2、开发-ReActAgent-类\"><a href=\"#2、开发-ReActAgent-类\" class=\"headerlink\" title=\"2、开发 ReActAgent 类\"></a>2、开发 ReActAgent 类</h4><p>参考 OpenM⁠anus 的实现方式，继承自 ‌BaseAgent，并且将 step 方法分解为 think‎ 和 act 两个抽象方法。R‌eActAgent 的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EqualsAndHashCode(callSuper = true)  </span><br><span class=\"line\">@Data  </span><br><span class=\"line\">public abstract class ReActAgent extends BaseAgent &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    public abstract boolean think();  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    public abstract String act();  </span><br><span class=\"line\">  </span><br><span class=\"line\">      </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String step() &#123;  </span><br><span class=\"line\">        try &#123;  </span><br><span class=\"line\">            boolean shouldAct = think();  </span><br><span class=\"line\">            if (!shouldAct) &#123;  </span><br><span class=\"line\">                return &quot;思考完成 - 无需行动&quot;;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            return act();  </span><br><span class=\"line\">        &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">            return &quot;步骤执行失败: &quot; + e.getMessage();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、开发-ToolCallAgent-类\"><a href=\"#3、开发-ToolCallAgent-类\" class=\"headerlink\" title=\"3、开发 ToolCallAgent 类\"></a>3、开发 ToolCallAgent 类</h4><p>ToolCa⁠llAgent 负责实现‌工具调用能力，继承自 ReActAgent，具体‎实现了 think 和 ‌act 两个抽象方法。</p>\n<p>我们有 3 种方案来实现 ToolCallAgent：</p>\n<p>1）基于 ⁠Spring AI‌ 的工具调用能力，手动控制工具执行。</p>\n<p>其实 Spring 的 ChatClient 已经支持选择工具进行调用（内部完成了 think、act、observe），但这里我们要自主实现，可以使用 Spring AI 提供的 <a href=\"https://docs.spring.io/spring-ai/reference/api/tools.html#_user_controlled_tool_execution\">手动控制工具执行</a>。</p>\n<p>2）基于 ⁠Spring AI‌ 的工具调用能力，简化调用流程。</p>\n<p>由于 Spr⁠ing AI 完全托管了‌工具调用，我们可以直接把所有工具调用的代码作为 ‎think 方法，而 a‌ct 方法不定义任何动作。</p>\n<p>3）自主实现工具调用能力。</p>\n<p>也就是工具调用⁠章节提到的实现原理：自己写‌ Prompt，引导 AI 回复想要调用的工具列表和‎调用参数，然后再执行工具并‌将结果返送给 AI 再次执行。</p>\n<p>使用哪种方案呢？</p>\n<p>如果是为了学⁠习 ReAct 模式，让‌流程更清晰，推荐第一种；如果只是为了快速实现，推‎荐第二种；不建议采用第三‌种方案，过于原生，开发成本高。</p>\n<p>下面我们采⁠用第一种方案实现 ‌ToolCallAgent，先定义所‎需的属性和构造方法‌：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EqualsAndHashCode(callSuper = true)  </span><br><span class=\"line\">@Data  </span><br><span class=\"line\">@Slf4j  </span><br><span class=\"line\">public class ToolCallAgent extends ReActAgent &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private final ToolCallback[] availableTools;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private ChatResponse toolCallChatResponse;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private final ToolCallingManager toolCallingManager;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    private final ChatOptions chatOptions;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public ToolCallAgent(ToolCallback[] availableTools) &#123;  </span><br><span class=\"line\">        super();  </span><br><span class=\"line\">        this.availableTools = availableTools;  </span><br><span class=\"line\">        this.toolCallingManager = ToolCallingManager.builder().build();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        this.chatOptions = DashScopeChatOptions.builder()  </span><br><span class=\"line\">                .withProxyToolCalls(true)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，在上述代码中⁠，我们通过将 DashScopeCh‌atOptions 的 withProxyToolCalls 选项设置为‎ true，来禁止 Spring A‌I 托管工具调用，而是我们自主实现。</p>\n<p><img src=\"/post/agent/image-20251111141743697.png\" alt=\"image-20251111141743697\"></p>\n<p>虽然官方提供的示例代码是设⁠置 internalToolExecutionEna‌bled 为 false 来禁用 Spring AI 托管工具调用，但是由于我们使用的是阿里的 Dash‎ScopeChatModel 大模型客户端，如果按照‌下面的方式，会直接导致工具调用失效！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChatOptions chatOptions = ToolCallingChatOptions.builder()  </span><br><span class=\"line\">    .toolCallbacks(new CustomerTools())  </span><br><span class=\"line\">    .internalToolExecutionEnabled(false)  </span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<p>下面我们实⁠现 think 方‌法，传入工具列表并调用大模型，得到需‎要调用的工具列表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override  </span><br><span class=\"line\">public boolean think() &#123;  </span><br><span class=\"line\">    if (getNextStepPrompt() != null &amp;&amp; !getNextStepPrompt().isEmpty()) &#123;  </span><br><span class=\"line\">        UserMessage userMessage = new UserMessage(getNextStepPrompt());  </span><br><span class=\"line\">        getMessageList().add(userMessage);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    List&lt;Message&gt; messageList = getMessageList();  </span><br><span class=\"line\">    Prompt prompt = new Prompt(messageList, chatOptions);  </span><br><span class=\"line\">    try &#123;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        ChatResponse chatResponse = getChatClient().prompt(prompt)  </span><br><span class=\"line\">                .system(getSystemPrompt())  </span><br><span class=\"line\">                .tools(availableTools)  </span><br><span class=\"line\">                .call()  </span><br><span class=\"line\">                .chatResponse();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        this.toolCallChatResponse = chatResponse;  </span><br><span class=\"line\">        AssistantMessage assistantMessage = chatResponse.getResult().getOutput();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        String result = assistantMessage.getText();  </span><br><span class=\"line\">        List&lt;AssistantMessage.ToolCall&gt; toolCallList = assistantMessage.getToolCalls();  </span><br><span class=\"line\">        log.info(getName() + &quot;的思考: &quot; + result);  </span><br><span class=\"line\">        log.info(getName() + &quot;选择了 &quot; + toolCallList.size() + &quot; 个工具来使用&quot;);  </span><br><span class=\"line\">        String toolCallInfo = toolCallList.stream()  </span><br><span class=\"line\">                .map(toolCall -&gt; String.format(&quot;工具名称：%s，参数：%s&quot;,  </span><br><span class=\"line\">                        toolCall.name(),  </span><br><span class=\"line\">                        toolCall.arguments())  </span><br><span class=\"line\">                )  </span><br><span class=\"line\">                .collect(Collectors.joining(&quot;\\n&quot;));  </span><br><span class=\"line\">        log.info(toolCallInfo);  </span><br><span class=\"line\">        if (toolCallList.isEmpty()) &#123;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            getMessageList().add(assistantMessage);  </span><br><span class=\"line\">            return false;  </span><br><span class=\"line\">        &#125; else &#123;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            return true;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">        log.error(getName() + &quot;的思考过程遇到了问题: &quot; + e.getMessage());  </span><br><span class=\"line\">        getMessageList().add(  </span><br><span class=\"line\">                new AssistantMessage(&quot;处理时遇到错误: &quot; + e.getMessage()));  </span><br><span class=\"line\">        return false;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后实现 ⁠act 方法，执行‌工具调用列表，得到返回结果，并将工具‎的响应添加到消息列‌表中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override  </span><br><span class=\"line\">public String act() &#123;  </span><br><span class=\"line\">    if (!toolCallChatResponse.hasToolCalls()) &#123;  </span><br><span class=\"line\">        return &quot;没有工具调用&quot;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    Prompt prompt = new Prompt(getMessageList(), chatOptions);  </span><br><span class=\"line\">    ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(prompt, toolCallChatResponse);  </span><br><span class=\"line\">    </span><br><span class=\"line\">    setMessageList(toolExecutionResult.conversationHistory());  </span><br><span class=\"line\">    </span><br><span class=\"line\">    ToolResponseMessage toolResponseMessage = (ToolResponseMessage) CollUtil.getLast(toolExecutionResult.conversationHistory());  </span><br><span class=\"line\">    String results = toolResponseMessage.getResponses().stream()  </span><br><span class=\"line\">            .map(response -&gt; &quot;工具 &quot; + response.name() + &quot; 完成了它的任务！结果: &quot; + response.responseData())  </span><br><span class=\"line\">            .collect(Collectors.joining(&quot;\\n&quot;));  </span><br><span class=\"line\">    log.info(results);  </span><br><span class=\"line\">    return results;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意维护消息上下文，不要重复添加了消息，因为 <code>toolExecutionResult.conversationHistory()</code> 方法已经包含了助手消息和工具调用返回的结果。</p>\n<p>可以带看下 toolCallingManager.executeToolCalls 的源码，会自动追加助手消息到上下文中：</p>\n<p><img src=\"/post/agent/image-20251111173200909.png\" alt=\"image-20251111173200909\"></p>\n<p><img src=\"/post/agent/image-20251111173209646.png\" alt=\"image-20251111173209646\"></p>\n<p>千万别忘了⁠，我们还需要定义一‌个终止工具，让智能体可以自行决定任‎务结束。</p>\n<p>1）在 tools 包下新建 TerminateTool：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TerminateTool &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Tool(description = &quot;&quot;&quot;  </span><br><span class=\"line\">            Terminate the interaction when the request is met OR if the assistant cannot proceed further with the task.  </span><br><span class=\"line\">            &quot;When you have finished all the tasks, call this tool to end the work.  </span><br><span class=\"line\">            &quot;&quot;&quot;)  </span><br><span class=\"line\">    public String doTerminate() &#123;  </span><br><span class=\"line\">        return &quot;任务结束&quot;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）修改 ToolRegistration，注册中止工具：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TerminateTool terminateTool = new TerminateTool();  </span><br><span class=\"line\">  </span><br><span class=\"line\">return ToolCallbacks.from(  </span><br><span class=\"line\">        fileOperationTool,  </span><br><span class=\"line\">        webSearchTool,  </span><br><span class=\"line\">        webScrapingTool,  </span><br><span class=\"line\">        resourceDownloadTool,  </span><br><span class=\"line\">        terminalOperationTool,  </span><br><span class=\"line\">        pdfGenerationTool,  </span><br><span class=\"line\">        terminateTool  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>3）完善 ⁠act 方法，当调‌用了终止工具时，修改 agent 的‎状态为 “已结束”‌：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ToolResponseMessage toolResponseMessage = (ToolResponseMessage) CollUtil.getLast(toolExecutionResult.conversationHistory());  </span><br><span class=\"line\">String results = toolResponseMessage.getResponses().stream()  </span><br><span class=\"line\">        .map(response -&gt; &quot;工具 &quot; + response.name() + &quot; 完成了它的任务！结果: &quot; + response.responseData())  </span><br><span class=\"line\">        .collect(Collectors.joining(&quot;\\n&quot;));  </span><br><span class=\"line\"></span><br><span class=\"line\">boolean terminateToolCalled = toolResponseMessage.getResponses().stream()  </span><br><span class=\"line\">        .anyMatch(response -&gt; &quot;doTerminate&quot;.equals(response.name()));  </span><br><span class=\"line\">if (terminateToolCalled) &#123;  </span><br><span class=\"line\">    setState(AgentState.FINISHED);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">log.info(results);  </span><br><span class=\"line\">return results;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、开发-AzerManus-类\"><a href=\"#4、开发-AzerManus-类\" class=\"headerlink\" title=\"4、开发 AzerManus 类\"></a>4、开发 AzerManus 类</h4><p>AzerManus 是⁠可以直接提供给其他方法调用的 AI‌ 超级智能体实例，继承自 ToolCallAgent，需要给智能体设‎置各种参数，比如对话客户端 cha‌tClient、工具调用列表等。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component  </span><br><span class=\"line\">public class AzerManus extends ToolCallAgent &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public AzerManus(ToolCallback[] allTools, ChatModel dashscopeChatModel) &#123;  </span><br><span class=\"line\">        super(allTools);  </span><br><span class=\"line\">        this.setName(&quot;AzerManus&quot;);  </span><br><span class=\"line\">        String SYSTEM_PROMPT = &quot;&quot;&quot;  </span><br><span class=\"line\">                You are AzerManus, an all-capable AI assistant, aimed at solving any task presented by the user.  </span><br><span class=\"line\">                You have various tools at your disposal that you can call upon to efficiently complete complex requests.  </span><br><span class=\"line\">                &quot;&quot;&quot;;  </span><br><span class=\"line\">        this.setSystemPrompt(SYSTEM_PROMPT);  </span><br><span class=\"line\">        String NEXT_STEP_PROMPT = &quot;&quot;&quot;  </span><br><span class=\"line\">                Based on user needs, proactively select the most appropriate tool or combination of tools.  </span><br><span class=\"line\">                For complex tasks, you can break down the problem and use different tools step by step to solve it.  </span><br><span class=\"line\">                After using each tool, clearly explain the execution results and suggest the next steps.  </span><br><span class=\"line\">                If you want to stop the interaction at any point, use the `terminate` tool/function call.  </span><br><span class=\"line\">                &quot;&quot;&quot;;  </span><br><span class=\"line\">        this.setNextStepPrompt(NEXT_STEP_PROMPT);  </span><br><span class=\"line\">        this.setMaxSteps(20);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        ChatClient chatClient = ChatClient.builder(dashscopeChatModel)  </span><br><span class=\"line\">                .defaultAdvisors(new MyLoggerAdvisor())  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        this.setChatClient(chatClient);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试智能体\"><a href=\"#测试智能体\" class=\"headerlink\" title=\"测试智能体\"></a>测试智能体</h3><p>编写单元测试类，让超级智能体完成一个较为复杂的任务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootTest  </span><br><span class=\"line\">class AzerManusTest &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Resource  </span><br><span class=\"line\">    private AzerManus azerManus;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void run() &#123;  </span><br><span class=\"line\">        String userPrompt = &quot;&quot;&quot;  </span><br><span class=\"line\">                我的另一半居住在上海静安区，请帮我找到 5 公里内合适的约会地点，  </span><br><span class=\"line\">                并结合一些网络图片，制定一份详细的约会计划，  </span><br><span class=\"line\">                并以 PDF 格式输出&quot;&quot;&quot;;  </span><br><span class=\"line\">        String answer = azerManus.run(userPrompt);  </span><br><span class=\"line\">        Assertions.assertNotNull(answer);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"一、什么是智能体？智能体（Agent）是一个能够感知环境、进行推理、制定计划、做出决策并自主采取行动以实现特定目标的 AI 系统。它以大语言模型为核心，集成 记...","permalink":"/post/agent","photos":[],"count_time":{"symbolsCount":"37k","symbolsTime":"34 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":12,"path":"api/categories/SpringBoot.json"},{"name":"Spring AI","slug":"SpringBoot/Spring-AI","count":8,"path":"api/categories/SpringBoot/Spring-AI.json"}],"tags":[{"name":"Spring AI","slug":"Spring-AI","count":9,"path":"api/tags/Spring-AI.json"},{"name":"大模型","slug":"大模型","count":9,"path":"api/tags/大模型.json"},{"name":"AI","slug":"AI","count":8,"path":"api/tags/AI.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%99%BA%E8%83%BD%E4%BD%93%EF%BC%9F\"><span class=\"toc-text\">一、什么是智能体？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%99%BA%E8%83%BD%E4%BD%93%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">智能体的分类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">二、智能体实现关键技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CoT-%E6%80%9D%E7%BB%B4%E9%93%BE\"><span class=\"toc-text\">CoT 思维链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Agent-Loop-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">Agent Loop 执行循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ReAct-%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">ReAct 模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%80%E9%9C%80%E6%94%AF%E6%8C%81%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">所需支持系统</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8-AI-%E6%99%BA%E8%83%BD%E4%BD%93\"><span class=\"toc-text\">三、使用 AI 智能体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%B9%B3%E5%8F%B0%E4%B8%AD%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1、平台中使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E8%BD%AF%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2、软件中使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3、程序中使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81OpenManus-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">四、OpenManus 实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">快速运行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OpenManus-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">OpenManus 整体架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%95%B4%E4%BD%93%E6%96%87%E4%BB%B6%E5%A4%B9%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">1、整体文件夹组织形式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81agent-%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">2、agent 目录</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81tool-%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">3、tool 目录</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81prompt-%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">4、prompt 目录</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%85%B6%E4%BB%96%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">5、其他支持</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AI-%E6%99%BA%E8%83%BD%E4%BD%93%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">AI 智能体核心实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81BaseAgent\"><span class=\"toc-text\">1、BaseAgent</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81ReActAgent\"><span class=\"toc-text\">2、ReActAgent</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81ToolCallAgent\"><span class=\"toc-text\">3、ToolCallAgent</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81Manus\"><span class=\"toc-text\">4、Manus</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MCP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%B7%A5%E5%85%B7%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">MCP 客户端用于远程工具访问</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">关键实现细节</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">1、工具系统设计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81MCP-%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">2、MCP 协议支持</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%85%B6%E4%BB%96%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">3、其他值得学习的源码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E8%87%AA%E4%B8%BB%E5%AE%9E%E7%8E%B0-Manus-%E6%99%BA%E8%83%BD%E4%BD%93\"><span class=\"toc-text\">五、自主实现 Manus 智能体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">定义数据模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E2%81%A0%E5%BF%83%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91-%E2%80%8C-%E2%80%8E-%E2%80%8C\"><span class=\"toc-text\">核⁠心架构开发    ‌                  ‎         ‌</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-Agent-%E7%B1%BB\"><span class=\"toc-text\">1、开发基础 Agent 类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%BC%80%E5%8F%91-ReActAgent-%E7%B1%BB\"><span class=\"toc-text\">2、开发 ReActAgent 类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%BC%80%E5%8F%91-ToolCallAgent-%E7%B1%BB\"><span class=\"toc-text\">3、开发 ToolCallAgent 类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%BC%80%E5%8F%91-AzerManus-%E7%B1%BB\"><span class=\"toc-text\">4、开发 AzerManus 类</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E6%99%BA%E8%83%BD%E4%BD%93\"><span class=\"toc-text\">测试智能体</span></a></li></ol></li></ol>","author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"VueUse Head","uid":"0c1a486237cc0ded727f0473b33c5eab","slug":"VueUse-Head","date":"2025-11-13T05:29:50.000Z","updated":"2025-11-13T05:31:25.860Z","comments":true,"path":"api/articles/VueUse-Head.json","keywords":"VUE、Python、JAVA","cover":"/medias/VueUse_Head.png","text":"VueUse Head 使用教程项目 介绍VueUse Head 是一个用于管理 Vue 3 应用中 <head> 标签内容的库。它允许开发者动态地设置和更新文...","permalink":"/post/VueUse-Head","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"}],"tags":[{"name":"插件","slug":"插件","count":6,"path":"api/tags/插件.json"},{"name":"vue","slug":"vue","count":3,"path":"api/tags/vue.json"}],"author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}}},"next_post":{"title":"MCP","uid":"0cec45348c42060a94488bf44a5c4b6b","slug":"MCP","date":"2025-11-11T02:21:01.000Z","updated":"2025-11-11T02:26:28.908Z","comments":true,"path":"api/articles/MCP.json","keywords":"VUE、Python、JAVA","cover":"/medias/MCP.png","text":"一、需求分析目前我们的 AI 恋爱大师已经具备了恋爱知识问答以及调用工具的能力，现在让我们再加一个实用功能：根据另一半的位置找到合适的约会地点。 你会怎么实现呢...","permalink":"/post/MCP","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":12,"path":"api/categories/SpringBoot.json"},{"name":"Spring AI","slug":"SpringBoot/Spring-AI","count":8,"path":"api/categories/SpringBoot/Spring-AI.json"}],"tags":[{"name":"Spring AI","slug":"Spring-AI","count":9,"path":"api/tags/Spring-AI.json"},{"name":"大模型","slug":"大模型","count":9,"path":"api/tags/大模型.json"},{"name":"AI","slug":"AI","count":8,"path":"api/tags/AI.json"}],"author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}}}}