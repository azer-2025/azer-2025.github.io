{"title":"RAG(2)","uid":"759217f82967d9e83558b0196a1e2331","slug":"RAG-2","date":"2025-11-08T05:13:53.000Z","updated":"2025-11-08T05:37:59.129Z","comments":true,"path":"api/articles/RAG-2.json","keywords":"VUE、Python、JAVA","cover":"/medias/RAG(2).png","content":"<p>具体内容包括：</p>\n<ul>\n<li>RAG 核心特性</li>\n<li>文档收集和切割（ETL）</li>\n<li>向量转换和存储（向量数据库）</li>\n<li>文档过滤和检索（文档检索器）</li>\n<li>查询增强和关联（上下文查询增强器）</li>\n<li>RAG 最佳实践和调优</li>\n<li>RAG 高级知识</li>\n<li>检索策略</li>\n<li>大模型幻觉</li>\n<li>高级 RAG 架构</li>\n</ul>\n<h2 id=\"一、RAG-核心特性\"><a href=\"#一、RAG-核心特性\" class=\"headerlink\" title=\"一、RAG 核心特性\"></a>一、RAG 核心特性</h2><p>这一小节我⁠们更多的是了解 R‌AG 的核心特性，重理论轻实战，下一‎小节会更注重实战。</p>\n<p>还记得上节教程中，我们讲到的 RAG 工作流程么？</p>\n<p><img src=\"/post/RAG-2/image-20251106153603353.png\" alt=\"image-20251106153603353\"></p>\n<p>上节教程中我们只是⁠按照这个流程完成了入门级 RAG ‌应用的开发，实际上每个流程都有一些值得学习的特性，Spring AI‎ 也为这些流程的技术实现提供了支持‌，下面让我们按照流程依次进行讲解。</p>\n<ul>\n<li>文档收集和切割</li>\n<li>向量转换和存储</li>\n<li>文档过滤和检索</li>\n<li>查询增强和关联</li>\n</ul>\n<h3 id=\"文档收集和切割-ETL\"><a href=\"#文档收集和切割-ETL\" class=\"headerlink\" title=\"文档收集和切割 - ETL\"></a>文档收集和切割 - ETL</h3><p>文档收集和切割阶段，我们要对自己准备好的知识库文档进行处理，然后保存到向量数据库中。这个过程俗称 ETL（抽取、转换、加载），Spring AI 提供了对 ETL 的支持，参考 <a href=\"https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html\">官方文档</a>。</p>\n<h4 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h4><p>什么是 Spring AI 中的文档呢？</p>\n<p>文档不仅仅包含文本，还可以包含一系列元信息和多媒体附件：</p>\n<p><img src=\"/post/RAG-2/image-20251106153653730.png\" alt=\"image-20251106153653730\"></p>\n<h4 id=\"ETL\"><a href=\"#ETL\" class=\"headerlink\" title=\"ETL\"></a>ETL</h4><p>在 Spr⁠ing AI 中，‌对 Document 的处理通常遵循‎以下流程：</p>\n<ol>\n<li>读取文档：使用 DocumentReader 组件从数据源（如本地文件、网络资源、数据库等）加载文档。</li>\n<li>转换文档：根据需求将文档转换为适合后续处理的格式，比如去除冗余信息、分词、词性标注等，可以使用 DocumentTransformer 组件实现。</li>\n<li>写入文档：使用 DocumentWriter 将文档以特定格式保存到存储中，比如将文档以嵌入向量的形式写入到向量数据库，或者以键值对字符串的形式保存到 Redis 等 KV 存储中。</li>\n</ol>\n<p>流程如图：</p>\n<p><img src=\"/post/RAG-2/image-20251106153714221.png\" alt=\"image-20251106153714221\"></p>\n<p>我们利用 Spr⁠ing AI 实现 ETL，核心‌就是要学习 DocumentReader、DocumentTra‎nsformer、Documen‌tWriter 三大组件。</p>\n<h4 id=\"抽取（Extract）\"><a href=\"#抽取（Extract）\" class=\"headerlink\" title=\"抽取（Extract）\"></a>抽取（Extract）</h4><p>Sprin⁠g AI 通过 D‌ocumentReader 组件实现‎文档抽取，也就是把‌文档加载到内存中。</p>\n<p>看下源码，DocumentReader 接口实现了 <code>Supplier&lt;List&lt;Document&gt;&gt;</code> 接口，主要负责从各种数据源读取数据并转换为 Document 对象集合。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface DocumentReader extends Supplier&lt;List&lt;Document&gt;&gt; &#123;</span><br><span class=\"line\">    default List&lt;Document&gt; read() &#123;</span><br><span class=\"line\">        return get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际开发中，我们可以直接使用 Spring AI 内置的多种 <a href=\"https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#_documentreaders\">DocumentReader 实现类</a>，用于处理不同类型的数据源：</p>\n<ol>\n<li>JsonReader：读取 JSON 文档</li>\n<li>TextReader：读取纯文本文件</li>\n<li>MarkdownReader：读取 Markdown 文件</li>\n<li>PDFReader：读取 PDF 文档，基于 Apache PdfBox 库实现</li>\n</ol>\n<ul>\n<li>PagePdfDocumentReader：按照分页读取 PDF</li>\n<li>ParagraphPdfDocumentReader：按照段落读取 PDF</li>\n</ul>\n<ol>\n<li>HtmlReader：读取 HTML 文档，基于 jsoup 库实现</li>\n<li>TikaDocumentReader：基于 <a href=\"https://tika.apache.org/3.1.0/formats.html\">Apache Tika</a> 库处理多种格式的文档，更灵活</li>\n</ol>\n<p>以 Json⁠Reader 为例，支‌持 JSON Pointers 特性，能够快‎速指定从 JSON 文‌档中提取哪些字段和内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyJsonReader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Resource resource;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyJsonReader(<span class=\"meta\">@Value(&quot;classpath:products.json&quot;)</span> Resource resource) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.resource = resource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; <span class=\"title function_\">loadBasicJsonDocuments</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JsonReader</span> <span class=\"variable\">jsonReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonReader</span>(<span class=\"built_in\">this</span>.resource);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonReader.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; <span class=\"title function_\">loadJsonWithSpecificFields</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JsonReader</span> <span class=\"variable\">jsonReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonReader</span>(<span class=\"built_in\">this</span>.resource, <span class=\"string\">&quot;description&quot;</span>, <span class=\"string\">&quot;features&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonReader.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; <span class=\"title function_\">loadJsonWithPointer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JsonReader</span> <span class=\"variable\">jsonReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonReader</span>(<span class=\"built_in\">this</span>.resource);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonReader.get(<span class=\"string\">&quot;/items&quot;</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更多的文档读取器等用到的时候再了解用法即可。</p>\n<p>此外，Spring AI Alibaba 官方社区提供了 <a href=\"https://java2ai.com/docs/1.0.0-M6.1/integrations/documentreader/\">更多的文档读取器</a>，比如加载飞书文档、提取 B 站视频信息和字幕、加载邮件、加载 GitHub 官方文档、加载数据库等等。</p>\n<p>比如一个邮⁠件文档读取器的实现‌其实并不难，核心代码就是解析邮件文档‎并且转换为 Doc‌ument 列表：</p>\n<p>邮件解析器的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MsgEmailParser</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">MsgEmailParser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Document <span class=\"title function_\">convertToDocument</span><span class=\"params\">(MsgEmailElement element)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (element == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;MsgEmailElement cannot be null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        Map&lt;String, Object&gt; metadata = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.hasText(element.getSubject())) &#123;</span><br><span class=\"line\">            metadata.put(<span class=\"string\">&quot;subject&quot;</span>, element.getSubject());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> StringUtils.hasText(element.getText()) ? element.getText() : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(content, metadata);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转换（Transform）\"><a href=\"#转换（Transform）\" class=\"headerlink\" title=\"转换（Transform）\"></a>转换（Transform）</h4><p>Sprin⁠g AI 通过 D‌ocumentTransformer‎ 组件实现文档转换‌。</p>\n<p>看下源码，DocumentTransformer 接口实现了 <code>Function&lt;List&lt;Document&gt;, List&lt;Document&gt;&gt;</code> 接口，负责将一组文档转换为另一组文档。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DocumentTransformer</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span>&lt;List&lt;Document&gt;, List&lt;Document&gt;&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">default</span> List&lt;Document&gt; <span class=\"title function_\">transform</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>文档转换是保证 R⁠AG 效果的核心步骤，也就是如何将大‌文档合理拆分为便于检索的知识碎片，Spring AI 提供了多种 Doc‎umentTransformer 实‌现类，可以简单分为 3 类。</p>\n<h5 id=\"1）TextSplitter-文本分割器\"><a href=\"#1）TextSplitter-文本分割器\" class=\"headerlink\" title=\"1）TextSplitter 文本分割器\"></a>1）TextSplitter 文本分割器</h5><p>其中 Te⁠xtSplitte‌r 是文本分割器的基类，提供了分割单‎词的流程方法：</p>\n<p>TokenTex⁠tSplitter 是其实现类‌，基于 Token 的文本分割器。它考虑了语义边界（比如句子‎结尾）来创建有意义的文本段落，‌是成本较低的文本切分方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTokenTextSplitter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Document&gt; <span class=\"title function_\">splitDocuments</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TokenTextSplitter</span> <span class=\"variable\">splitter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TokenTextSplitter</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> splitter.apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Document&gt; <span class=\"title function_\">splitCustomized</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TokenTextSplitter</span> <span class=\"variable\">splitter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TokenTextSplitter</span>(<span class=\"number\">1000</span>, <span class=\"number\">400</span>, <span class=\"number\">10</span>, <span class=\"number\">5000</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> splitter.apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Token⁠TextSplit‌ter 提供了两种构造函数选项：</p>\n<ol>\n<li><code>TokenTextSplitter()</code>：使用默认设置创建分割器。</li>\n<li><code>TokenTextSplitter(int defaultChunkSize, int minChunkSizeChars, int minChunkLengthToEmbed, int maxNumChunks, boolean keepSeparator)</code>：使用自定义参数创建分割器，通过调整参数，可以控制分割的粒度和方式，适应不同的应用场景。</li>\n</ol>\n<p>参数说明（无需记忆）：</p>\n<ul>\n<li>defaultChunkSize：每个文本块的目标大小（以 token 为单位，默认值：800）。</li>\n<li>minChunkSizeChars：每个文本块的最小大小（以字符为单位，默认值：350）。</li>\n<li>minChunkLengthToEmbed：要被包含的块的最小长度（默认值：5）。</li>\n<li>maxNumChunks：从文本中生成的最大块数（默认值：10000）。</li>\n<li>keepSeparator：是否在块中保留分隔符（如换行符）（默认值：true）。</li>\n</ul>\n<p>官方文档有⁠对 Token 分‌词器工作原理的详细解释，可以简单了解‎下：</p>\n<ol>\n<li>使用 CL100K_BASE 编码将输入文本编码为 token。</li>\n<li>根据 defaultChunkSize 将编码后的文本分割成块。</li>\n<li>对于每个块：</li>\n</ol>\n<ul>\n<li>将块解码回文本。</li>\n<li>尝试在 minChunkSizeChars 之后找到合适的断点（句号、问号、感叹号或换行符）。</li>\n<li>如果找到断点，则在该点截断块。</li>\n<li>修剪块并根据 keepSeparator 设置选择性地删除换行符。</li>\n<li>如果生成的块长度大于 minChunkLengthToEmbed，则将其添加到输出中。</li>\n</ul>\n<ol>\n<li>这个过程会一直持续到所有 token 都被处理完或达到 maxNumChunks 为止。</li>\n<li>如果剩余文本长度大于 minChunkLengthToEmbed，则会作为最后一个块添加。</li>\n</ol>\n<h5 id=\"2）Metada‌taEnricher-元数据增强器\"><a href=\"#2）Metada‌taEnricher-元数据增强器\" class=\"headerlink\" title=\"2）Metada‌taEnricher 元数据增强器\"></a>2）Metada‌taEnricher 元数据增强器</h5><p>元数据增强⁠器的作用是为文档补‌充更多的元信息，便于后续检索，而不是‎改变文档本身的‌切分规则。包括：</p>\n<ul>\n<li>KeywordMetadataEnricher：使用 AI 提取关键词并添加到元数据</li>\n<li>SummaryMetadataEnricher：使用 AI 生成文档摘要并添加到元数据。不仅可以为当前文档生成摘要，还能关联前一个和后一个相邻的文档，让摘要更完整。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">class MyDocumentEnricher &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final ChatModel chatModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyDocumentEnricher(ChatModel chatModel) &#123;</span><br><span class=\"line\">        this.chatModel = chatModel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      </span><br><span class=\"line\">    List&lt;Document&gt; enrichDocumentsByKeyword(List&lt;Document&gt; documents) &#123;</span><br><span class=\"line\">        KeywordMetadataEnricher enricher = new KeywordMetadataEnricher(this.chatModel, 5);</span><br><span class=\"line\">        return enricher.apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; enrichDocumentsBySummary(List&lt;Document&gt; documents) &#123;</span><br><span class=\"line\">        SummaryMetadataEnricher enricher = new SummaryMetadataEnricher(chatModel, </span><br><span class=\"line\">            List.of(SummaryType.PREVIOUS, SummaryType.CURRENT, SummaryType.NEXT));</span><br><span class=\"line\">        return enricher.apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3）Conten‌tFormatter-内容格式化工具\"><a href=\"#3）Conten‌tFormatter-内容格式化工具\" class=\"headerlink\" title=\"3）Conten‌tFormatter 内容格式化工具\"></a>3）Conten‌tFormatter 内容格式化工具</h5><p>用于统一文⁠档内容格式。官方对‌这个的介绍少的可怜，感觉像是个孤‎儿功能。。。</p>\n<p>我们不妨看它的实现类 <code>DefaultContentFormatter</code> 的源码来了解他的功能：</p>\n<p><img src=\"/post/RAG-2/image-20251106155550250.png\" alt=\"image-20251106155550250\"></p>\n<p>主要提供了 3 类功能：</p>\n<ol>\n<li>文档格式化：将文档内容与元数据合并成特定格式的字符串，以便于后续处理。</li>\n<li>元数据过滤：根据不同的元数据模式（MetadataMode）筛选需要保留的元数据项：</li>\n</ol>\n<ul>\n<li><code>ALL</code>：保留所有元数据</li>\n<li><code>NONE</code>：移除所有元数据</li>\n<li><code>INFERENCE</code>：用于推理场景，排除指定的推理元数据</li>\n<li><code>EMBED</code>：用于嵌入场景，排除指定的嵌入元数据</li>\n</ul>\n<ol>\n<li>自定义模板：支持自定义以下格式：</li>\n</ol>\n<ul>\n<li>元数据模板：控制每个元数据项的展示方式</li>\n<li>元数据分隔符：控制多个元数据项之间的分隔方式</li>\n<li>文本模板：控制元数据和内容如何结合</li>\n</ul>\n<p>该类采用 Builder 模式创建实例，使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultContentFormatter</span> <span class=\"variable\">formatter</span> <span class=\"operator\">=</span> DefaultContentFormatter.builder()</span><br><span class=\"line\">    .withMetadataTemplate(<span class=\"string\">&quot;&#123;key&#125;: &#123;value&#125;&quot;</span>)</span><br><span class=\"line\">    .withMetadataSeparator(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    .withTextTemplate(<span class=\"string\">&quot;&#123;metadata_string&#125;\\n\\n&#123;content&#125;&quot;</span>)</span><br><span class=\"line\">    .withExcludedInferenceMetadataKeys(<span class=\"string\">&quot;embedding&quot;</span>, <span class=\"string\">&quot;vector_id&quot;</span>)</span><br><span class=\"line\">    .withExcludedEmbedMetadataKeys(<span class=\"string\">&quot;source_url&quot;</span>, <span class=\"string\">&quot;timestamp&quot;</span>)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">formattedText</span> <span class=\"operator\">=</span> formatter.format(document, MetadataMode.INFERENCE);</span><br></pre></td></tr></table></figure>\n\n<p>在 RAG⁠ 系统中，这个格式‌化器可以有下面的作用，了解即可：</p>\n<ol>\n<li>提供上下文：将元数据（如文档来源、时间、标签等）与内容结合，丰富大语言模型的上下文信息</li>\n<li>过滤无关信息：通过排除特定元数据，减少噪音，提高检索和生成质量</li>\n<li>场景适配：为不同场景（如推理和嵌入）提供不同的格式化策略</li>\n<li>结构化输出：为 AI 模型提供结构化的输入，使其能更好地理解和处理文档内容</li>\n</ol>\n<h4 id=\"加载（Load）\"><a href=\"#加载（Load）\" class=\"headerlink\" title=\"加载（Load）\"></a>加载（Load）</h4><p>Sprin⁠g AI 通过 D‌ocumentWriter 组件实现‎文档加载（写入）。</p>\n<p>DocumentWriter 接口实现了 <code>Consumer&lt;List&lt;Document&gt;&gt;</code> 接口，负责将处理后的文档写入到目标存储中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DocumentWriter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Consumer</span>&lt;List&lt;Document&gt;&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        accept(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Sprin⁠g AI 提供了 ‌2 种内置的 DocumentWri‎ter 实现：</p>\n<p>1）Fil⁠eDocument‌Writer：将文档写入到文件系统</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyDocumentWriter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeDocuments</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">FileDocumentWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileDocumentWriter</span>(<span class=\"string\">&quot;output.txt&quot;</span>, <span class=\"literal\">true</span>, MetadataMode.ALL, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        writer.accept(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）Vec⁠torStoreW‌riter：将文档写入到向量数据库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyVectorStoreWriter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> VectorStore vectorStore;</span><br><span class=\"line\">    </span><br><span class=\"line\">    MyVectorStoreWriter(VectorStore vectorStore) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.vectorStore = vectorStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">storeDocuments</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        vectorStore.accept(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也⁠可以同时将文档写入‌多个存储，只需要创建多个 Write‎r 或者自定义 W‌riter 即可。</p>\n<h4 id=\"ETL-流程示例\"><a href=\"#ETL-流程示例\" class=\"headerlink\" title=\"ETL 流程示例\"></a>ETL 流程示例</h4><p>将上述 3 大组件组合起来，可以实现完整的 ETL 流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">PDFReader</span> <span class=\"variable\">pdfReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PagePdfDocumentReader</span>(<span class=\"string\">&quot;knowledge_base.pdf&quot;</span>);</span><br><span class=\"line\">List&lt;Document&gt; documents = pdfReader.read();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">TokenTextSplitter</span> <span class=\"variable\">splitter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TokenTextSplitter</span>(<span class=\"number\">500</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">List&lt;Document&gt; splitDocuments = splitter.apply(documents);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">SummaryMetadataEnricher</span> <span class=\"variable\">enricher</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SummaryMetadataEnricher</span>(chatModel, </span><br><span class=\"line\">    List.of(SummaryType.CURRENT));</span><br><span class=\"line\">List&lt;Document&gt; enrichedDocuments = enricher.apply(splitDocuments);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vectorStore.write(enrichedDocuments);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vectorStore.write(enricher.apply(splitter.apply(pdfReader.read())));</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方⁠式，我们完成了从原‌始文档到向量数据库的整个 ETL 过‎程，为后续的检索增‌强生成提供了基础。</p>\n<h2 id=\"二、向量转换和存储\"><a href=\"#二、向量转换和存储\" class=\"headerlink\" title=\"二、向量转换和存储\"></a>二、向量转换和存储</h2><p>上一节教程中有介绍过，向量存储是 RAG 应用中的核心组件，它将文档转换为向量（嵌入）并存储起来，以便后续进行高效的相似性搜索。<a href=\"https://docs.spring.io/spring-ai/reference/api/vectordbs.html\">Spring AI 官方</a> 提供了向量数据库接口 <code>VectorStore</code> 和向量存储整合包，帮助开发者快速集成各种第三方向量存储，比如 Milvus、Redis、PGVector、Elasticsearch 等。</p>\n<h4 id=\"VectorStore-接口介绍\"><a href=\"#VectorStore-接口介绍\" class=\"headerlink\" title=\"VectorStore 接口介绍\"></a>VectorStore 接口介绍</h4><p>VectorS⁠tore 是 Spring‌ AI 中用于与向量数据库交互的核心接口，它继承自 ‎DocumentWrite‌r，主要提供以下功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">VectorStore</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DocumentWriter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(List&lt;Document&gt; documents)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">delete</span><span class=\"params\">(List&lt;String&gt; idList)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">delete</span><span class=\"params\">(Filter.Expression filterExpression)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">delete</span><span class=\"params\">(String filterExpression)</span> &#123; ... &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Document&gt; <span class=\"title function_\">similaritySearch</span><span class=\"params\">(String query)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Document&gt; <span class=\"title function_\">similaritySearch</span><span class=\"params\">(SearchRequest request)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">getNativeClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个接口定⁠义了向量存储的基本‌操作，简单来说就是 “增删改查”：</p>\n<ul>\n<li>添加文档到向量库</li>\n<li>从向量库删除文档</li>\n<li>基于查询进行相似度搜索</li>\n<li>获取原生客户端（用于特定实现的高级操作）</li>\n</ul>\n<h4 id=\"搜索请求构建\"><a href=\"#搜索请求构建\" class=\"headerlink\" title=\"搜索请求构建\"></a>搜索请求构建</h4><p>Sprin⁠g AI 提供了 ‌SearchRequest 类，用于‎构建相似度搜索请求‌：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SearchRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> SearchRequest.builder()</span><br><span class=\"line\">    .query(<span class=\"string\">&quot;什么是github？&quot;</span>)</span><br><span class=\"line\">    .topK(<span class=\"number\">5</span>)                  </span><br><span class=\"line\">    .similarityThreshold(<span class=\"number\">0.7</span>) </span><br><span class=\"line\">    .filterExpression(<span class=\"string\">&quot;category == &#x27;web&#x27; AND date &gt; &#x27;2025-05-03&#x27;&quot;</span>)  </span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Document&gt; results = vectorStore.similaritySearch(request);</span><br></pre></td></tr></table></figure>\n\n<p>SearchRequest 提供了多种配置选项：</p>\n<ul>\n<li>query：搜索的查询文本</li>\n<li>topK：返回的最大结果数，默认为 4</li>\n<li>similarityThreshold：相似度阈值，低于此值的结果会被过滤掉</li>\n<li>filterExpression：基于文档元数据的过滤表达式，语法有点类似 SQL 语句，需要用到时查询 <a href=\"https://docs.spring.io/spring-ai/reference/api/vectordbs.html#metadata-filters\">官方文档</a> 了解语法即可</li>\n</ul>\n<h4 id=\"向量存储的工作原理\"><a href=\"#向量存储的工作原理\" class=\"headerlink\" title=\"向量存储的工作原理\"></a>向量存储的工作原理</h4><p>在向量数据库⁠中，查询与传统关系型数据‌库有所不同。向量库执行的是相似性搜索，而非精确匹‎配，具体流程我们在上一节‌教程中有了解，可以再复习下。</p>\n<ol>\n<li>嵌入转换：当文档被添加到向量存储时，Spring AI 会使用嵌入模型（如 OpenAI 的 text-embedding-ada-002）将文本转换为向量。</li>\n<li>相似度计算：查询时，查询文本同样被转换为向量，然后系统计算此向量与存储中所有向量的相似度。</li>\n<li>相似度度量：常用的相似度计算方法包括：</li>\n</ol>\n<ul>\n<li>余弦相似度：计算两个向量的夹角余弦值，范围在 - 1 到 1 之间</li>\n<li>欧氏距离：计算两个向量间的直线距离</li>\n<li>点积：两个向量的点积值</li>\n</ul>\n<ol>\n<li>过滤与排序：根据相似度阈值过滤结果，并按相似度排序返回最相关的文档</li>\n</ol>\n<p>对于每种 Vecto⁠r Store 实现，我们都可以参考对应‌的官方文档进行整合，开发方法基本上一致：先准备好数据源 &#x3D;&gt; 引入不同的整合包 ‎&#x3D;&gt; 编写对应的配置 &#x3D;&gt; 使用自动注入‌的 VectorStore 即可。</p>\n<p>值得一提的是，S⁠pring AI Alibaba‌ 已经集成了阿里云百炼平台，可以直接使用阿里云百炼平台提供的 V‎ectorStore API，无‌需自己再搭建向量数据库了。</p>\n<p>参考 <a href=\"https://java2ai.com/docs/1.0.0-M6.1/tutorials/vectorstore/\">官方文档</a>，主要是提供了 DashScopeCloudStore 类： </p>\n<p><img src=\"/post/RAG-2/image-20251106160832461.png\" alt=\"image-20251106160832461\"></p>\n<h4 id=\"基于-PGVector-实现向量存储\"><a href=\"#基于-PGVector-实现向量存储\" class=\"headerlink\" title=\"基于 PGVector 实现向量存储\"></a>基于 PGVector 实现向量存储</h4><p>PGVect⁠or 是经典数据库 P‌ostgreSQL 的扩展，为 Postgr‎eSQL 提供了存储和‌检索高维向量数据的能力。</p>\n<p>为什么选择它来实现向量存⁠储呢？因为很多传统业务都会把数据存储在这种关系‌型数据库中，直接给原有的数据库安装扩展就能实现向量相似度搜索、而不需要额外搞一套向量数据库，‎人力物力成本都很低，所以这种方案很受企业青睐，‌也是目前实现 RAG 的主流方案之一。</p>\n<p>首先我们准备⁠ PostgreSQL ‌数据库，并为其添加扩展。有 2 种方式，第一种是‎在自己的本地或服务器安装‌，可以参考下列文章实现：</p>\n<ul>\n<li><a href=\"https://cloud.baidu.com/article/3229759\">Linux 服务器快速安装 PostgreSQL 15 与 pgvector 向量插件实践</a></li>\n<li><a href=\"https://blog.csdn.net/qq_29213799/article/details/146277755\">宝塔 PostgreSQL 安装 pgvector 插件实现向量存储</a></li>\n</ul>\n<p>这里由于大⁠家更多的是为了学习‌，我们采用更方便的方式 —— 使用现‎成的云数据库，下面‌我们来实操下~</p>\n<p>1）首先打开 <a href=\"https://www.aliyun.com/product/rds/postgresql\">阿里云 PostgreSQL 官网</a>，开通 Serverless 版本，按用量计费，对于学习来说性价比更高：</p>\n<p><img src=\"/post/RAG-2/image-20251106170900358.png\" alt=\"image-20251106170900358\"></p>\n<p>开通 Serverless 数据库服务，填写配置：</p>\n<p><img src=\"/post/RAG-2/image-20251106171225009.png\" alt=\"image-20251106171225009\"></p>\n<p><img src=\"/post/RAG-2/image-20251106171235799.png\" alt=\"image-20251106171235799\"></p>\n<p><img src=\"/post/RAG-2/image-20251106172010016.png\" alt=\"image-20251106172010016\"></p>\n<p>2）开通成功后，进入控制台，先创建账号：</p>\n<p><img src=\"/post/RAG-2/image-20251106173414117.png\" alt=\"image-20251106173414117\"></p>\n<p>然后创建数据库：</p>\n<p><img src=\"/post/RAG-2/image-20251106173617660.png\" alt=\"image-20251106173617660\"></p>\n<p>进入插件管理，安装 vector 插件：</p>\n<p><img src=\"/post/RAG-2/image-20251106173710942.png\" alt=\"image-20251106173710942\"></p>\n<p>进入数据库连接，开通公网访问地址：</p>\n<p><img src=\"/post/RAG-2/image-20251106173944168.png\" alt=\"image-20251106173944168\"></p>\n<p>可以在本地⁠使用 IDEA 自‌带的数据库管理工具，进行连接测试：</p>\n<p>如果你的 ⁠IDEA 版本没有‌这个工具，也不用纠结，直接在云平台查‎看管理数据库即可</p>\n<p><img src=\"/post/RAG-2/image-20251106174412498.png\" alt=\"image-20251106174412498\"></p>\n<p>3）参考 <a href=\"https://docs.spring.io/spring-ai/reference/api/vectordbs/pgvector.html\">Spring AI 官方文档</a> 整合 PGVector，先引入依赖，版本号可以在 <a href=\"https://mvnrepository.com/artifact/org.springframework.ai/spring-ai-starter-vector-store-pgvector\">Maven 中央仓库</a> 查找：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.ai<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-ai-starter-vector-store-pgvector<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0.0-M7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>编写配置，建立数据库连接：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:postgresql://改为你的公网地址/azer_ai_agent</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">改为你的用户名</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">改为你的密码</span></span><br><span class=\"line\">  <span class=\"attr\">ai:</span></span><br><span class=\"line\">    <span class=\"attr\">vectorstore:</span></span><br><span class=\"line\">      <span class=\"attr\">pgvector:</span></span><br><span class=\"line\">        <span class=\"attr\">index-type:</span> <span class=\"string\">HNSW</span></span><br><span class=\"line\">        <span class=\"attr\">dimensions:</span> <span class=\"number\">1536</span></span><br><span class=\"line\">        <span class=\"attr\">distance-type:</span> <span class=\"string\">COSINE_DISTANCE</span></span><br><span class=\"line\">        <span class=\"attr\">max-document-batch-size:</span> <span class=\"number\">10000</span> </span><br></pre></td></tr></table></figure>\n\n<p>注意，在不确定向量维度的情况下，⁠建议不要指定 dimensions 配置。如果未明确指定，Pg‌VectorStore 将从提供的 EmbeddingModel 中检索维度，维度在表创建时设置为嵌入列。如果更改维度，则必‎须重新创建 Vector_store 表。不过最好提前明确你要‌使用的嵌入维度值，手动建表，更可靠一些。</p>\n<p>正常情况下⁠，接下来就可以使用‌自动注入的 VectorStore ‎了，系统会自动创建‌库表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">VectorStore vectorStore;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Document&gt; documents = List.of(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;Spring AI rocks!! Spring AI rocks!! Spring AI rocks!! Spring AI rocks!! Spring AI rocks!!&quot;</span>, Map.of(<span class=\"string\">&quot;meta1&quot;</span>, <span class=\"string\">&quot;meta1&quot;</span>)),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;The World is Big and Salvation Lurks Around the Corner&quot;</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;You walk forward facing the past and you turn back toward the future.&quot;</span>, Map.of(<span class=\"string\">&quot;meta2&quot;</span>, <span class=\"string\">&quot;meta2&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vectorStore.add(documents);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Document&gt; results = <span class=\"built_in\">this</span>.vectorStore.similaritySearch(SearchRequest.builder().query(<span class=\"string\">&quot;Spring&quot;</span>).topK(<span class=\"number\">5</span>).build());</span><br></pre></td></tr></table></figure>\n\n<p>4）让⁠我们换一种更灵活的‌方式来初始化 VectorStore‎。先引入 3 个依‌赖：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-ai-pgvector-store&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;<span class=\"number\">1.0</span><span class=\"number\">.0</span>-M6&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后编写配⁠置类自己构造 Pg‌VectorStore，不用 Sta‎rter 自动注入‌：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PgVectorVectorStoreConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> VectorStore <span class=\"title function_\">pgVectorVectorStore</span><span class=\"params\">(JdbcTemplate jdbcTemplate, EmbeddingModel dashscopeEmbeddingModel)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">VectorStore</span> <span class=\"variable\">vectorStore</span> <span class=\"operator\">=</span> PgVectorStore.builder(jdbcTemplate, dashscopeEmbeddingModel)</span><br><span class=\"line\">                .dimensions(<span class=\"number\">1536</span>)                    </span><br><span class=\"line\">                .distanceType(COSINE_DISTANCE)       </span><br><span class=\"line\">                .indexType(HNSW)                     </span><br><span class=\"line\">                .initializeSchema(<span class=\"literal\">true</span>)              </span><br><span class=\"line\">                .schemaName(<span class=\"string\">&quot;public&quot;</span>)                </span><br><span class=\"line\">                .vectorTableName(<span class=\"string\">&quot;vector_store&quot;</span>)     </span><br><span class=\"line\">                .maxDocumentBatchSize(<span class=\"number\">10000</span>)         </span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vectorStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且启动类要排除掉自动加载，否则也会报错：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication(exclude = PgVectorStoreAutoConfiguration.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">YuAiAgentApplication</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(YuAiAgentApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5）编写单元测试类，验证效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PgVectorVectorStoreConfigTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    VectorStore pgVectorVectorStore;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;Document&gt; documents = List.of(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;Spring AI rocks!! Spring AI rocks!! Spring AI rocks!! Spring AI rocks!! Spring AI rocks!!&quot;</span>, Map.of(<span class=\"string\">&quot;meta1&quot;</span>, <span class=\"string\">&quot;meta1&quot;</span>)),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;The World is Big and Salvation Lurks Around the Corner&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;You walk forward facing the past and you turn back toward the future.&quot;</span>, Map.of(<span class=\"string\">&quot;meta2&quot;</span>, <span class=\"string\">&quot;meta2&quot;</span>)));</span><br><span class=\"line\">        </span><br><span class=\"line\">        pgVectorVectorStore.add(documents);</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Document&gt; results = pgVectorVectorStore.similaritySearch(SearchRequest.builder().query(<span class=\"string\">&quot;Spring&quot;</span>).topK(<span class=\"number\">5</span>).build());</span><br><span class=\"line\">        Assertions.assertNotNull(results);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 Deb⁠ug 模式运行，可‌以看到文档检索成功，并且给出了相似度‎得分：</p>\n<p>现在我自己试的时候好像需要手动创建数据表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> vector_store (</span><br><span class=\"line\">                              id <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">                              content TEXT,</span><br><span class=\"line\">                              metadata JSONB,</span><br><span class=\"line\">                              embedding VECTOR(<span class=\"number\">1536</span>)  <span class=\"comment\">-- 根据实际向量维度调整</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestVectorStore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> VectorStore vectorStore;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        List&lt;Document&gt; documents = List.of(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;Spring AI rocks!! Spring AI rocks!! Spring AI rocks!! Spring AI rocks!! Spring AI rocks!!&quot;</span>, Map.of(<span class=\"string\">&quot;meta1&quot;</span>, <span class=\"string\">&quot;meta1&quot;</span>)),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;The World is Big and Salvation Lurks Around the Corner&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(<span class=\"string\">&quot;You walk forward facing the past and you turn back toward the future.&quot;</span>, Map.of(<span class=\"string\">&quot;meta2&quot;</span>, <span class=\"string\">&quot;meta2&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        vectorStore.add(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/RAG-2/image-20251106184602169.png\" alt=\"image-20251106184602169\"></p>\n<p>至此，我们的⁠ PGVectorSto‌re 就整合成功了。你可以用它来替换原本的本地 ‎VectorStore，自行‌测试即可。示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PgVectorVectorStoreConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoveAppDocumentLoader loveAppDocumentLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> VectorStore <span class=\"title function_\">pgVectorVectorStore</span><span class=\"params\">(JdbcTemplate jdbcTemplate, EmbeddingModel dashscopeEmbeddingModel)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">VectorStore</span> <span class=\"variable\">vectorStore</span> <span class=\"operator\">=</span> PgVectorStore.builder(jdbcTemplate, dashscopeEmbeddingModel)</span><br><span class=\"line\">                .dimensions(<span class=\"number\">1536</span>)                    </span><br><span class=\"line\">                .distanceType(COSINE_DISTANCE)       </span><br><span class=\"line\">                .indexType(HNSW)                     </span><br><span class=\"line\">                .initializeSchema(<span class=\"literal\">true</span>)              </span><br><span class=\"line\">                .schemaName(<span class=\"string\">&quot;public&quot;</span>)                </span><br><span class=\"line\">                .vectorTableName(<span class=\"string\">&quot;vector_store&quot;</span>)     </span><br><span class=\"line\">                .maxDocumentBatchSize(<span class=\"number\">10000</span>)         </span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Document&gt; documents = loveAppDocumentLoader.loadMarkdowns();</span><br><span class=\"line\">        vectorStore.add(documents);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vectorStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"扩展知识-批处理策略\"><a href=\"#扩展知识-批处理策略\" class=\"headerlink\" title=\"扩展知识 - 批处理策略\"></a>扩展知识 - 批处理策略</h4><p>在使用向量⁠存储时，可能要嵌入大‌量文档，如果一次性处理存储大量文档，可能‎会导致性能问题、甚至‌出现错误导致数据不完整。</p>\n<p>举个例子，嵌入模型⁠一般有一个最大标记限制，通常称为上下‌文窗口大小（context window size），限制了单个嵌入请求‎中可以处理的文本量。如果在一次调用中‌转换过多文档可能直接导致报错。</p>\n<p>为此，Spring⁠ AI 实现了批处理策略（Batch‌ing Strategy），将大量文档分解为较小的批次，使其适合嵌入模型‎的最大上下文窗口，还可以提高性能并更‌有效地利用 API 速率限制。</p>\n<p>Spring⁠ AI 通过 Batc‌hingStrategy 接口提供该功能，该‎接口允许基于文档的标记‌计数并以分批方式处理文档：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BatchingStrategy &#123;</span><br><span class=\"line\">    List&lt;List&lt;Document&gt;&gt; batch(List&lt;Document&gt; documents);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该接口定义了一个单一方法 <code>batch</code>，它接收一个文档列表并返回一个文档批次列表。</p>\n<p>Spring AI 提供了一⁠个名为 TokenCountBatchingStrate‌gy 的默认实现。这个策略为每个文档估算 token 数，将文档分组到不超过最大输入 token 数的批次中，如‎果单个文档超过此限制，则抛出异常。这样就确保了每个批次不‌超过计算出的最大输入 token 数。</p>\n<p>可以自定义⁠ TokenCou‌ntBatchingStrategy‎，示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmbeddingConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> BatchingStrategy <span class=\"title function_\">customTokenCountBatchingStrategy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TokenCountBatchingStrategy</span>(</span><br><span class=\"line\">            EncodingType.CL100K_BASE,  </span><br><span class=\"line\">            <span class=\"number\">8000</span>,                      </span><br><span class=\"line\">            <span class=\"number\">0.1</span>                        </span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，除了⁠使用默认策略外，也‌可以自己实现 BatchingStr‎ategy：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmbeddingConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> BatchingStrategy <span class=\"title function_\">customBatchingStrategy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomBatchingStrategy</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如你使用的向⁠量数据库每秒只能插入 1 ‌万条数据，就可以通过自实现 BatchingStra‎tegy 控制速率，还可以‌进行额外的日志记录和异常处理。</p>\n<h4 id=\"文档过滤和检索\"><a href=\"#文档过滤和检索\" class=\"headerlink\" title=\"文档过滤和检索\"></a>文档过滤和检索</h4><p>Sprin⁠g AI 官方声称‌提供了一个 “模块化” 的 RAG ‎架构，用于优化大模‌型回复的准确性。</p>\n<p>简单来说，⁠就是把整个文档过滤‌检索阶段拆分为：检索前、检索时、检索‎后，分别针对每个阶‌段提供了可自定义的组件。</p>\n<ul>\n<li>在预检索阶段，系统接收用户的原始查询，通过查询转换和查询扩展等方法对其进行优化，输出增强的用户查询。</li>\n<li>在检索阶段，系统使用增强的查询从知识库中搜索相关文档，可能涉及多个检索源的合并，最终输出一组相关文档。</li>\n<li>在检索后阶段，系统对检索到的文档进行进一步处理，包括排序、选择最相关的子集以及压缩文档内容，输出经过优化的相关文档集。</li>\n</ul>\n<h4 id=\"预检索：优化用户查询\"><a href=\"#预检索：优化用户查询\" class=\"headerlink\" title=\"预检索：优化用户查询\"></a>预检索：优化用户查询</h4><p>预检索阶段⁠负责处理和优化用户‌的原始查询，以提高后续检索的质量。S‎pring AI ‌提供了多种查询处理组件。</p>\n<h5 id=\"查询转换-查询重写\"><a href=\"#查询转换-查询重写\" class=\"headerlink\" title=\"查询转换 - 查询重写\"></a>查询转换 - 查询重写</h5><p><code>RewriteQueryTransformer</code> 使用大语言模型对用户的原始查询进行改写，使其更加清晰和详细。当用户查询含糊不清或包含无关信息时，这种方法特别有用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Query</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Query</span>(<span class=\"string\">&quot;啥是Azer啊啊啊啊？&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">QueryTransformer</span> <span class=\"variable\">queryTransformer</span> <span class=\"operator\">=</span> RewriteQueryTransformer.builder()</span><br><span class=\"line\">        .chatClientBuilder(chatClientBuilder)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Query</span> <span class=\"variable\">transformedQuery</span> <span class=\"operator\">=</span> queryTransformer.transform(query);</span><br></pre></td></tr></table></figure>\n\n<p>实现原理很简单，从源码中能看到改写查询的提示词：<img src=\"/post/RAG-2/image-20251106204930708.png\" alt=\"image-20251106204930708\"></p>\n<p>也可以通过构造方法的 <code>promptTemplate</code> 参数自定义该组件使用的提示模板。</p>\n<h5 id=\"查询转换-查询翻译\"><a href=\"#查询转换-查询翻译\" class=\"headerlink\" title=\"查询转换 - 查询翻译\"></a>查询转换 - 查询翻译</h5><p><code>TranslationQueryTransformer</code> 将查询翻译成嵌入模型支持的目标语言。如果查询已经是目标语言，则保持不变。这对于嵌入模型是针对特定语言训练而用户查询使用不同语言的情况非常有用，便于实现国际化应用。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Query</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Query</span>(<span class=\"string\">&quot;hi, who is coder Azer? please answer me&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">QueryTransformer</span> <span class=\"variable\">queryTransformer</span> <span class=\"operator\">=</span> TranslationQueryTransformer.builder()</span><br><span class=\"line\">        .chatClientBuilder(chatClientBuilder)</span><br><span class=\"line\">        .targetLanguage(<span class=\"string\">&quot;chinese&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Query</span> <span class=\"variable\">transformedQuery</span> <span class=\"operator\">=</span> queryTransformer.transform(query);</span><br></pre></td></tr></table></figure>\n\n<p>语言可以随便⁠指定，因为看源码我们会发‌现，查询翻译器也是通过给 AI 一段 Promp‎t 来实现翻译，当然也可‌以自定义翻译的 Prompt：</p>\n<p><img src=\"/post/RAG-2/image-20251106205135039.png\" alt=\"image-20251106205135039\"></p>\n<p>不过不太建⁠议使用这个查询器，因为调用 ‌AI 的成本远比调用第三方翻译 API 的成本要高，不如‎自己有样学样定义一个 Que‌ryTransformer。</p>\n<h5 id=\"查询转换-查询压缩\"><a href=\"#查询转换-查询压缩\" class=\"headerlink\" title=\"查询转换 - 查询压缩\"></a>查询转换 - 查询压缩</h5><p><code>CompressionQueryTransformer</code> 使用大语言模型将对话历史和后续查询压缩成一个独立的查询，类似于概括总结。适用于对话历史较长且后续查询与对话上下文相关的场景。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Query</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> Query.builder()</span><br><span class=\"line\">        .text(<span class=\"string\">&quot;github有啥内容？&quot;</span>)</span><br><span class=\"line\">        .history(<span class=\"keyword\">new</span> <span class=\"title class_\">UserMessage</span>(<span class=\"string\">&quot;谁是Azer？&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">AssistantMessage</span>(<span class=\"string\">&quot;github的创始人 github.io&quot;</span>))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">QueryTransformer</span> <span class=\"variable\">queryTransformer</span> <span class=\"operator\">=</span> CompressionQueryTransformer.builder()</span><br><span class=\"line\">        .chatClientBuilder(chatClientBuilder)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Query</span> <span class=\"variable\">transformedQuery</span> <span class=\"operator\">=</span> queryTransformer.transform(query);</span><br></pre></td></tr></table></figure>\n\n<p>查看源码，⁠可以看到提示词，同‌样可以定制 Prompt 模版（虽然‎感觉没什么必要）：</p>\n<p><img src=\"/post/RAG-2/image-20251106205648610.png\" alt=\"image-20251106205648610\"></p>\n<h5 id=\"查询扩展-多查询扩展\"><a href=\"#查询扩展-多查询扩展\" class=\"headerlink\" title=\"查询扩展 - 多查询扩展\"></a>查询扩展 - 多查询扩展</h5><p><code>MultiQueryExpander</code> 使用大语言模型将一个查询扩展为多个语义上不同的变体，有助于检索额外的上下文信息并增加找到相关结果的机会。就理解为我们在网上搜东西的时候，可能一种关键词搜不到，就会尝试一些不同的关键词。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MultiQueryExpander</span> <span class=\"variable\">queryExpander</span> <span class=\"operator\">=</span> MultiQueryExpander.builder()</span><br><span class=\"line\">    .chatClientBuilder(chatClientBuilder)</span><br><span class=\"line\">    .numberOfQueries(<span class=\"number\">3</span>)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">List&lt;Query&gt; queries = queryExpander.expand(<span class=\"keyword\">new</span> <span class=\"title class_\">Query</span>(<span class=\"string\">&quot;啥是Azer？他会啥？&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>上面这个查询可能被扩展为：</p>\n<ul>\n<li>请介绍Azer，以及他的专业技能</li>\n<li>给出Azer的个人简介，以及他的技能</li>\n<li>Azer有什么专业技能，并给出更多介绍</li>\n</ul>\n<p>默认情况下，会在扩展查询列表中包含原始查询。可以在构造时通过 <code>includeOriginal</code> 方法改变这个行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MultiQueryExpander</span> <span class=\"variable\">queryExpander</span> <span class=\"operator\">=</span> MultiQueryExpander.builder()</span><br><span class=\"line\">    .chatClientBuilder(chatClientBuilder)</span><br><span class=\"line\">    .includeOriginal(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<p>查看源码，⁠会先调用 AI 得‌到查询扩展，然后按照换行符分割：</p>\n<p><img src=\"/post/RAG-2/image-20251106210013256.png\" alt=\"image-20251106210013256\"></p>\n<h4 id=\"检索：提高查询相关性\"><a href=\"#检索：提高查询相关性\" class=\"headerlink\" title=\"检索：提高查询相关性\"></a>检索：提高查询相关性</h4><p>检索模块负责从存储中查询检索出最相关的文档。</p>\n<h5 id=\"文档搜索\"><a href=\"#文档搜索\" class=\"headerlink\" title=\"文档搜索\"></a>文档搜索</h5><p>之前我们有了解过 DocumentRetriever 的概念，这是 Spring AI 提供的文档检索器。每种不同的存储方案都可能有自己的文档检索器实现类，比如 <code>VectorStoreDocumentRetriever</code>，从向量存储中检索与输入查询语义相似的文档。它支持基于元数据的过滤、设置相似度阈值、设置返回的结果数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DocumentRetriever</span> <span class=\"variable\">retriever</span> <span class=\"operator\">=</span> VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">    .vectorStore(vectorStore)</span><br><span class=\"line\">    .similarityThreshold(<span class=\"number\">0.7</span>)</span><br><span class=\"line\">    .topK(<span class=\"number\">5</span>)</span><br><span class=\"line\">    .filterExpression(<span class=\"keyword\">new</span> <span class=\"title class_\">FilterExpressionBuilder</span>()</span><br><span class=\"line\">        .eq(<span class=\"string\">&quot;type&quot;</span>, <span class=\"string\">&quot;web&quot;</span>)</span><br><span class=\"line\">        .build())</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">List&lt;Document&gt; documents = retriever.retrieve(<span class=\"keyword\">new</span> <span class=\"title class_\">Query</span>(<span class=\"string\">&quot;谁是Azer&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中的 filterExpression 可以灵活地指定过滤条件。当然也可以通过构造 Query 对象的 <code>FILTER_EXPRESSION</code> 参数动态指定过滤表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Query</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> Query.builder()</span><br><span class=\"line\">    .text(<span class=\"string\">&quot;谁是Azer？&quot;</span>)</span><br><span class=\"line\">    .context(Map.of(VectorStoreDocumentRetriever.FILTER_EXPRESSION, <span class=\"string\">&quot;type == &#x27;boy&#x27;&quot;</span>))</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">List&lt;Document&gt; retrievedDocuments = documentRetriever.retrieve(query);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"文档合并\"><a href=\"#文档合并\" class=\"headerlink\" title=\"文档合并\"></a>文档合并</h5><p>Spring AI 内置了 <code>ConcatenationDocumentJoiner</code> 文档合并器，通过连接操作，将基于多个查询和来自多个数据源检索到的文档合并成单个文档集合。在遇到重复文档时，会保留首次出现的文档，每个文档的分数保持不变。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Query, List&lt;List&lt;Document&gt;&gt;&gt; documentsForQuery = ...</span><br><span class=\"line\"><span class=\"type\">DocumentJoiner</span> <span class=\"variable\">documentJoiner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcatenationDocumentJoiner</span>();</span><br><span class=\"line\">List&lt;Document&gt; documents = documentJoiner.join(documentsForQuery);</span><br></pre></td></tr></table></figure>\n\n<p>看源码发现，这玩意⁠的实现原理很简单，说是 “连接”，‌其实就是把 Map 展开为二维列表、再把二维列表展开成文档列表，最后进‎行去重。但不得不说，这段 Str‌eam API 的使用真是优雅~</p>\n<p><img src=\"/post/RAG-2/image-20251106210131942.png\" alt=\"image-20251106210131942\"></p>\n<h4 id=\"检索后：优化文档处理\"><a href=\"#检索后：优化文档处理\" class=\"headerlink\" title=\"检索后：优化文档处理\"></a>检索后：优化文档处理</h4><p>检索后模块负责⁠处理检索到的文档，以实现最‌佳生成结果。它们可以解决 “丢失在中间” 问题、模型‎上下文长度限制，以及减少检‌索信息中的噪音和冗余。</p>\n<p>这些模块可能包括：</p>\n<ul>\n<li>根据与查询的相关性对文档进行排序</li>\n<li>删除不相关或冗余的文档</li>\n<li>压缩每个文档的内容以减少噪音和冗余</li>\n</ul>\n<p>不过这个模块官方文⁠档的讲解非常少，而且更新很快，比如‌鱼皮在写本节教程时，已经从 M7 更新到了 M8，引入了新的 Doc‎umentPostProcesso‌r API 来代替原来的实现。</p>\n<h4 id=\"查询增强和关联\"><a href=\"#查询增强和关联\" class=\"headerlink\" title=\"查询增强和关联\"></a>查询增强和关联</h4><p>生成阶段是 ⁠RAG 流程的最终环节，‌负责将检索到的文档与用户查询结合起来，为 AI ‎提供必要的上下文，从而生‌成更准确、更相关的回答。</p>\n<p>之前我们已经了解了 Spring AI 提供的 2 种实现 RAG 查询增强的 Advisor，分别是 <code>QuestionAnswerAdvisor</code> 和 <code>RetrievalAugmentationAdvisor</code>。</p>\n<h5 id=\"⁠QuestionA‌nswerAdvisor-查询增强\"><a href=\"#⁠QuestionA‌nswerAdvisor-查询增强\" class=\"headerlink\" title=\"⁠QuestionA‌nswerAdvisor 查询增强\"></a>⁠QuestionA‌nswerAdvisor 查询增强</h5><p>当用户问题发⁠送到 AI 模型时，Ad‌visor 会查询向量数据库来获取与用户问题相关‎的文档，并将这些文档作为‌上下文附加到用户查询中。</p>\n<p>基本使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChatResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> ChatClient.builder(chatModel)</span><br><span class=\"line\">        .build().prompt()</span><br><span class=\"line\">        .advisors(<span class=\"keyword\">new</span> <span class=\"title class_\">QuestionAnswerAdvisor</span>(vectorStore))</span><br><span class=\"line\">        .user(userText)</span><br><span class=\"line\">        .call()</span><br><span class=\"line\">        .chatResponse();</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过建造者模式配置更精细的参数，比如文档过滤条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">qaAdvisor</span> <span class=\"operator\">=</span> QuestionAnswerAdvisor.builder(vectorStore)</span><br><span class=\"line\">              </span><br><span class=\"line\">        .searchRequest(SearchRequest.builder().similarityThreshold(<span class=\"number\">0.8d</span>).topK(<span class=\"number\">6</span>).build())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>此外，<code>QuestionAnswerAdvisor</code> 还支持动态过滤表达式，可以在运行时根据需要调整过滤条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChatClient</span> <span class=\"variable\">chatClient</span> <span class=\"operator\">=</span> ChatClient.builder(chatModel)</span><br><span class=\"line\">    .defaultAdvisors(QuestionAnswerAdvisor.builder(vectorStore)</span><br><span class=\"line\">        .searchRequest(SearchRequest.builder().build())</span><br><span class=\"line\">        .build())</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.chatClient.prompt()</span><br><span class=\"line\">    .user(<span class=\"string\">&quot;看着我的眼睛，回答我！&quot;</span>)</span><br><span class=\"line\">    .advisors(a -&gt; a.param(QuestionAnswerAdvisor.FILTER_EXPRESSION, <span class=\"string\">&quot;type == &#x27;web&#x27;&quot;</span>))</span><br><span class=\"line\">    .call()</span><br><span class=\"line\">    .content();</span><br></pre></td></tr></table></figure>\n\n<p><code>QuestionAnswerAdvisor</code> 的实现原理很简单，把用户提示词和检索到的文档等上下文信息拼成一个新的 Prompt，再调用 AI：</p>\n<p><img src=\"/post/RAG-2/image-20251106212339194.png\" alt=\"image-20251106212339194\"></p>\n<p>当然，我们⁠也可以自定义提示词‌模板，控制如何将检索到的文档与用户查‎询结合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">QuestionAnswerAdvisor</span> <span class=\"variable\">qaAdvisor</span> <span class=\"operator\">=</span> QuestionAnswerAdvisor.builder(vectorStore)</span><br><span class=\"line\">    .promptTemplate(customPromptTemplate)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"⁠Retrieval‌AugmentationAdviso‎r-查询增强\"><a href=\"#⁠Retrieval‌AugmentationAdviso‎r-查询增强\" class=\"headerlink\" title=\"⁠Retrieval‌AugmentationAdviso‎r 查询增强\"></a>⁠Retrieval‌AugmentationAdviso‎r 查询增强</h5><p>Sprin⁠g AI 提供的另一‌种 RAG 实现方式，它基于 RAG 模‎块化架构，提供了更多‌的灵活性和定制选项。</p>\n<p>最简单的 RAG 流程可以通过以下方式实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Advisor</span> <span class=\"variable\">retrievalAugmentationAdvisor</span> <span class=\"operator\">=</span> RetrievalAugmentationAdvisor.builder()</span><br><span class=\"line\">        .documentRetriever(VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">                .similarityThreshold(<span class=\"number\">0.50</span>)</span><br><span class=\"line\">                .vectorStore(vectorStore)</span><br><span class=\"line\">                .build())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">answer</span> <span class=\"operator\">=</span> chatClient.prompt()</span><br><span class=\"line\">        .advisors(retrievalAugmentationAdvisor)</span><br><span class=\"line\">        .user(question)</span><br><span class=\"line\">        .call()</span><br><span class=\"line\">        .content();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，我们配置了 <code>VectorStoreDocumentRetriever</code> 文档检索器，用于从向量存储中检索文档。然后将这个 Advisor 添加到 ChatClient 的请求中，让它处理用户的问题。</p>\n<p><code>RetrievalAugmentationAdvisor</code> 还支持更高级的 RAG 流程，比如结合查询转换器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Advisor</span> <span class=\"variable\">retrievalAugmentationAdvisor</span> <span class=\"operator\">=</span> RetrievalAugmentationAdvisor.builder()</span><br><span class=\"line\">        .queryTransformers(RewriteQueryTransformer.builder()</span><br><span class=\"line\">                .chatClientBuilder(chatClientBuilder.build().mutate())</span><br><span class=\"line\">                .build())</span><br><span class=\"line\">        .documentRetriever(VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">                .similarityThreshold(<span class=\"number\">0.50</span>)</span><br><span class=\"line\">                .vectorStore(vectorStore)</span><br><span class=\"line\">                .build())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，我们添加了一个 <code>RewriteQueryTransformer</code>，它会在检索之前重写用户的原始查询，使其更加明确和详细，从而显著提高检索的质量（因为大多数用户的原始查询是含糊不清、或者不够具体的）。</p>\n<h5 id=\"⁠Contextua‌lQueryAugmenter-空上‎下文处理\"><a href=\"#⁠Contextua‌lQueryAugmenter-空上‎下文处理\" class=\"headerlink\" title=\"⁠Contextua‌lQueryAugmenter 空上‎下文处理\"></a>⁠Contextua‌lQueryAugmenter 空上‎下文处理</h5><p>默认情况下，<code>RetrievalAugmentationAdvisor</code> 不允许检索的上下文为空。当没有找到相关文档时，它会指示模型不要回答用户查询。这是一种保守的策略，可以防止模型在没有足够信息的情况下生成不准确的回答。</p>\n<p>但在某些场景下，我们可能希望即使在没有相关文档的情况下也能为用户提供回答，比如即使没有特定知识库支持也能回答的通用问题。可以通过配置 <code>ContextualQueryAugmenter</code> 上下文查询增强器来实现。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Advisor</span> <span class=\"variable\">retrievalAugmentationAdvisor</span> <span class=\"operator\">=</span> RetrievalAugmentationAdvisor.builder()</span><br><span class=\"line\">        .documentRetriever(VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">                .similarityThreshold(<span class=\"number\">0.50</span>)</span><br><span class=\"line\">                .vectorStore(vectorStore)</span><br><span class=\"line\">                .build())</span><br><span class=\"line\">        .queryAugmenter(ContextualQueryAugmenter.builder()</span><br><span class=\"line\">                .allowEmptyContext(<span class=\"literal\">true</span>)</span><br><span class=\"line\">                .build())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>通过设置 <code>allowEmptyContext(true)</code>，允许模型在没有找到相关文档的情况下也生成回答。</p>\n<p>查看源码，⁠发现有 2 处 Pr‌ompt 的定义，分别为正常情况下对用户‎提示词的增强、以及上‌下文为空时使用的提示词：</p>\n<p><img src=\"/post/RAG-2/image-20251106212712719.png\" alt=\"image-20251106212712719\"></p>\n<p>为了提供更友好的错误处理机制，<code>ContextualQueryAugmenter</code>允许我们自定义提示模板，包括正常情况下使用的提示模板和上下文为空时使用的提示模板：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">QueryAugmenter</span> <span class=\"variable\">queryAugmenter</span> <span class=\"operator\">=</span> ContextualQueryAugmenter.builder()</span><br><span class=\"line\">        .promptTemplate(customPromptTemplate)</span><br><span class=\"line\">        .emptyContextPromptTemplate(emptyContextPromptTemplate)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>通过定制 empt⁠yContextPromptTem‌plate，我们可以指导模型在没有找到相关文档时如何回应用户，比如礼‎貌地解释无法回答的原因，并可能引导‌用户尝试其他问题或提供更多信息。</p>\n<h3 id=\"三、RAG-最佳实践和调优\"><a href=\"#三、RAG-最佳实践和调优\" class=\"headerlink\" title=\"三、RAG 最佳实践和调优\"></a>三、RAG 最佳实践和调优</h3><p>下面我们还⁠是从实现 RAG ‌的 4 大核心步骤，来实战 RAG ‎开发的最佳实践和‌优化技巧。</p>\n<h4 id=\"文档收集和切割\"><a href=\"#文档收集和切割\" class=\"headerlink\" title=\"文档收集和切割\"></a>文档收集和切割</h4><p>文档的质量⁠决定了 AI 回答‌能力的上限，其他优化策略只是让 AI‎ 回答能力不断‌接近上限。</p>\n<p>因此，文档处理是 RAG 系统中最基础也最重要的环节。</p>\n<h6 id=\"1、优化原始文档\"><a href=\"#1、优化原始文档\" class=\"headerlink\" title=\"1、优化原始文档\"></a>1、优化原始文档</h6><p><strong>知识完备性</strong> 是文档质量的首要条件。如果知识库缺失相关内容，大模型将无法准确回答对应问题。我们需要通过收集用户反馈或统计知识库检索命中率，不断完善和优化知识库内容。</p>\n<p>在知识完整的前提下，我们要注意 3 个方面：</p>\n<p>1）内容结构化：</p>\n<ul>\n<li>原始文档应保持排版清晰、结构合理，如案例编号、项目概述、设计要点等</li>\n<li>文档的各级标题层次分明，各标题下的内容表达清晰</li>\n<li>列表中间的某一条之下尽量不要再分级，减少层级嵌套</li>\n</ul>\n<p>2）内容规范化：</p>\n<ul>\n<li>语言统一：确保文档语言与用户提示词一致（比如英语场景采用英文文档），专业术语可进行多语言标注</li>\n<li>表述统一：同一概念应使用统一表达方式（比如 ML、Machine Learning 规范为 “机器学习”），可通过大模型分段处理长文档辅助完成</li>\n<li>减少噪音：尽量避免水印、表格和图片等可能影响解析的元素</li>\n</ul>\n<p>3）格式标准化：</p>\n<ul>\n<li>优先使用 Markdown、DOC&#x2F;DOCX 等文本格式（PDF 解析效果可能不佳），可以通过百炼 DashScopeParse 工具将 PDF 转为 Markdown，再借助大模型整理格式</li>\n<li>如果文档包含图片，需链接化处理，确保回答中能正常展示文档中的插图，可以通过在文档中插入可公网访问的 URL 链接实现</li>\n</ul>\n<p>这里鱼皮提出了⁠ “AI 原生文档” 的概‌念，也就是专门为 AI 知识库创作的文档。我们可以将‎上述规则输入给 AI 大模‌型，让它对已有文档进行优化。</p>\n<h6 id=\"2、文档切片\"><a href=\"#2、文档切片\" class=\"headerlink\" title=\"2、文档切片\"></a>2、文档切片</h6><p>合适的文档切片大小和方式对检索效果至关重要。</p>\n<p>文档切片尺⁠寸需要根据具体情况灵‌活调整，避免两个极端：切片过短导致语义缺‎失，切片过长引入‌无关信息。具体需结合以下因素：</p>\n<ul>\n<li>文档类型：对于专业类文献，增加长度通常有助于保留更多上下文信息；而对于社交类帖子，缩短长度则能更准确地捕捉语义</li>\n<li>提示词复杂度：如果用户的提示词较复杂且具体，则可能需要增加切片长度；反之，缩短长度会更为合适</li>\n</ul>\n<p>不当的切片方式可能导致以下问题：</p>\n<p>1）文本切片过短：出现语义缺失，导致检索时无法匹配。</p>\n<p><img src=\"/post/RAG-2/image-20251106213237575.png\" alt=\"image-20251106213237575\"></p>\n<p>2）文本切片过长：包含不相关主题，导致召回时返回无关信息。</p>\n<p>3）明显的⁠语义截断：文本切片‌出现了强制性的语义截断，导致召回时缺‎失内容。</p>\n<p>最佳文档切片策略是 <strong>结合智能分块算法和人工二次校验</strong>。智能分块算法基于分句标识符先划分为段落，再根据语义相关性动态选择切片点，避免固定长度切分导致的语义断裂。在实际应用中，应尽量让文本切片包含完整信息，同时避免包含过多干扰信息。</p>\n<p>在编程实现上，可以通过 Spring AI 的 <a href=\"https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#_tokentextsplitter\">ETL Pipeline</a> 提供的 DocumentTransformer 来调整切分规则，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyTokenTextSplitter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Document&gt; <span class=\"title function_\">splitDocuments</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TokenTextSplitter</span> <span class=\"variable\">splitter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TokenTextSplitter</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> splitter.apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Document&gt; <span class=\"title function_\">splitCustomized</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TokenTextSplitter</span> <span class=\"variable\">splitter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TokenTextSplitter</span>(<span class=\"number\">200</span>, <span class=\"number\">100</span>, <span class=\"number\">10</span>, <span class=\"number\">5000</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> splitter.apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用切分器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Resource</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MyTokenTextSplitter myTokenTextSplitter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">VectorStore <span class=\"title function_\">loveAppVectorStore</span><span class=\"params\">(EmbeddingModel dashscopeEmbeddingModel)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">SimpleVectorStore</span> <span class=\"variable\">simpleVectorStore</span> <span class=\"operator\">=</span> SimpleVectorStore.builder(dashscopeEmbeddingModel)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; documents = loveAppDocumentLoader.loadMarkdowns();</span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; splitDocuments = myTokenTextSplitter.splitCustomized(documents);</span><br><span class=\"line\">    simpleVectorStore.add(splitDocuments);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> simpleVectorStore;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而，手动调整⁠切分参数很难把握合适值，容‌易破坏语义完整性。如下图所示，每个 Markdown‎ 内的问题被强制拆分成了 ‌2 块，破坏了语义完整性：</p>\n<p>如果使用云服务，如阿里云百炼，推荐在创建知识库时选择 <strong>智能切分</strong>，这是百炼经过大量评估后总结出的推荐策略：</p>\n<p><img src=\"/post/RAG-2/image-20251106221630715.png\" alt=\"image-20251106221630715\"></p>\n<p>采用智能切分策略时，知识库会：</p>\n<ol>\n<li>首先利用系统内置的分句标识符将文档划分为若干段落</li>\n<li>基于划分的段落，根据语义相关性自适应地选择切片点进行切分，而非根据固定长度切分</li>\n</ol>\n<p>这种方法能⁠更好地保障文档语义完‌整性，避免不必要的断裂。这一策略将应用于‎知识库中的所有文档（‌包括后续导入的文档）。</p>\n<p>此外，建议在文⁠档导入知识库后进行一次人工‌检查，确认文本切片内容的语义完整性和正确性。如果发现‎切分不当或解析错误，可以直‌接编辑文本切片进行修正：</p>\n<p>需要注意，⁠这里修改的只是知识库‌中的文本切片，而非原始文档。因此，后续再‎次导入知识库时，仍需‌进行人工检查和修正。</p>\n<h6 id=\"3、元数据标注\"><a href=\"#3、元数据标注\" class=\"headerlink\" title=\"3、元数据标注\"></a>3、元数据标注</h6><p>可以为文档⁠添加丰富的结构化信‌息，俗称元信息，形成多维索引，便于后‎续向量化处理和‌精准检索。</p>\n<p>在编程实现中，可以通过多种方式为文档添加元数据：</p>\n<p>1）手动添加元信息（单个文档）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">documents.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Document</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;案例编号：LR-2023-001\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;项目概述：180平米大平层现代简约风格客厅改造\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;设计要点：\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;1. 采用5.2米挑高的落地窗，最大化自然采光\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;2. 主色调：云雾白(哑光，NCS S0500-N)配合莫兰迪灰\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;3. 家具选择：意大利B&amp;B品牌真皮沙发，北欧白橡木茶几\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;空间效果：通透大气，适合商务接待和家庭日常起居&quot;</span>,</span><br><span class=\"line\">    Map.of(</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>, <span class=\"string\">&quot;interior&quot;</span>,    </span><br><span class=\"line\">        <span class=\"string\">&quot;year&quot;</span>, <span class=\"string\">&quot;2025&quot;</span>,        </span><br><span class=\"line\">        <span class=\"string\">&quot;month&quot;</span>, <span class=\"string\">&quot;05&quot;</span>,         </span><br><span class=\"line\">        <span class=\"string\">&quot;style&quot;</span>, <span class=\"string\">&quot;modern&quot;</span>,      </span><br><span class=\"line\">    )));</span><br></pre></td></tr></table></figure>\n\n<p>2）利用 DocumentReader 批量添加元信息</p>\n<p>比如我们可⁠以在 loadMa‌rkdown 时为每篇文章添加特定标‎签，例如 “恋爱状态‌”：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> fileName.substring(fileName.length() - <span class=\"number\">6</span>, fileName.length() - <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"type\">MarkdownDocumentReaderConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> MarkdownDocumentReaderConfig.builder()</span><br><span class=\"line\">        .withHorizontalRuleCreateDocument(<span class=\"literal\">true</span>)</span><br><span class=\"line\">        .withIncludeCodeBlock(<span class=\"literal\">false</span>)</span><br><span class=\"line\">        .withIncludeBlockquote(<span class=\"literal\">false</span>)</span><br><span class=\"line\">        .withAdditionalMetadata(<span class=\"string\">&quot;filename&quot;</span>, fileName)</span><br><span class=\"line\">        .withAdditionalMetadata(<span class=\"string\">&quot;status&quot;</span>, status)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/RAG-2/image-20251106222237639.png\" alt=\"image-20251106222237639\"></p>\n<p>3）自动添加元信息：Spring AI 提供了生成元信息的 <a href=\"https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#_keywordmetadataenricher\">Transformer 组件</a>，可以基于 AI 自动解析关键词并添加到元信息中。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyKeywordEnricher</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ChatModel dashscopeChatModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Document&gt; <span class=\"title function_\">enrichDocuments</span><span class=\"params\">(List&lt;Document&gt; documents)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">KeywordMetadataEnricher</span> <span class=\"variable\">enricher</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">KeywordMetadataEnricher</span>(<span class=\"built_in\">this</span>.dashscopeChatModel, <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enricher.apply(documents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">VectorStore <span class=\"title function_\">loveAppVectorStore</span><span class=\"params\">(EmbeddingModel dashscopeEmbeddingModel)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">SimpleVectorStore</span> <span class=\"variable\">simpleVectorStore</span> <span class=\"operator\">=</span> SimpleVectorStore.builder(dashscopeEmbeddingModel)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; documents = loveAppDocumentLoader.loadMarkdowns();</span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;Document&gt; enrichedDocuments = myKeywordEnricher.enrichDocuments(documents);</span><br><span class=\"line\">    simpleVectorStore.add(enrichedDocuments);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> simpleVectorStore;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如图，系统自动补充了相关标签：</p>\n<p><img src=\"/post/RAG-2/image-20251106222258007.png\" alt=\"image-20251106222258007\"></p>\n<p>元数据抽取支持 <a href=\"https://help.aliyun.com/zh/model-studio/rag-knowledge-base/#c0fa1080aerzp\">多种规则</a>，如下图：</p>\n<p><img src=\"/post/RAG-2/image-20251106222441670.png\" alt=\"image-20251106222441670\"></p>\n<p>比如我们可⁠以使用 AI 大模‌型自动从文档中提取元信息，需要编写一‎段 Prompt：\t</p>\n<p><img src=\"/post/RAG-2/image-20251106222454024.png\" alt=\"image-20251106222454024\"></p>\n<p>抽取效果如⁠图：       ‌     </p>\n<p><img src=\"/post/RAG-2/image-20251106222504878.png\" alt=\"image-20251106222504878\"></p>\n<h5 id=\"向量转换和存储\"><a href=\"#向量转换和存储\" class=\"headerlink\" title=\"向量转换和存储\"></a>向量转换和存储</h5><p>向量转换和⁠存储是 RAG 系‌统的核心环节，直接影响检索的效率和‎准确性。</p>\n<h6 id=\"向量存储配置\"><a href=\"#向量存储配置\" class=\"headerlink\" title=\"向量存储配置\"></a>向量存储配置</h6><p>需要根据费⁠用成本、数据规模、‌性能、开发成本来选择向量存储方案，比‎如内存 &#x2F; Red‌is &#x2F; MongoDB。</p>\n<p>在编程实现中，可以通过以下方式配置向量存储：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SimpleVectorStore</span> <span class=\"variable\">vectorStore</span> <span class=\"operator\">=</span> SimpleVectorStore.builder(embeddingModel)</span><br><span class=\"line\">.build();</span><br></pre></td></tr></table></figure>\n\n<p>在云平台中⁠，通常提供多种存储‌选项，比如内置的向量存储或者云数据库‎：</p>\n<p><img src=\"/post/RAG-2/image-20251106222519073.png\" alt=\"image-20251106222519073\"></p>\n<h6 id=\"选择合适的嵌入模型\"><a href=\"#选择合适的嵌入模型\" class=\"headerlink\" title=\"选择合适的嵌入模型\"></a>选择合适的嵌入模型</h6><p>嵌入模型负⁠责将文本转换为向量‌，其质量直接影响相似度计算和检索‎准确性。可以在代码中修‌改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SimpleVectorStore</span> <span class=\"variable\">vectorStore</span> <span class=\"operator\">=</span> SimpleVectorStore.builder(embeddingModel)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<p>云平台通常提供多种嵌入模型选项：\t</p>\n<p><img src=\"/post/RAG-2/image-20251106222534242.png\" alt=\"image-20251106222534242\"></p>\n<h5 id=\"文档过滤和检索-1\"><a href=\"#文档过滤和检索-1\" class=\"headerlink\" title=\"文档过滤和检索\"></a>文档过滤和检索</h5><p>这个环节是⁠我们开发者最能大显‌身手的地方，在技术已经确定的情况下，‎优化这个环节可以显‌著提升系统整体效果。</p>\n<h6 id=\"多查询扩展\"><a href=\"#多查询扩展\" class=\"headerlink\" title=\"多查询扩展\"></a>多查询扩展</h6><p>在多轮会话场⁠景中，用户输入的提示词‌有时可能不够完整，或者存在歧义。多查询扩展技‎术可以扩大检索范围，提‌高相关文档的召回率。</p>\n<p>使用多查询扩展时，要注意：</p>\n<ul>\n<li>设置合适的查询数量（建议 3 - 5 个），过多会影响性能、增大成本</li>\n<li>保留原始查询的核心语义</li>\n</ul>\n<p>在编程实现中，可以通过以下代码实现多查询扩展：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MultiQueryExpander</span> <span class=\"variable\">queryExpander</span> <span class=\"operator\">=</span> MultiQueryExpander.builder()</span><br><span class=\"line\">    .chatClientBuilder(chatClientBuilder)</span><br><span class=\"line\">    .numberOfQueries(<span class=\"number\">3</span>)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">List&lt;Query&gt; queries = queryExpander.expand(<span class=\"keyword\">new</span> <span class=\"title class_\">Query</span>(<span class=\"string\">&quot;谁是Azer？&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>获得扩展查⁠询后，可以直接用于‌检索文档、或者提取查询文本来改写提示‎词：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DocumentRetriever</span> <span class=\"variable\">retriever</span> <span class=\"operator\">=</span> VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">    .vectorStore(vectorStore)</span><br><span class=\"line\">    .similarityThreshold(<span class=\"number\">0.73</span>)</span><br><span class=\"line\">    .topK(<span class=\"number\">5</span>)</span><br><span class=\"line\">    .filterExpression(<span class=\"keyword\">new</span> <span class=\"title class_\">FilterExpressionBuilder</span>()</span><br><span class=\"line\">        .eq(<span class=\"string\">&quot;genre&quot;</span>, <span class=\"string\">&quot;fairytale&quot;</span>)</span><br><span class=\"line\">        .build())</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Document&gt; retrievedDocuments = documentRetriever.retrieve(query);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(query.text());</span><br></pre></td></tr></table></figure>\n\n<p>多查询扩展的完整使用流程可以包括三个步骤：</p>\n<ol>\n<li>使用扩展后的查询召回文档：遍历扩展后的查询列表，对每个查询使用 <code>DocumentRetriever</code> 来召回相关文档。</li>\n<li>整合召回的文档：将每个查询召回的文档进行整合，形成一个包含所有相关信息的文档集合。（也可以使用 <a href=\"https://java2ai.com/docs/1.0.0-M6.1/tutorials/rag/#35-%E6%96%87%E6%A1%A3%E5%90%88%E5%B9%B6%E5%99%A8documentjoiner\">文档合并器</a> 去重）</li>\n<li>使用召回的文档改写 Prompt：将整合后的文档内容添加到原始 Prompt 中，为大语言模型提供更丰富的上下文信息。</li>\n</ol>\n<p>💡 需要⁠注意，多查询扩展会‌增加查询次数和计算成本，效果也不易量‎化评估，所以个人建‌议慎用这种优化方式。</p>\n<h6 id=\"查询重写和翻译\"><a href=\"#查询重写和翻译\" class=\"headerlink\" title=\"查询重写和翻译\"></a>查询重写和翻译</h6><p>查询重写和⁠翻译可以使查询更加‌精确和专业，但是要注意保持查询的语义‎完整性。</p>\n<p>主要应用包括：</p>\n<ul>\n<li>使用 <code>RewriteQueryTransformer</code> 优化查询结构</li>\n<li>配置 <code>TranslationQueryTransformer</code> 支持多语言</li>\n</ul>\n<p>参考 <a href=\"https://java2ai.com/docs/1.0.0-M6.1/tutorials/rag/#32-query-rewrite-%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99\">官方文档</a> 实现查询重写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">QueryRewriter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> QueryTransformer queryTransformer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">QueryRewriter</span><span class=\"params\">(ChatModel dashscopeChatModel)</span> &#123;</span><br><span class=\"line\">        ChatClient.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> ChatClient.builder(dashscopeChatModel);</span><br><span class=\"line\">        </span><br><span class=\"line\">        queryTransformer = RewriteQueryTransformer.builder()</span><br><span class=\"line\">                .chatClientBuilder(builder)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">doQueryRewrite</span><span class=\"params\">(String prompt)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Query</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Query</span>(prompt);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">Query</span> <span class=\"variable\">transformedQuery</span> <span class=\"operator\">=</span> queryTransformer.transform(query);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> transformedQuery.text();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应用查询重写器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Resource</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> QueryRewriter queryRewriter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">doChatWithRag</span><span class=\"params\">(String message, String chatId)</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">rewrittenMessage</span> <span class=\"operator\">=</span> queryRewriter.doQueryRewrite(message);</span><br><span class=\"line\">      <span class=\"type\">ChatResponse</span> <span class=\"variable\">chatResponse</span> <span class=\"operator\">=</span> chatClient</span><br><span class=\"line\">              .prompt()</span><br><span class=\"line\">              .user(rewrittenMessage)</span><br><span class=\"line\">              .call()</span><br><span class=\"line\">              .chatResponse();</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> chatResponse.getResult().getOutput().getText();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在云服务中，可以开启 <a href=\"https://help.aliyun.com/zh/model-studio/rag-optimization#b7031e2ad6cji\">多轮会话改写</a> 功能，自动将用户的提示词转换为更完整的形式：</p>\n<p><img src=\"/post/RAG-2/image-20251106224049171.png\" alt=\"image-20251106224049171\"></p>\n<h6 id=\"检索器配置\"><a href=\"#检索器配置\" class=\"headerlink\" title=\"检索器配置\"></a>检索器配置</h6><p>检索器配置⁠是影响检索质量的关‌键因素，主要包括三个方面：相似度阈值‎、返回文档数量和‌过滤规则。</p>\n<p><strong>1）设置合理的相似度阈值</strong></p>\n<p>相似度阈值控制文档被召回的标准，需根据具体问题调整：</p>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>知识库的召回结果不完整，没有包含全部相关的文本切片</td>\n<td>建议降低 相似度阈值，提高 召回片段数，以召回一些原本应被检索到的信息</td>\n</tr>\n<tr>\n<td>知识库的召⁠回结果中包含大量无‌关的文本切片</td>\n<td>建议提高相似度阈值‎，以排除与用户提示‌词相似度低的信息</td>\n</tr>\n</tbody></table>\n<p>在编程实现中，可以通过文档检索器配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DocumentRetriever</span> <span class=\"variable\">documentRetriever</span> <span class=\"operator\">=</span> VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">        .vectorStore(loveAppVectorStore)</span><br><span class=\"line\">        .similarityThreshold(<span class=\"number\">0.5</span>) </span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>云平台提供了更便捷的配置界面，<a href=\"https://help.aliyun.com/zh/model-studio/rag-optimization#861895e8993co\">参考文档</a>：</p>\n<p><img src=\"/post/RAG-2/image-20251106224105330.png\" alt=\"image-20251106224105330\"></p>\n<p><strong>2）控制返回文档数量（召回片段数）</strong></p>\n<p>控制返回给⁠模型的文档数量，平‌衡信息完整性和噪音水平。在编程实现中‎，可以通过文档检索‌器配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DocumentRetriever</span> <span class=\"variable\">documentRetriever</span> <span class=\"operator\">=</span> VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">        .vectorStore(loveAppVectorStore)</span><br><span class=\"line\">        .similarityThreshold(<span class=\"number\">0.5</span>) </span><br><span class=\"line\">        .topK(<span class=\"number\">3</span>) </span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>使用云平台，可以在编辑百炼应用时调整召回片段数，参考文档的 <a href=\"https://help.aliyun.com/zh/model-studio/use-cases/rag-optimization#a0086e42d9n12\">提高召回片段数</a> 部分：</p>\n<p><img src=\"/post/RAG-2/image-20251106224120284.png\" alt=\"image-20251106224120284\"></p>\n<p>召回片段数即多⁠路召回策略中的 K 值。系统‌最终会选取相似度分数最高的 K 个文本切片。不合适的 K‎ 值可能导致 RAG 漏掉正‌确的文本切片，影响回答质量。</p>\n<p>在多路召回场⁠景下，如果应用关联了多个‌知识库，系统会从这些库中检索相关文本切片，然后通‎过重排序，选出最相关的前‌ K 条提供给大模型参考。</p>\n<p><strong>3）配置文档过滤规则</strong></p>\n<p>通过文档过⁠滤规则可以控制查询‌范围，提高检索精度和效率。主要应用场‎景：</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>知识库中包含多个类别的文档，希望限定检索范围</td>\n<td>建议为文档 添加标签，知识库检索时会先根据标签筛选相关文档</td>\n</tr>\n<tr>\n<td>知识库中有⁠多篇结构相似的文档，‌希望精确定位</td>\n<td>提取元数据，知识库会先‎使用元数据进行结构化‌搜索，再进行向量检索</td>\n</tr>\n</tbody></table>\n<p>在编程实现中，运用 Spring 内置的文档检索器提供的 <a href=\"https://docs.spring.io/spring-ai/reference/api/retrieval-augmented-generation.html#_vectorstoredocumentretriever\">filterExpression</a> 配置过滤规则。</p>\n<p>写一个工厂类⁠ LoveAppRag‌CustomAdvisorFactory，根‎据用户查询需求生成对应‌的 advisor：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Slf4j</span><br><span class=\"line\">public class LoveAppRagCustomAdvisorFactory &#123;</span><br><span class=\"line\">    public static Advisor createLoveAppRagCustomAdvisor(VectorStore vectorStore, String status) &#123;</span><br><span class=\"line\">        Filter.Expression expression = new FilterExpressionBuilder()</span><br><span class=\"line\">                .eq(&quot;status&quot;, status)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        DocumentRetriever documentRetriever = VectorStoreDocumentRetriever.builder()</span><br><span class=\"line\">                .vectorStore(vectorStore)</span><br><span class=\"line\">                .filterExpression(expression) </span><br><span class=\"line\">                .similarityThreshold(0.5) </span><br><span class=\"line\">                .topK(3) </span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        return RetrievalAugmentationAdvisor.builder()</span><br><span class=\"line\">                .documentRetriever(documentRetriever)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>给恋爱大师⁠应用 LoveAp‌p 的 ChatClient 对象应‎用这个 Advis‌or：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chatClient.advisors(</span><br><span class=\"line\">    LoveAppRagCustomAdvisorFactory.createLoveAppRagCustomAdvisor(</span><br><span class=\"line\">        loveAppVectorStore, &quot;已婚&quot;</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>实际过滤效果如图：</p>\n<p><img src=\"/post/RAG-2/image-20251106224132965.png\" alt=\"image-20251106224132965\"></p>\n<p>不过阿里云⁠ DashScop‌e 文档检索器好像暂时不支持直接关联‎筛选表达式，鱼皮查‌了很久文档都没查到（</p>\n<p>使用云平台，目前百炼支持以下两种方式使用标签来实现过滤：</p>\n<ol>\n<li><p><a href=\"https://help.aliyun.com/zh/model-studio/user-guide/application-calling/#4100253b7chc3\">通过 API 调用百炼应用</a> 时，可以在请求参数 <code>tags</code> 中指定标签。</p>\n</li>\n<li><p>在控制台编辑应用时设置标签（但本方式仅适用于 <a href=\"https://help.aliyun.com/zh/model-studio/user-guide/single-agent-application/\">智能体应用</a>）。</p>\n</li>\n</ol>\n<p>云百炼还支⁠持元数据过滤，开启‌后，知识库会在向量检索前增加一层结构‎化搜索，完整过程如‌下：</p>\n<ol>\n<li>从提示词中提取元数据 {“key”: “name”, “value”: “程序员鱼皮”}</li>\n<li>根据提取的元数据，找到所有包含该元数据的文本切片</li>\n<li>再进行向量（语义）检索，找到最相关的文本切片</li>\n</ol>\n<p>通过 API 调用应用时，可以在请求参数 <code>metadata_filter</code> 中指定 metadata。应用在检索知识库时，会先根据 metadata 筛选相关文档，实现精准过滤，<a href=\"https://help.aliyun.com/zh/model-studio/application-calling-guide#6bd8094de7e1e\">参考官方文档</a>。</p>\n<p>最后，无论采用何种配置，都应 <strong>多进行命中测试</strong>，验证检索效果：</p>\n<h5 id=\"查询增强和关联-1\"><a href=\"#查询增强和关联-1\" class=\"headerlink\" title=\"查询增强和关联\"></a>查询增强和关联</h5><p>经过前面的文档检⁠索，系统已经获取了与用户查询相‌关的文档。此时，大模型需要根据用户提示词和检索内容生成最‎终回答。然而，返回结果可能仍未达到‌预期效果，需要进一步优化。</p>\n<h6 id=\"错误处理机制\"><a href=\"#错误处理机制\" class=\"headerlink\" title=\"错误处理机制\"></a>错误处理机制</h6><p>在实际应用⁠中，可能出现多种异常‌情况，如找不到相关文档、相似度过低、查询‎超时等。良好的错误处‌理机制可以提升用户体验。</p>\n<p>异常处理主要包括：</p>\n<ul>\n<li>允许空上下文查询（即处理边界情况）</li>\n<li>提供友好的错误提示</li>\n<li>引导用户提供必要信息</li>\n</ul>\n<p>边界情况处⁠理可以使用 Spri‌ng AI 的 ContextualQu‎eryAugment‌er 上下文查询增强器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RetrievalAugmentationAdvisor.builder()</span><br><span class=\"line\">    .queryAugmenter(</span><br><span class=\"line\">        ContextualQueryAugmenter.builder()</span><br><span class=\"line\">            .allowEmptyContext(<span class=\"literal\">false</span>)</span><br><span class=\"line\">            .build()</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n\n<p>如果不使用自⁠定义处理器，或者未启用‌ “允许空上下文” 选项，系统在找不到相关文‎档时会默认改写用户查询‌ userText：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The user query is outside your knowledge base.</span><br><span class=\"line\">Politely inform the user that you can<span class=\"string\">&#x27;t answer it.</span></span><br></pre></td></tr></table></figure>\n\n<p>效果如图：</p>\n<p><img src=\"/post/RAG-2/image-20251106233348794.png\" alt=\"image-20251106233348794\"></p>\n<p>如果启用 ⁠“允许空上下文”，‌系统会自动处理空 Prompt 情况‎，不会改写用户输入‌，而是使用原本的查询。</p>\n<p>我们也可以⁠自定义错误处理逻辑，‌来运用工厂模式创建一个自定义的 Cont‎extualQuer‌yAugmenter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoveAppContextualQueryAugmenterFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ContextualQueryAugmenter <span class=\"title function_\">createInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">PromptTemplate</span> <span class=\"variable\">emptyContextPromptTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PromptTemplate</span>(<span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">                你应该输出下面的内容：</span></span><br><span class=\"line\"><span class=\"string\">                抱歉，我只能回答恋爱相关的问题，别的没办法帮到您哦，</span></span><br><span class=\"line\"><span class=\"string\">                有问题可以联系编程导航客服 https://codefather.cn</span></span><br><span class=\"line\"><span class=\"string\">                &quot;&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ContextualQueryAugmenter.builder()</span><br><span class=\"line\">                .allowEmptyContext(<span class=\"literal\">false</span>)</span><br><span class=\"line\">                .emptyContextPromptTemplate(emptyContextPromptTemplate)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>给检索增强⁠生成 Adviso‌r 应用自定义的 Contextua‎lQueryAug‌menter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RetrievalAugmentationAdvisor.builder()</span><br><span class=\"line\">              .documentRetriever(documentRetriever)</span><br><span class=\"line\">              .queryAugmenter(LoveAppContextualQueryAugmenterFactory.createInstance())</span><br><span class=\"line\">              .build();</span><br></pre></td></tr></table></figure>\n\n<p>当系统无法找到相关文档时，会返回我们自定义的友好提示：</p>\n<p><img src=\"/post/RAG-2/image-20251106233359981.png\" alt=\"image-20251106233359981\"></p>\n<h6 id=\"其他建议\"><a href=\"#其他建议\" class=\"headerlink\" title=\"其他建议\"></a>其他建议</h6><p>除了上述优化策略外，还可以考虑以下方面的改进：</p>\n<table>\n<thead>\n<tr>\n<th>问题类型</th>\n<th>改进策略</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>大模型并未理解知识和用户提示词之间的关系，答案生硬拼凑</td>\n<td>建议 选择合适的大模型，提升语义理解能力</td>\n</tr>\n<tr>\n<td>返回的结果没有按照要求，或⁠者不够全面</td>\n<td>建议 优化提示词模板，引导模型生成更‌符合要求的回答</td>\n</tr>\n<tr>\n<td>返回结果不够准确，混入了模型自身的通用知识</td>\n<td>建议 开启拒识 功能，限制模型只基于知识‎库回答</td>\n</tr>\n<tr>\n<td>相似提示词，希望控制回答的一致性或多样性</td>\n<td>‌ 建议 调整大模型参数，如温度值等</td>\n</tr>\n</tbody></table>\n<p>如果有必要的话，还可以考虑更高级的优化方向，比如：</p>\n<ol>\n<li>分离检索阶段和生成阶段的知识块</li>\n<li>针对不同阶段使用不同粒度的文档，进一步提升系统性能和回答质量</li>\n<li>针对查询重写、关键词元信息增强等用到 AI 大模型的场景，可以选择相对轻量的大模型，不一定整个项目只引入一种大模型</li>\n</ol>\n","text":"具体内容包括： RAG 核心特性 文档收集和切割（ETL） 向量转换和存储（向量数据库） 文档过滤和检索（文档检索器） 查询增强和关联（上下文查询增强器） RA...","permalink":"/post/RAG-2","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":10,"path":"api/categories/SpringBoot.json"},{"name":"Spring AI","slug":"SpringBoot/Spring-AI","count":8,"path":"api/categories/SpringBoot/Spring-AI.json"}],"tags":[{"name":"Spring AI","slug":"Spring-AI","count":9,"path":"api/tags/Spring-AI.json"},{"name":"大模型","slug":"大模型","count":9,"path":"api/tags/大模型.json"},{"name":"AI","slug":"AI","count":8,"path":"api/tags/AI.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81RAG-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">一、RAG 核心特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3%E6%94%B6%E9%9B%86%E5%92%8C%E5%88%87%E5%89%B2-ETL\"><span class=\"toc-text\">文档收集和切割 - ETL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">文档</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ETL\"><span class=\"toc-text\">ETL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E5%8F%96%EF%BC%88Extract%EF%BC%89\"><span class=\"toc-text\">抽取（Extract）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E6%8D%A2%EF%BC%88Transform%EF%BC%89\"><span class=\"toc-text\">转换（Transform）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%EF%BC%89TextSplitter-%E6%96%87%E6%9C%AC%E5%88%86%E5%89%B2%E5%99%A8\"><span class=\"toc-text\">1）TextSplitter 文本分割器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%EF%BC%89Metada%E2%80%8CtaEnricher-%E5%85%83%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E5%99%A8\"><span class=\"toc-text\">2）Metada‌taEnricher 元数据增强器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%EF%BC%89Conten%E2%80%8CtFormatter-%E5%86%85%E5%AE%B9%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">3）Conten‌tFormatter 内容格式化工具</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD%EF%BC%88Load%EF%BC%89\"><span class=\"toc-text\">加载（Load）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ETL-%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">ETL 流程示例</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%90%91%E9%87%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">二、向量转换和存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#VectorStore-%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">VectorStore 接口介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%E8%AF%B7%E6%B1%82%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\">搜索请求构建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">向量存储的工作原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E-PGVector-%E5%AE%9E%E7%8E%B0%E5%90%91%E9%87%8F%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">基于 PGVector 实现向量存储</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-%E6%89%B9%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">扩展知识 - 批处理策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3%E8%BF%87%E6%BB%A4%E5%92%8C%E6%A3%80%E7%B4%A2\"><span class=\"toc-text\">文档过滤和检索</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A2%84%E6%A3%80%E7%B4%A2%EF%BC%9A%E4%BC%98%E5%8C%96%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">预检索：优化用户查询</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E8%BD%AC%E6%8D%A2-%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99\"><span class=\"toc-text\">查询转换 - 查询重写</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E8%BD%AC%E6%8D%A2-%E6%9F%A5%E8%AF%A2%E7%BF%BB%E8%AF%91\"><span class=\"toc-text\">查询转换 - 查询翻译</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E8%BD%AC%E6%8D%A2-%E6%9F%A5%E8%AF%A2%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">查询转换 - 查询压缩</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95-%E5%A4%9A%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">查询扩展 - 多查询扩展</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A3%80%E7%B4%A2%EF%BC%9A%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E6%80%A7\"><span class=\"toc-text\">检索：提高查询相关性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">文档搜索</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">文档合并</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A3%80%E7%B4%A2%E5%90%8E%EF%BC%9A%E4%BC%98%E5%8C%96%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86\"><span class=\"toc-text\">检索后：优化文档处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E5%A2%9E%E5%BC%BA%E5%92%8C%E5%85%B3%E8%81%94\"><span class=\"toc-text\">查询增强和关联</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%81%A0QuestionA%E2%80%8CnswerAdvisor-%E6%9F%A5%E8%AF%A2%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">⁠QuestionA‌nswerAdvisor 查询增强</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%81%A0Retrieval%E2%80%8CAugmentationAdviso%E2%80%8Er-%E6%9F%A5%E8%AF%A2%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">⁠Retrieval‌AugmentationAdviso‎r 查询增强</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%81%A0Contextua%E2%80%8ClQueryAugmenter-%E7%A9%BA%E4%B8%8A%E2%80%8E%E4%B8%8B%E6%96%87%E5%A4%84%E7%90%86\"><span class=\"toc-text\">⁠Contextua‌lQueryAugmenter 空上‎下文处理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81RAG-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">三、RAG 最佳实践和调优</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3%E6%94%B6%E9%9B%86%E5%92%8C%E5%88%87%E5%89%B2\"><span class=\"toc-text\">文档收集和切割</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1%E3%80%81%E4%BC%98%E5%8C%96%E5%8E%9F%E5%A7%8B%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">1、优化原始文档</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%96%87%E6%A1%A3%E5%88%87%E7%89%87\"><span class=\"toc-text\">2、文档切片</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%85%83%E6%95%B0%E6%8D%AE%E6%A0%87%E6%B3%A8\"><span class=\"toc-text\">3、元数据标注</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">向量转换和存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">向量存储配置</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">选择合适的嵌入模型</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3%E8%BF%87%E6%BB%A4%E5%92%8C%E6%A3%80%E7%B4%A2-1\"><span class=\"toc-text\">文档过滤和检索</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">多查询扩展</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99%E5%92%8C%E7%BF%BB%E8%AF%91\"><span class=\"toc-text\">查询重写和翻译</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%A3%80%E7%B4%A2%E5%99%A8%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">检索器配置</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E5%A2%9E%E5%BC%BA%E5%92%8C%E5%85%B3%E8%81%94-1\"><span class=\"toc-text\">查询增强和关联</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">错误处理机制</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE\"><span class=\"toc-text\">其他建议</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Ai Tool","uid":"f3cc45dde1c6d3f1266c71ae166c094a","slug":"Ai-Tool","date":"2025-11-08T14:48:33.000Z","updated":"2025-11-08T14:53:25.082Z","comments":true,"path":"api/articles/Ai-Tool.json","keywords":"VUE、Python、JAVA","cover":"/medias/tool.png","text":"一、需求分析之前我们通过 RAG 技术让 AI 应用具备了根据外部知识库来获取信息并回答的能力，但是直到目前为止，AI 应用还只是个 “知识问答助手”。本节我们...","permalink":"/post/Ai-Tool","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":10,"path":"api/categories/SpringBoot.json"},{"name":"Spring AI","slug":"SpringBoot/Spring-AI","count":8,"path":"api/categories/SpringBoot/Spring-AI.json"}],"tags":[{"name":"Spring AI","slug":"Spring-AI","count":9,"path":"api/tags/Spring-AI.json"},{"name":"大模型","slug":"大模型","count":9,"path":"api/tags/大模型.json"},{"name":"AI","slug":"AI","count":8,"path":"api/tags/AI.json"}],"author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}}},"next_post":{"title":"RAG(1)","uid":"0b6174194fca75a66e45364f4a9eec76","slug":"RAG-1","date":"2025-11-06T04:59:49.000Z","updated":"2025-11-06T05:03:39.663Z","comments":true,"path":"api/articles/RAG-1.json","keywords":"VUE、Python、JAVA","cover":"/medias/RAG(1).png","text":"0.引言如何让 AI 获取知识？在实现需求前，我们需要思考一个关键问题：恋爱知识从哪里获取呢？ 首先 AI 原本就拥有一些通用的⁠知识，对于不会的知识，还可以利...","permalink":"/post/RAG-1","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":10,"path":"api/categories/SpringBoot.json"},{"name":"Spring AI","slug":"SpringBoot/Spring-AI","count":8,"path":"api/categories/SpringBoot/Spring-AI.json"}],"tags":[{"name":"Spring AI","slug":"Spring-AI","count":9,"path":"api/tags/Spring-AI.json"},{"name":"大模型","slug":"大模型","count":9,"path":"api/tags/大模型.json"},{"name":"AI","slug":"AI","count":8,"path":"api/tags/AI.json"}],"author":{"name":"Azer","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"<span style='font-size:30px;background:linear-gradient(90deg,#00c6ff,#0072ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'>怀民亦未寝</span><span style='font-size:30px;'>💕</span>","socials":{"github":"https://github.com/azer-2025","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_52541129?type=blog","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1764589563?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/azzzer"}}}}}}